# Mark Notification Tray Seen

<CardGroup cols={2}>
  <Card title="Global Tray Tracking" icon="globe">
    Update the tray's seen timestamp on server when user visits the Notification Tray screen
  </Card>
  <Card title="Badge Management" icon="bell">
    Control UI badge indicators based on global seen status
  </Card>
</CardGroup>

## Overview

Use `markNotificationTraySeen()` to update the tray's seen timestamp on the server when the user visits the Notification Tray screen.

This method supports **global-level read tracking**, separate from per-item seen state. Once invoked, future calls to `getNotificationTraySeen()` will return the new `isSeen` value. It is recommended to call this method as soon as the tray UI is opened.

<Note>
This method updates the **global tray seen state**, not individual notification items. Use `markSeen()` on individual items for fine-grained tracking.
</Note>

## Implementation Guide

<Tabs>
  <Tab title="iOS">
    <CodeGroup>
      ```swift Basic Implementation
      import AmitySDK
      
      class NotificationTrayViewController: UIViewController {
          private let repository = AmityNotificationTrayRepository()
          
          override func viewDidAppear(_ animated: Bool) {
              super.viewDidAppear(animated)
              
              // Mark tray as seen when user opens it
              markTrayAsSeen()
          }
          
          private func markTrayAsSeen() {
              repository.markNotificationTraySeen { [weak self] result in
                  DispatchQueue.main.async {
                      switch result {
                      case .success:
                          self?.updateGlobalBadgeState()
                      case .failure(let error):
                          print("Failed to mark tray as seen: \(error)")
                      }
                  }
              }
          }
          
          private func updateGlobalBadgeState() {
              // Update global app badge
              NotificationCenter.default.post(
                  name: .notificationTrayMarkedAsSeen,
                  object: nil
              )
          }
      }
      ```
      
      ```swift Advanced Implementation with Badge Management
      class NotificationBadgeManager {
          private let repository = AmityNotificationTrayRepository()
          private var isUpdatingBadge = false
          
          func markTraySeenAndUpdateBadge() {
              guard !isUpdatingBadge else { return }
              isUpdatingBadge = true
              
              repository.markNotificationTraySeen { [weak self] result in
                  DispatchQueue.main.async {
                      self?.isUpdatingBadge = false
                      
                      switch result {
                      case .success:
                          self?.refreshGlobalBadgeState()
                      case .failure(let error):
                          self?.handleBadgeUpdateError(error)
                      }
                  }
              }
          }
          
          private func refreshGlobalBadgeState() {
              // Refresh the global seen state to update badges across the app
              repository.getNotificationTraySeen { [weak self] result in
                  DispatchQueue.main.async {
                      switch result {
                      case .success(let trayData):
                          self?.updateAppBadges(hasUnseen: !trayData.isSeen)
                      case .failure(let error):
                          print("Failed to refresh badge state: \(error)")
                      }
                  }
              }
          }
          
          private func updateAppBadges(hasUnseen: Bool) {
              // Update tab bar badge
              if let tabBarController = UIApplication.shared.keyWindow?.rootViewController as? UITabBarController,
                 let notificationTabIndex = tabBarController.viewControllers?.firstIndex(where: { $0 is NotificationTrayViewController }) {
                  tabBarController.tabBar.items?[notificationTabIndex].badgeValue = hasUnseen ? "‚óè" : nil
              }
              
              // Update app icon badge
              UIApplication.shared.applicationIconBadgeNumber = hasUnseen ? 1 : 0
              
              // Notify other parts of the app
              NotificationCenter.default.post(
                  name: .globalNotificationBadgeChanged,
                  object: nil,
                  userInfo: ["hasUnseen": hasUnseen]
              )
          }
      }
      ```
    </CodeGroup>
  </Tab>
  
  <Tab title="Android">
    <CodeGroup>
      ```kotlin Basic Implementation
      import com.amity.socialcloud.sdk.AmityCoreClient
      
      class NotificationTrayActivity : AppCompatActivity() {
          private lateinit var repository: AmityNotificationTrayRepository
          
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              repository = AmityCoreClient.newNotificationRepository()
          }
          
          override fun onResume() {
              super.onResume()
              
              // Mark tray as seen when user opens it
              markTrayAsSeen()
          }
          
          private fun markTrayAsSeen() {
              repository.markNotificationTraySeen()
                  .observeOn(AndroidSchedulers.mainThread())
                  .subscribe({
                      updateGlobalBadgeState()
                  }, { error ->
                      Log.e("NotificationTray", "Failed to mark tray as seen", error)
                  })
          }
          
          private fun updateGlobalBadgeState() {
              // Update global app badge
              val intent = Intent(ACTION_NOTIFICATION_TRAY_MARKED_SEEN)
              LocalBroadcastManager.getInstance(this).sendBroadcast(intent)
          }
          
          companion object {
              const val ACTION_NOTIFICATION_TRAY_MARKED_SEEN = "com.app.notification_tray_marked_seen"
          }
      }
      ```
      
      ```kotlin Advanced Implementation with Badge Management
      class NotificationBadgeManager(private val context: Context) {
          private val repository = AmityCoreClient.newNotificationRepository()
          private var isUpdatingBadge = false
          
          fun markTraySeenAndUpdateBadge() {
              if (isUpdatingBadge) return
              isUpdatingBadge = true
              
              repository.markNotificationTraySeen()
                  .observeOn(AndroidSchedulers.mainThread())
                  .subscribe({
                      isUpdatingBadge = false
                      refreshGlobalBadgeState()
                  }, { error ->
                      isUpdatingBadge = false
                      handleBadgeUpdateError(error)
                  })
          }
          
          private fun refreshGlobalBadgeState() {
              // Refresh the global seen state to update badges across the app
              repository.getNotificationTraySeen()
                  .observeOn(AndroidSchedulers.mainThread())
                  .subscribe({ trayData ->
                      updateAppBadges(!trayData.isSeen)
                  }, { error ->
                      Log.e("BadgeManager", "Failed to refresh badge state", error)
                  })
          }
          
          private fun updateAppBadges(hasUnseen: Boolean) {
              // Update bottom navigation badge
              val intent = Intent(ACTION_GLOBAL_NOTIFICATION_BADGE_CHANGED)
              intent.putExtra("hasUnseen", hasUnseen)
              LocalBroadcastManager.getInstance(context).sendBroadcast(intent)
              
              // Update app shortcut badge (Android 8.0+)
              if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                  val shortcutManager = context.getSystemService(ShortcutManager::class.java)
                  try {
                      shortcutManager?.reportShortcutUsed("notification_tray")
                  } catch (e: Exception) {
                      Log.w("BadgeManager", "Failed to update shortcut badge", e)
                  }
              }
          }
          
          companion object {
              const val ACTION_GLOBAL_NOTIFICATION_BADGE_CHANGED = "com.app.global_notification_badge_changed"
          }
      }
      ```
    </CodeGroup>
  </Tab>
  
  <Tab title="Web">
    <CodeGroup>
      ```typescript Basic Implementation
      import { AmityNotificationTrayRepository } from '@amityco/ts-sdk';
      
      class NotificationTrayManager {
          private repository: AmityNotificationTrayRepository;
          
          constructor() {
              this.repository = new AmityNotificationTrayRepository();
          }
          
          async onTrayOpened(): Promise<void> {
              try {
                  // Mark tray as seen when user opens it
                  await this.markTrayAsSeen();
              } catch (error) {
                  console.error('Failed to mark tray as seen:', error);
              }
          }
          
          private async markTrayAsSeen(): Promise<void> {
              await this.repository.markNotificationTraySeen();
              this.updateGlobalBadgeState();
          }
          
          private updateGlobalBadgeState(): void {
              // Emit custom event for global badge updates
              const event = new CustomEvent('notificationTrayMarkedSeen');
              window.dispatchEvent(event);
          }
      }
      ```
      
      ```typescript React Hook Implementation
      import React, { useEffect, useCallback } from 'react';
      import { AmityNotificationTrayRepository } from '@amityco/ts-sdk';
      
      interface UseNotificationTrayResult {
          markTrayAsSeen: () => Promise<void>;
          isMarking: boolean;
          error: Error | null;
      }
      
      export const useNotificationTray = (): UseNotificationTrayResult => {
          const [isMarking, setIsMarking] = useState(false);
          const [error, setError] = useState<Error | null>(null);
          const repository = new AmityNotificationTrayRepository();
          
          const markTrayAsSeen = useCallback(async () => {
              setIsMarking(true);
              setError(null);
              
              try {
                  await repository.markNotificationTraySeen();
                  
                  // Update global badge state
                  const event = new CustomEvent('notificationTrayMarkedSeen');
                  window.dispatchEvent(event);
              } catch (err) {
                  setError(err as Error);
                  throw err;
              } finally {
                  setIsMarking(false);
              }
          }, [repository]);
          
          return { markTrayAsSeen, isMarking, error };
      };
      
      // Usage in component
      const NotificationTrayScreen: React.FC = () => {
          const { markTrayAsSeen } = useNotificationTray();
          
          useEffect(() => {
              // Mark as seen when component mounts (tray is opened)
              markTrayAsSeen();
          }, [markTrayAsSeen]);
          
          return (
              <div className="notification-tray">
                  {/* Tray content */}
              </div>
          );
      };
      ```
      
      ```typescript Advanced Badge Management System
      class GlobalNotificationBadgeManager {
          private repository: AmityNotificationTrayRepository;
          private badgeElements: Set<HTMLElement> = new Set();
          private currentUnseenState: boolean = false;
          
          constructor() {
              this.repository = new AmityNotificationTrayRepository();
              this.setupEventListeners();
          }
          
          private setupEventListeners(): void {
              // Listen for tray marked as seen
              window.addEventListener('notificationTrayMarkedSeen', () => {
                  this.refreshGlobalBadgeState();
              });
              
              // Listen for new notifications (if you have real-time events)
              window.addEventListener('newNotificationReceived', () => {
                  this.refreshGlobalBadgeState();
              });
          }
          
          async markTraySeenAndUpdateBadges(): Promise<void> {
              try {
                  await this.repository.markNotificationTraySeen();
                  await this.refreshGlobalBadgeState();
              } catch (error) {
                  console.error('Failed to mark tray as seen and update badges:', error);
              }
          }
          
          private async refreshGlobalBadgeState(): Promise<void> {
              try {
                  const trayData = await this.repository.getNotificationTraySeen();
                  const hasUnseen = !trayData.isSeen;
                  
                  if (this.currentUnseenState !== hasUnseen) {
                      this.currentUnseenState = hasUnseen;
                      this.updateAllBadges(hasUnseen);
                  }
              } catch (error) {
                  console.error('Failed to refresh global badge state:', error);
              }
          }
          
          registerBadgeElement(element: HTMLElement): void {
              this.badgeElements.add(element);
              this.updateBadgeElement(element, this.currentUnseenState);
          }
          
          unregisterBadgeElement(element: HTMLElement): void {
              this.badgeElements.delete(element);
          }
          
          private updateAllBadges(hasUnseen: boolean): void {
              this.badgeElements.forEach(element => {
                  this.updateBadgeElement(element, hasUnseen);
              });
              
              // Update document title badge
              this.updateDocumentTitle(hasUnseen);
              
              // Update favicon badge (if you have a library for this)
              this.updateFaviconBadge(hasUnseen);
          }
          
          private updateBadgeElement(element: HTMLElement, hasUnseen: boolean): void {
              if (hasUnseen) {
                  element.classList.add('has-notification');
                  element.setAttribute('data-badge', '‚óè');
              } else {
                  element.classList.remove('has-notification');
                  element.removeAttribute('data-badge');
              }
          }
          
          private updateDocumentTitle(hasUnseen: boolean): void {
              const baseTitle = 'My App';
              document.title = hasUnseen ? `(1) ${baseTitle}` : baseTitle;
          }
          
          private updateFaviconBadge(hasUnseen: boolean): void {
              // Implementation depends on favicon badge library
              // This is a placeholder for favicon badge updates
              console.log(`Favicon badge should be ${hasUnseen ? 'shown' : 'hidden'}`);
          }
      }
      ```
    </CodeGroup>
  </Tab>
  
  <Tab title="Flutter">
    <CodeGroup>
      ```dart Basic Implementation
      import 'package:amity_sdk/amity_sdk.dart';
      
      class NotificationTrayScreen extends StatefulWidget {
          @override
          _NotificationTrayScreenState createState() => _NotificationTrayScreenState();
      }
      
      class _NotificationTrayScreenState extends State<NotificationTrayScreen> {
          late AmityNotificationTrayRepository _repository;
          
          @override
          void initState() {
              super.initState();
              _repository = AmityNotificationTrayRepository();
              
              // Mark tray as seen when screen is opened
              WidgetsBinding.instance.addPostFrameCallback((_) {
                  _markTrayAsSeen();
              });
          }
          
          Future<void> _markTrayAsSeen() async {
              try {
                  await _repository.markNotificationTraySeen();
                  _updateGlobalBadgeState();
              } catch (error) {
                  print('Failed to mark tray as seen: $error');
              }
          }
          
          void _updateGlobalBadgeState() {
              // Notify other parts of the app
              NotificationBadgeManager.instance.refreshBadgeState();
          }
          
          @override
          Widget build(BuildContext context) {
              return Scaffold(
                  appBar: AppBar(title: Text('Notifications')),
                  body: NotificationTrayList(),
              );
          }
      }
      ```
      
      ```dart Advanced Badge Management System
      class NotificationBadgeManager {
          static final NotificationBadgeManager _instance = NotificationBadgeManager._internal();
          static NotificationBadgeManager get instance => _instance;
          
          NotificationBadgeManager._internal();
          
          late AmityNotificationTrayRepository _repository;
          final ValueNotifier<bool> hasUnseenNotifications = ValueNotifier<bool>(false);
          bool _isUpdating = false;
          
          void initialize() {
              _repository = AmityNotificationTrayRepository();
          }
          
          Future<void> markTraySeenAndUpdateBadges() async {
              if (_isUpdating) return;
              _isUpdating = true;
              
              try {
                  await _repository.markNotificationTraySeen();
                  await refreshBadgeState();
              } catch (error) {
                  print('Failed to mark tray as seen and update badges: $error');
              } finally {
                  _isUpdating = false;
              }
          }
          
          Future<void> refreshBadgeState() async {
              try {
                  final trayData = await _repository.getNotificationTraySeen();
                  final hasUnseen = !trayData.isSeen;
                  
                  if (hasUnseenNotifications.value != hasUnseen) {
                      hasUnseenNotifications.value = hasUnseen;
                      _updateAppBadges(hasUnseen);
                  }
              } catch (error) {
                  print('Failed to refresh badge state: $error');
              }
          }
          
          void _updateAppBadges(bool hasUnseen) {
              // Update app badge (iOS only, requires flutter_app_badger package)
              // FlutterAppBadger.updateBadgeCount(hasUnseen ? 1 : 0);
              
              // Update bottom navigation badge
              // This would typically be handled by listening to hasUnseenNotifications
              print('Global notification badge should be ${hasUnseen ? 'shown' : 'hidden'}');
          }
      }
      
      // Usage in main app widget
      class MyApp extends StatelessWidget {
          @override
          Widget build(BuildContext context) {
              return MaterialApp(
                  home: MainBottomNavigation(),
              );
          }
      }
      
      class MainBottomNavigation extends StatefulWidget {
          @override
          _MainBottomNavigationState createState() => _MainBottomNavigationState();
      }
      
      class _MainBottomNavigationState extends State<MainBottomNavigation> {
          int _currentIndex = 0;
          
          @override
          void initState() {
              super.initState();
              NotificationBadgeManager.instance.initialize();
          }
          
          @override
          Widget build(BuildContext context) {
              return Scaffold(
                  body: _getBody(),
                  bottomNavigationBar: ValueListenableBuilder<bool>(
                      valueListenable: NotificationBadgeManager.instance.hasUnseenNotifications,
                      builder: (context, hasUnseen, child) {
                          return BottomNavigationBar(
                              currentIndex: _currentIndex,
                              onTap: (index) {
                                  setState(() {
                                      _currentIndex = index;
                                  });
                                  
                                  // If navigating to notifications tab, mark as seen
                                  if (index == 2) { // Assuming notifications is at index 2
                                      NotificationBadgeManager.instance.markTraySeenAndUpdateBadges();
                                  }
                              },
                              items: [
                                  BottomNavigationBarItem(
                                      icon: Icon(Icons.home),
                                      label: 'Home',
                                  ),
                                  BottomNavigationBarItem(
                                      icon: Icon(Icons.search),
                                      label: 'Search',
                                  ),
                                  BottomNavigationBarItem(
                                      icon: Stack(
                                          children: [
                                              Icon(Icons.notifications),
                                              if (hasUnseen)
                                                  Positioned(
                                                      right: 0,
                                                      top: 0,
                                                      child: Container(
                                                          width: 8,
                                                          height: 8,
                                                          decoration: BoxDecoration(
                                                              color: Colors.red,
                                                              shape: BoxShape.circle,
                                                          ),
                                                      ),
                                                  ),
                                          ],
                                      ),
                                      label: 'Notifications',
                                  ),
                              ],
                          );
                      },
                  ),
              );
          }
      }
      ```
    </CodeGroup>
  </Tab>
</Tabs>

## Usage Patterns

<AccordionGroup>
  <Accordion title="üéØ When to Mark Tray as Seen">
    <CardGroup cols={2}>
      <Card title="Screen Visibility" icon="eye">
        **Primary Triggers**
        - User opens/navigates to notification tray screen
        - Tray becomes visible in UI (viewDidAppear, onResume)
        - User focuses on notification tray tab/section
      </Card>
      <Card title="User Intent" icon="user">
        **Secondary Triggers**
        - User pulls-to-refresh in tray
        - User explicitly marks "all as read"
        - User interacts with tray controls
      </Card>
    </CardGroup>
    
    ### Implementation Timing Examples
    
    <Tabs>
      <Tab title="iOS">
        ```swift
        // Option 1: Mark when view appears (recommended)
        override func viewDidAppear(_ animated: Bool) {
            super.viewDidAppear(animated)
            markTrayAsSeen()
        }
        
        // Option 2: Mark with slight delay for better UX
        override func viewDidAppear(_ animated: Bool) {
            super.viewDidAppear(animated)
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                self.markTrayAsSeen()
            }
        }
        
        // Option 3: Mark when user scrolls (indicating engagement)
        func scrollViewDidScroll(_ scrollView: UIScrollView) {
            if !hasMarkedAsSeen && scrollView.contentOffset.y > 50 {
                hasMarkedAsSeen = true
                markTrayAsSeen()
            }
        }
        ```
      </Tab>
      
      <Tab title="Android">
        ```kotlin
        // Option 1: Mark when activity resumes (recommended)
        override fun onResume() {
            super.onResume()
            markTrayAsSeen()
        }
        
        // Option 2: Mark with delay for better UX
        override fun onResume() {
            super.onResume()
            Handler(Looper.getMainLooper()).postDelayed({
                markTrayAsSeen()
            }, 500)
        }
        
        // Option 3: Mark when RecyclerView is scrolled
        private val scrollListener = object : RecyclerView.OnScrollListener() {
            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
                if (!hasMarkedAsSeen && dy > 0) {
                    hasMarkedAsSeen = true
                    markTrayAsSeen()
                }
            }
        }
        ```
      </Tab>
      
      <Tab title="Web">
        ```typescript
        // Option 1: Mark when component mounts (recommended)
        useEffect(() => {
            markTrayAsSeen();
        }, []);
        
        // Option 2: Mark with delay for better UX
        useEffect(() => {
            const timer = setTimeout(() => {
                markTrayAsSeen();
            }, 500);
            
            return () => clearTimeout(timer);
        }, []);
        
        // Option 3: Mark when user scrolls
        useEffect(() => {
            const handleScroll = () => {
                if (!hasMarkedAsSeen && window.scrollY > 50) {
                    setHasMarkedAsSeen(true);
                    markTrayAsSeen();
                }
            };
            
            window.addEventListener('scroll', handleScroll);
            return () => window.removeEventListener('scroll', handleScroll);
        }, [hasMarkedAsSeen]);
        ```
      </Tab>
    </Tabs>
  </Accordion>

  <Accordion title="üîÑ State Synchronization Patterns">
    ### Global Badge Management Flow
    
    ```mermaid
    sequenceDiagram
        participant User
        participant TrayScreen
        participant BadgeManager
        participant Server
        participant UIComponents
        
        User->>TrayScreen: Opens Notification Tray
        TrayScreen->>Server: markNotificationTraySeen()
        Server-->>TrayScreen: Success response
        TrayScreen->>BadgeManager: updateGlobalBadgeState()
        BadgeManager->>Server: getNotificationTraySeen()
        Server-->>BadgeManager: Return updated state
        BadgeManager->>UIComponents: Update all badges
        UIComponents-->>User: Hide notification badges
    ```
    
    ### Cross-screen Badge Updates
    
    <CardGroup cols={2}>
      <Card title="Tab Bar Badges" icon="folder-tree">
        Update navigation tab indicators when tray is marked as seen
      </Card>
      <Card title="App Icon Badge" icon="mobile-screen">
        Clear app icon badge count when global tray is seen
      </Card>
      <Card title="Header Indicators" icon="bell">
        Update header notification bells and counters
      </Card>
      <Card title="Menu Badges" icon="bars">
        Clear sidebar or menu notification indicators
      </Card>
    </CardGroup>
  </Accordion>

  <Accordion title="üé® UI State Management">
    ### Before and After Visual States
    
    <Tabs>
      <Tab title="Before Seen">
        ```css
        /* Notification indicators showing unseen state */
        .notification-badge {
            display: inline-block;
            background-color: #ef4444;
            color: white;
            border-radius: 50%;
            width: 8px;
            height: 8px;
        }
        
        .tab-item.has-notifications::after {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 6px;
            height: 6px;
            background-color: #ef4444;
            border-radius: 50%;
        }
        ```
      </Tab>
      
      <Tab title="After Seen">
        ```css
        /* Clean state after marking as seen */
        .notification-badge.hidden {
            display: none;
        }
        
        .tab-item.has-notifications.seen::after {
            display: none;
        }
        
        /* Smooth transition animations */
        .notification-badge {
            transition: opacity 0.3s ease-out;
        }
        
        .notification-badge.hidden {
            opacity: 0;
        }
        ```
      </Tab>
    </Tabs>
  </Accordion>
</AccordionGroup>

## Error Handling

<AccordionGroup>
  <Accordion title="Common Error Scenarios">
    <CardGroup cols={2}>
      <Card title="Network Connectivity" icon="wifi-slash">
        Handle offline scenarios gracefully without blocking UI
      </Card>
      <Card title="Concurrent Operations" icon="arrows-spin">
        Prevent multiple simultaneous mark-seen operations
      </Card>
      <Card title="Authentication Issues" icon="lock">
        Handle token expiration during badge updates
      </Card>
      <Card title="State Inconsistency" icon="triangle-exclamation">
        Manage UI state when server operations fail
      </Card>
    </CardGroup>
  </Accordion>

  <Accordion title="Error Handling Implementation">
    <Tabs>
      <Tab title="iOS">
        <CodeGroup>
          ```swift Robust Error Handling
          class NotificationTrayErrorHandler {
              private let repository = AmityNotificationTrayRepository()
              private var retryAttempts = 0
              private let maxRetryAttempts = 3
              
              func markTraySeenWithErrorHandling(completion: @escaping (Bool) -> Void) {
                  repository.markNotificationTraySeen { [weak self] result in
                      DispatchQueue.main.async {
                          switch result {
                          case .success:
                              self?.retryAttempts = 0
                              completion(true)
                              
                          case .failure(let error):
                              self?.handleMarkSeenError(error, completion: completion)
                          }
                      }
                  }
              }
              
              private func handleMarkSeenError(_ error: Error, completion: @escaping (Bool) -> Void) {
                  retryAttempts += 1
                  
                  if let amityError = error as? AmityError {
                      switch amityError.code {
                      case .networkError:
                          if retryAttempts < maxRetryAttempts {
                              // Exponential backoff retry
                              let delay = pow(2.0, Double(retryAttempts))
                              DispatchQueue.main.asyncAfter(deadline: .now() + delay) { [weak self] in
                                  self?.markTraySeenWithErrorHandling(completion: completion)
                              }
                          } else {
                              // Fail silently but log error - don't block UI
                              print("Failed to mark tray as seen after \(maxRetryAttempts) attempts")
                              completion(false)
                          }
                          
                      case .permissionDenied:
                          // Handle authentication issues
                          handleAuthenticationError()
                          completion(false)
                          
                      default:
                          // For other errors, fail silently
                          print("Error marking tray as seen: \(error)")
                          completion(false)
                      }
                  }
              }
              
              private func handleAuthenticationError() {
                  // Trigger re-authentication flow
                  NotificationCenter.default.post(name: .authenticationRequired, object: nil)
              }
          }
          ```
        </CodeGroup>
      </Tab>
      
      <Tab title="Android">
        <CodeGroup>
          ```kotlin Robust Error Handling
          class NotificationTrayErrorHandler(private val context: Context) {
              private val repository = AmityCoreClient.newNotificationRepository()
              private var retryAttempts = 0
              private val maxRetryAttempts = 3
              
              fun markTraySeenWithErrorHandling(callback: (Boolean) -> Unit) {
                  repository.markNotificationTraySeen()
                      .observeOn(AndroidSchedulers.mainThread())
                      .subscribe({
                          retryAttempts = 0
                          callback(true)
                      }, { error ->
                          handleMarkSeenError(error, callback)
                      })
              }
              
              private fun handleMarkSeenError(error: Throwable, callback: (Boolean) -> Unit) {
                  retryAttempts++
                  
                  when {
                      error is NetworkException -> {
                          if (retryAttempts < maxRetryAttempts) {
                              // Exponential backoff retry
                              val delay = (2.0.pow(retryAttempts.toDouble()) * 1000).toLong()
                              Handler(Looper.getMainLooper()).postDelayed({
                                  markTraySeenWithErrorHandling(callback)
                              }, delay)
                          } else {
                              // Fail silently but log error
                              Log.w("NotificationTray", "Failed to mark tray as seen after $maxRetryAttempts attempts")
                              callback(false)
                          }
                      }
                      
                      error.message?.contains("unauthorized") == true -> {
                          // Handle authentication issues
                          handleAuthenticationError()
                          callback(false)
                      }
                      
                      else -> {
                          // For other errors, fail silently
                          Log.w("NotificationTray", "Error marking tray as seen", error)
                          callback(false)
                      }
                  }
              }
              
              private fun handleAuthenticationError() {
                  // Trigger re-authentication flow
                  val intent = Intent(ACTION_AUTHENTICATION_REQUIRED)
                  LocalBroadcastManager.getInstance(context).sendBroadcast(intent)
              }
              
              companion object {
                  const val ACTION_AUTHENTICATION_REQUIRED = "com.app.authentication_required"
              }
          }
          ```
        </CodeGroup>
      </Tab>
      
      <Tab title="Web">
        <CodeGroup>
          ```typescript Robust Error Handling
          class NotificationTrayErrorHandler {
              private repository: AmityNotificationTrayRepository;
              private retryAttempts: number = 0;
              private maxRetryAttempts: number = 3;
              
              constructor() {
                  this.repository = new AmityNotificationTrayRepository();
              }
              
              async markTraySeenWithErrorHandling(): Promise<boolean> {
                  try {
                      await this.repository.markNotificationTraySeen();
                      this.retryAttempts = 0;
                      return true;
                  } catch (error: any) {
                      return await this.handleMarkSeenError(error);
                  }
              }
              
              private async handleMarkSeenError(error: any): Promise<boolean> {
                  this.retryAttempts++;
                  
                  switch (error.code) {
                      case 'NETWORK_ERROR':
                          if (this.retryAttempts < this.maxRetryAttempts) {
                              // Exponential backoff retry
                              const delay = Math.pow(2, this.retryAttempts) * 1000;
                              await new Promise(resolve => setTimeout(resolve, delay));
                              return await this.markTraySeenWithErrorHandling();
                          } else {
                              // Fail silently but log error
                              console.warn(`Failed to mark tray as seen after ${this.maxRetryAttempts} attempts`);
                              return false;
                          }
                          
                      case 'UNAUTHORIZED':
                          // Handle authentication issues
                          this.handleAuthenticationError();
                          return false;
                          
                      default:
                          // For other errors, fail silently
                          console.warn('Error marking tray as seen:', error);
                          return false;
                  }
              }
              
              private handleAuthenticationError(): void {
                  // Emit authentication required event
                  const event = new CustomEvent('authenticationRequired');
                  window.dispatchEvent(event);
              }
          }
          ```
        </CodeGroup>
      </Tab>
    </Tabs>
  </Accordion>
</AccordionGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="üéØ Implementation Guidelines">
    <CardGroup cols={2}>
      <Card title="Timing" icon="clock">
        **Call Timing**
        - As soon as tray UI becomes visible
        - On screen/tab focus, not just app launch
        - Consider slight delay for better UX
        - Avoid calling multiple times for same session
      </Card>
      <Card title="Error Handling" icon="shield-check">
        **Failure Management**
        - Fail silently to avoid blocking UI
        - Implement exponential backoff for retries
        - Log errors for debugging purposes
        - Don't show error dialogs for this operation
      </Card>
    </CardGroup>
  </Accordion>

  <Accordion title="üîß Performance Optimization">
    - **Debounce Calls**: Prevent multiple rapid calls during screen transitions
    - **Cache State**: Store last known seen state locally for immediate UI updates
    - **Background Processing**: Perform operation off main thread where possible
    - **Batch Operations**: Combine with other notification operations when feasible
  </Accordion>

  <Accordion title="üé® User Experience">
    - **Immediate Feedback**: Update UI badges immediately, sync with server async
    - **Smooth Animations**: Use transitions when hiding badge indicators
    - **Progressive Enhancement**: UI should work even if operation fails
    - **Accessibility**: Announce seen state changes to screen readers
  </Accordion>

  <Accordion title="üîí Security Considerations">
    - **Authentication**: Verify user is authenticated before calling
    - **Rate Limiting**: Implement client-side rate limiting to prevent abuse
    - **Privacy**: Handle seen states according to privacy policies
    - **Logging**: Avoid logging sensitive notification data
  </Accordion>
</AccordionGroup>

## Related Documentation

<CardGroup cols={3}>
  <Card title="Get Tray Seen Status" href="./get-notification-tray-seen" icon="eye">
    Check current global notification tray seen status
  </Card>
  <Card title="Mark Individual Items" href="./mark-notification-tray-item-seen" icon="list-check">
    Track seen status for specific notification items
  </Card>
  <Card title="Query Tray Items" href="./query-notification-tray-item" icon="magnifying-glass">
    Retrieve and filter notification tray items
  </Card>
</CardGroup>