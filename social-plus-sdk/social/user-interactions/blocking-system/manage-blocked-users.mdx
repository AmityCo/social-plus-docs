---
title: "Manage Blocked Users"
description: "View, search, and manage your blocked users list with comprehensive user management tools"
---

# Manage Blocked Users

Efficiently manage your blocked users with comprehensive list management, search capabilities, and bulk operations. Provide users with easy-to-use interfaces for reviewing and managing their blocked user lists.

<CardGroup cols={3}>
  <Card title="List Management" icon="list-check">
    View and paginate through blocked users efficiently
  </Card>
  <Card title="Search & Filter" icon="magnifying-glass">
    Find specific blocked users with advanced search
  </Card>
  <Card title="Bulk Operations" icon="users-gear">
    Manage multiple blocked users simultaneously
  </Card>
</CardGroup>

## Features Overview

<Info>
  **List Behavior**
  - Only shows users you have blocked (not users who blocked you)
  - Inactive or deleted users are automatically filtered out
  - Includes user ID, display name, avatar, and profile information
  - Supports pagination for large lists
</Info>

## Implementation Guide

<Tabs>
  <Tab title="TypeScript/JavaScript">
    ```typescript
    import { AmitySDK, AmityUser } from '@amityco/js-sdk';
    
    interface BlockedUser {
      userId: string;
      displayName: string;
      avatar?: string;
      isActive: boolean;
      blockedAt: Date;
    }
    
    class BlockedUsersManager {
      private blockedUsers: BlockedUser[] = [];
      private currentPage = 1;
      private pageSize = 20;
      
      // Get blocked users list with pagination
      async getBlockedUsers(
        page: number = 1, 
        limit: number = 20
      ): Promise<{ users: BlockedUser[], hasMore: boolean }> {
        try {
          const result = await AmitySDK.getBlockedUsers({
            page,
            limit,
            sortBy: 'displayName', // Sort alphabetically
            includeDeleted: false   // Exclude deleted users
          });
          
          console.log(`Retrieved ${result.data.length} blocked users`);
          
          // Transform data for UI
          const users: BlockedUser[] = result.data.map(user => ({
            userId: user.userId,
            displayName: user.displayName || 'Unknown User',
            avatar: user.avatar?.fileUrl,
            isActive: user.isActive,
            blockedAt: user.blockedAt || new Date()
          }));
          
          // Update local cache
          if (page === 1) {
            this.blockedUsers = users;
          } else {
            this.blockedUsers.push(...users);
          }
          
          return {
            users,
            hasMore: result.hasNextPage
          };
          
        } catch (error) {
          console.error('Failed to get blocked users:', error);
          this.handleGetBlockedUsersError(error);
          throw error;
        }
      }
      
      // Search within blocked users
      async searchBlockedUsers(query: string): Promise<BlockedUser[]> {
        try {
          if (!query.trim()) {
            return this.blockedUsers;
          }
          
          const filteredUsers = this.blockedUsers.filter(user =>
            user.displayName.toLowerCase().includes(query.toLowerCase()) ||
            user.userId.toLowerCase().includes(query.toLowerCase())
          );
          
          return filteredUsers;
          
        } catch (error) {
          console.error('Search failed:', error);
          return [];
        }
      }
      
      // Unblock user from list
      async unblockFromList(userId: string): Promise<void> {
        try {
          await AmitySDK.unblockUser(userId);
          
          // Remove from local cache immediately
          this.blockedUsers = this.blockedUsers.filter(user => user.userId !== userId);
          
          // Update UI
          this.onUserUnblocked(userId);
          
          console.log(`Successfully unblocked user: ${userId}`);
          
        } catch (error) {
          console.error('Failed to unblock user:', error);
          this.handleUnblockError(error);
          throw error;
        }
      }
      
      // Bulk unblock operations
      async bulkUnblock(userIds: string[]): Promise<{ success: string[], failed: string[] }> {
        const results = { success: [], failed: [] };
        
        for (const userId of userIds) {
          try {
            await this.unblockFromList(userId);
            results.success.push(userId);
          } catch (error) {
            console.error(`Failed to unblock ${userId}:`, error);
            results.failed.push(userId);
          }
        }
        
        return results;
      }
      
      // Event handlers
      private onUserUnblocked(userId: string): void {
        // Emit event for UI updates
        this.emit('userUnblocked', { userId });
      }
      
      private handleGetBlockedUsersError(error: any): void {
        if (error.code === 'PERMISSION_DENIED') {
          this.emit('error', { message: 'Unable to access blocked users list' });
        } else {
          this.emit('error', { message: 'Failed to load blocked users' });
        }
      }
      
      private handleUnblockError(error: any): void {
        this.emit('error', { message: 'Failed to unblock user' });
      }
    }
    
    // Usage examples
    const manager = new BlockedUsersManager();
    
    // Load blocked users
    const { users, hasMore } = await manager.getBlockedUsers();
    
    // Search blocked users
    const searchResults = await manager.searchBlockedUsers('john');
    
    // Unblock single user
    await manager.unblockFromList('user123');
    
    // Bulk unblock
    const bulkResults = await manager.bulkUnblock(['user1', 'user2', 'user3']);
    ```
  </Tab>
  
  <Tab title="iOS (Swift)">
    ```swift
    import AmitySDK
    import Combine
    
    class BlockedUsersManager: ObservableObject {
        @Published var blockedUsers: [AmityUser] = []
        @Published var isLoading = false
        @Published var hasMore = true
        @Published var searchQuery = ""
        
        private var repository: AmityUserRepository?
        private var collection: AmityCollection<AmityUser>?
        private var token: AmityNotificationToken?
        private var cancellables = Set<AnyCancellable>()
        
        init() {
            repository = AmityManager.shared.client.userRepository
            setupBlockedUsersObserver()
            setupSearch()
        }
        
        // Setup real-time observer for blocked users
        private func setupBlockedUsersObserver() {
            guard let repository = repository else { return }
            
            collection = repository.getBlockedUsers()
            
            token = collection?.observe { [weak self] collection, _, error in
                DispatchQueue.main.async {
                    if let error = error {
                        print("Error observing blocked users: \(error)")
                        self?.handleError(error)
                        return
                    }
                    
                    // Update UI with filtered active users
                    self?.blockedUsers = collection.allObjects().filter { $0.isActive }
                    self?.isLoading = false
                    
                    print("Updated blocked users list: \(self?.blockedUsers.count ?? 0) users")
                }
            }
        }
        
        // Setup search functionality
        private func setupSearch() {
            $searchQuery
                .debounce(for: .milliseconds(300), scheduler: RunLoop.main)
                .sink { [weak self] query in
                    self?.performSearch(query: query)
                }
                .store(in: &cancellables)
        }
        
        // Perform search within blocked users
        private func performSearch(query: String) {
            guard let collection = collection else { return }
            
            if query.isEmpty {
                // Show all blocked users
                blockedUsers = collection.allObjects().filter { $0.isActive }
            } else {
                // Filter based on search query
                blockedUsers = collection.allObjects().filter { user in
                    let displayName = user.displayName?.lowercased() ?? ""
                    let userId = user.userId.lowercased()
                    let searchQuery = query.lowercased()
                    
                    return user.isActive && (displayName.contains(searchQuery) || userId.contains(searchQuery))
                }
            }
        }
        
        // Load more blocked users (pagination)
        func loadMore() {
            guard hasMore && !isLoading else { return }
            
            isLoading = true
            collection?.nextPage()
        }
        
        // Unblock user with confirmation
        func unblockUser(_ user: AmityUser, completion: @escaping (Bool) -> Void) {
            repository?.unblockUser(userId: user.userId) { [weak self] success, error in
                DispatchQueue.main.async {
                    if success {
                        print("Successfully unblocked user: \(user.userId)")
                        // User will be automatically removed from observer
                        completion(true)
                    } else if let error = error {
                        print("Failed to unblock user: \(error)")
                        self?.handleError(error)
                        completion(false)
                    }
                }
            }
        }
        
        // Bulk unblock operations
        func bulkUnblock(users: [AmityUser], completion: @escaping (Int, Int) -> Void) {
            var successCount = 0
            var failureCount = 0
            let group = DispatchGroup()
            
            for user in users {
                group.enter()
                unblockUser(user) { success in
                    if success {
                        successCount += 1
                    } else {
                        failureCount += 1
                    }
                    group.leave()
                }
            }
            
            group.notify(queue: .main) {
                completion(successCount, failureCount)
            }
        }
        
        // Export blocked users list
        func exportBlockedUsers() -> [String: Any] {
            let exportData: [String: Any] = [
                "exportDate": Date(),
                "totalUsers": blockedUsers.count,
                "users": blockedUsers.map { user in
                    [
                        "userId": user.userId,
                        "displayName": user.displayName ?? "",
                        "avatar": user.avatar?.fileUrl ?? ""
                    ]
                }
            ]
            
            return exportData
        }
        
        private func handleError(_ error: Error) {
            // Handle different error types
            if let amityError = error as? AmityError {
                switch amityError {
                case .permissionDenied:
                    // Handle permission error
                    break
                default:
                    // Handle other errors
                    break
                }
            }
        }
        
        deinit {
            token?.invalidate()
        }
    }
    
    // SwiftUI View for Blocked Users Management
    struct BlockedUsersView: View {
        @StateObject private var manager = BlockedUsersManager()
        @State private var selectedUsers: Set<String> = []
        @State private var showingBulkActions = false
        
        var filteredUsers: [AmityUser] {
            manager.blockedUsers
        }
        
        var body: some View {
            NavigationView {
                VStack {
                    // Search bar
                    SearchBar(text: $manager.searchQuery)
                    
                    // Bulk actions bar
                    if !selectedUsers.isEmpty {
                        BulkActionBar(
                            selectedCount: selectedUsers.count,
                            onUnblockSelected: unblockSelected
                        )
                    }
                    
                    // Users list
                    List {
                        ForEach(filteredUsers, id: \.userId) { user in
                            BlockedUserRow(
                                user: user,
                                isSelected: selectedUsers.contains(user.userId),
                                onToggleSelection: { toggleSelection(user.userId) },
                                onUnblock: { manager.unblockUser(user) { _ in } }
                            )
                        }
                        
                        // Load more indicator
                        if manager.hasMore {
                            ProgressView()
                                .onAppear { manager.loadMore() }
                        }
                    }
                }
                .navigationTitle("Blocked Users")
                .toolbar {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button("Select") {
                            showingBulkActions.toggle()
                        }
                    }
                }
            }
        }
        
        private func toggleSelection(_ userId: String) {
            if selectedUsers.contains(userId) {
                selectedUsers.remove(userId)
            } else {
                selectedUsers.insert(userId)
            }
        }
        
        private func unblockSelected() {
            let usersToUnblock = manager.blockedUsers.filter { selectedUsers.contains($0.userId) }
            
            manager.bulkUnblock(users: usersToUnblock) { success, failure in
                selectedUsers.removeAll()
                // Show results to user
            }
        }
    }
    ```
  </Tab>
  
  <Tab title="Android (Kotlin)">
    ```kotlin
    import com.amityco.socialplus.sdk.AmitySocialClient
    import com.amityco.socialplus.sdk.model.AmityUser
    import androidx.lifecycle.ViewModel
    import androidx.lifecycle.viewModelScope
    import androidx.paging.PagingData
    import androidx.paging.PagingDataAdapter
    import kotlinx.coroutines.flow.*
    import kotlinx.coroutines.launch
    
    class BlockedUsersViewModel : ViewModel() {
        private val userRepository = AmitySocialClient.newUserRepository()
        
        private val _searchQuery = MutableStateFlow("")
        val searchQuery: StateFlow<String> = _searchQuery.asStateFlow()
        
        private val _selectedUsers = MutableStateFlow<Set<String>>(emptySet())
        val selectedUsers: StateFlow<Set<String>> = _selectedUsers.asStateFlow()
        
        private val _isLoading = MutableStateFlow(false)
        val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()
        
        // Get paginated blocked users with search
        val blockedUsers: Flow<PagingData<AmityUser>> = searchQuery
            .debounce(300)
            .flatMapLatest { query ->
                if (query.isEmpty()) {
                    getBlockedUsers()
                } else {
                    searchBlockedUsers(query)
                }
            }
        
        private fun getBlockedUsers(): Flow<PagingData<AmityUser>> {
            return userRepository.getBlockedUsers()
                .build()
                .query()
        }
        
        private fun searchBlockedUsers(query: String): Flow<PagingData<AmityUser>> {
            return userRepository.getBlockedUsers()
                .displayName(query) // Search by display name
                .build()
                .query()
        }
        
        // Update search query
        fun updateSearchQuery(query: String) {
            _searchQuery.value = query
        }
        
        // Toggle user selection for bulk operations
        fun toggleUserSelection(userId: String) {
            val current = _selectedUsers.value
            _selectedUsers.value = if (current.contains(userId)) {
                current - userId
            } else {
                current + userId
            }
        }
        
        // Clear all selections
        fun clearSelections() {
            _selectedUsers.value = emptySet()
        }
        
        // Select all visible users
        fun selectAllUsers(userIds: List<String>) {
            _selectedUsers.value = userIds.toSet()
        }
        
        // Unblock single user
        fun unblockUser(userId: String, callback: (Boolean) -> Unit) {
            viewModelScope.launch {
                _isLoading.value = true
                try {
                    userRepository.unblockUser(userId).blockingGet()
                    callback(true)
                } catch (error: Throwable) {
                    Log.e("BlockedUsers", "Failed to unblock user", error)
                    callback(false)
                } finally {
                    _isLoading.value = false
                }
            }
        }
        
        // Bulk unblock selected users
        fun bulkUnblockSelected(callback: (Int, Int) -> Unit) {
            val selectedUserIds = _selectedUsers.value
            if (selectedUserIds.isEmpty()) return
            
            viewModelScope.launch {
                _isLoading.value = true
                
                var successCount = 0
                var failureCount = 0
                
                selectedUserIds.forEach { userId ->
                    try {
                        userRepository.unblockUser(userId).blockingGet()
                        successCount++
                    } catch (error: Throwable) {
                        Log.e("BlockedUsers", "Failed to unblock user: $userId", error)
                        failureCount++
                    }
                }
                
                _selectedUsers.value = emptySet()
                _isLoading.value = false
                
                callback(successCount, failureCount)
            }
        }
        
        // Export blocked users data
        fun exportBlockedUsers(users: List<AmityUser>): Map<String, Any> {
            return mapOf(
                "exportDate" to System.currentTimeMillis(),
                "totalUsers" to users.size,
                "users" to users.map { user ->
                    mapOf(
                        "userId" to user.userId,
                        "displayName" to (user.displayName ?: ""),
                        "avatar" to (user.avatar?.fileUrl ?: "")
                    )
                }
            )
        }
    }
    
    // RecyclerView Adapter for blocked users
    class BlockedUsersAdapter(
        private val onToggleSelection: (String) -> Unit,
        private val onUnblockClick: (AmityUser) -> Unit,
        private val isUserSelected: (String) -> Boolean
    ) : PagingDataAdapter<AmityUser, BlockedUsersAdapter.ViewHolder>(UserDiffCallback()) {
        
        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
            val binding = ItemBlockedUserBinding.inflate(
                LayoutInflater.from(parent.context), parent, false
            )
            return ViewHolder(binding)
        }
        
        override fun onBindViewHolder(holder: ViewHolder, position: Int) {
            val user = getItem(position)
            user?.let { holder.bind(it) }
        }
        
        inner class ViewHolder(private val binding: ItemBlockedUserBinding) : 
            RecyclerView.ViewHolder(binding.root) {
            
            fun bind(user: AmityUser) {
                binding.apply {
                    // User information
                    textDisplayName.text = user.displayName ?: "Unknown User"
                    textUserId.text = user.userId
                    
                    // Selection state
                    checkboxSelect.isChecked = isUserSelected(user.userId)
                    checkboxSelect.setOnCheckedChangeListener { _, isChecked ->
                        onToggleSelection(user.userId)
                    }
                    
                    // Avatar
                    user.avatar?.let { avatar ->
                        Glide.with(imageAvatar.context)
                            .load(avatar.fileUrl)
                            .placeholder(R.drawable.ic_user_placeholder)
                            .into(imageAvatar)
                    }
                    
                    // Unblock button
                    buttonUnblock.setOnClickListener {
                        showUnblockConfirmation(user)
                    }
                    
                    // Item click for selection
                    root.setOnClickListener {
                        onToggleSelection(user.userId)
                    }
                }
            }
            
            private fun showUnblockConfirmation(user: AmityUser) {
                AlertDialog.Builder(binding.root.context)
                    .setTitle("Unblock User")
                    .setMessage("Are you sure you want to unblock ${user.displayName ?: user.userId}?")
                    .setPositiveButton("Unblock") { _, _ ->
                        onUnblockClick(user)
                    }
                    .setNegativeButton("Cancel", null)
                    .show()
            }
        }
    }
    
    // Fragment implementation
    class BlockedUsersFragment : Fragment() {
        private val viewModel: BlockedUsersViewModel by viewModels()
        private lateinit var adapter: BlockedUsersAdapter
        
        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
            super.onViewCreated(view, savedInstanceState)
            
            setupRecyclerView()
            setupSearch()
            setupBulkActions()
            observeData()
        }
        
        private fun setupRecyclerView() {
            adapter = BlockedUsersAdapter(
                onToggleSelection = { userId -> viewModel.toggleUserSelection(userId) },
                onUnblockClick = { user -> unblockUser(user) },
                isUserSelected = { userId -> 
                    viewModel.selectedUsers.value.contains(userId) 
                }
            )
            
            binding.recyclerViewBlockedUsers.adapter = adapter
        }
        
        private fun setupSearch() {
            binding.searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener {
                override fun onQueryTextSubmit(query: String?): Boolean = false
                
                override fun onQueryTextChange(newText: String?): Boolean {
                    viewModel.updateSearchQuery(newText ?: "")
                    return true
                }
            })
        }
        
        private fun setupBulkActions() {
            binding.buttonBulkUnblock.setOnClickListener {
                viewModel.bulkUnblockSelected { success, failure ->
                    val message = "Unblocked: $success, Failed: $failure"
                    Toast.makeText(context, message, Toast.LENGTH_LONG).show()
                }
            }
        }
        
        private fun observeData() {
            viewLifecycleOwner.lifecycleScope.launch {
                viewModel.blockedUsers.collectLatest { pagingData ->
                    adapter.submitData(pagingData)
                }
            }
            
            viewLifecycleOwner.lifecycleScope.launch {
                viewModel.selectedUsers.collect { selectedUsers ->
                    binding.textSelectedCount.text = "${selectedUsers.size} selected"
                    binding.layoutBulkActions.isVisible = selectedUsers.isNotEmpty()
                }
            }
        }
        
        private fun unblockUser(user: AmityUser) {
            viewModel.unblockUser(user.userId) { success ->
                val message = if (success) {
                    "User unblocked successfully"
                } else {
                    "Failed to unblock user"
                }
                Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
            }
        }
    }
    ```
  </Tab>
  
  <Tab title="Flutter (Dart)">
    ```dart
    import 'package:amity_sdk/amity_sdk.dart';
    import 'package:flutter/material.dart';
    
    class BlockedUsersManager {
      final AmityUserRepository _userRepository = AmitySocialClient.newUserRepository();
      
      /// Get blocked users with pagination
      Stream<List<AmityUser>> getBlockedUsers() {
        return _userRepository.getBlockedUsers()
            .getPagingData()
            .map((pagingData) => pagingData.data
                .where((user) => user.isActive)
                .toList());
      }
      
      /// Search blocked users by display name
      Stream<List<AmityUser>> searchBlockedUsers(String query) {
        if (query.isEmpty) {
          return getBlockedUsers();
        }
        
        return _userRepository.getBlockedUsers()
            .displayName(query)
            .getPagingData()
            .map((pagingData) => pagingData.data
                .where((user) => user.isActive)
                .toList());
      }
      
      /// Unblock a single user
      Future<bool> unblockUser(String userId) async {
        try {
          await _userRepository.unblockUser(userId);
          return true;
        } catch (error) {
          print('Failed to unblock user: $error');
          return false;
        }
      }
      
      /// Bulk unblock multiple users
      Future<Map<String, int>> bulkUnblock(List<String> userIds) async {
        int successCount = 0;
        int failureCount = 0;
        
        for (String userId in userIds) {
          final success = await unblockUser(userId);
          if (success) {
            successCount++;
          } else {
            failureCount++;
          }
        }
        
        return {'success': successCount, 'failure': failureCount};
      }
      
      /// Export blocked users data
      Map<String, dynamic> exportBlockedUsers(List<AmityUser> users) {
        return {
          'exportDate': DateTime.now().toIso8601String(),
          'totalUsers': users.length,
          'users': users.map((user) => {
            'userId': user.userId,
            'displayName': user.displayName ?? '',
            'avatar': user.avatar?.fileUrl ?? '',
          }).toList(),
        };
      }
    }
    
    // Blocked Users Screen Widget
    class BlockedUsersScreen extends StatefulWidget {
      @override
      _BlockedUsersScreenState createState() => _BlockedUsersScreenState();
    }
    
    class _BlockedUsersScreenState extends State<BlockedUsersScreen> {
      final BlockedUsersManager _manager = BlockedUsersManager();
      final TextEditingController _searchController = TextEditingController();
      final Set<String> _selectedUsers = <String>{};
      
      late Stream<List<AmityUser>> _blockedUsersStream;
      bool _isSelectionMode = false;
      
      @override
      void initState() {
        super.initState();
        _blockedUsersStream = _manager.getBlockedUsers();
        _setupSearch();
      }
      
      void _setupSearch() {
        _searchController.addListener(() {
          setState(() {
            _blockedUsersStream = _manager.searchBlockedUsers(_searchController.text);
          });
        });
      }
      
      void _toggleUserSelection(String userId) {
        setState(() {
          if (_selectedUsers.contains(userId)) {
            _selectedUsers.remove(userId);
          } else {
            _selectedUsers.add(userId);
          }
          
          _isSelectionMode = _selectedUsers.isNotEmpty;
        });
      }
      
      Future<void> _bulkUnblock() async {
        if (_selectedUsers.isEmpty) return;
        
        final confirmed = await _showBulkUnblockConfirmation();
        if (!confirmed) return;
        
        final results = await _manager.bulkUnblock(_selectedUsers.toList());
        
        setState(() {
          _selectedUsers.clear();
          _isSelectionMode = false;
        });
        
        _showBulkResultSnackBar(results['success']!, results['failure']!);
      }
      
      Future<bool> _showBulkUnblockConfirmation() async {
        return await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: Text('Bulk Unblock'),
            content: Text('Are you sure you want to unblock ${_selectedUsers.length} users?'),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(false),
                child: Text('Cancel'),
              ),
              TextButton(
                onPressed: () => Navigator.of(context).pop(true),
                child: Text('Unblock All'),
                style: TextButton.styleFrom(foregroundColor: Colors.red),
              ),
            ],
          ),
        ) ?? false;
      }
      
      void _showBulkResultSnackBar(int success, int failure) {
        String message;
        Color backgroundColor;
        
        if (failure == 0) {
          message = 'Successfully unblocked $success users';
          backgroundColor = Colors.green;
        } else if (success == 0) {
          message = 'Failed to unblock $failure users';
          backgroundColor = Colors.red;
        } else {
          message = 'Unblocked: $success, Failed: $failure';
          backgroundColor = Colors.orange;
        }
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(message),
            backgroundColor: backgroundColor,
          ),
        );
      }
      
      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(
            title: _isSelectionMode 
                ? Text('${_selectedUsers.length} selected')
                : Text('Blocked Users'),
            actions: [
              if (_isSelectionMode) ...[
                IconButton(
                  icon: Icon(Icons.select_all),
                  onPressed: _selectAllVisibleUsers,
                ),
                IconButton(
                  icon: Icon(Icons.clear),
                  onPressed: () {
                    setState(() {
                      _selectedUsers.clear();
                      _isSelectionMode = false;
                    });
                  },
                ),
              ] else
                IconButton(
                  icon: Icon(Icons.checklist),
                  onPressed: () {
                    setState(() {
                      _isSelectionMode = true;
                    });
                  },
                ),
            ],
          ),
          body: Column(
            children: [
              // Search bar
              Padding(
                padding: EdgeInsets.all(16),
                child: TextField(
                  controller: _searchController,
                  decoration: InputDecoration(
                    hintText: 'Search blocked users...',
                    prefixIcon: Icon(Icons.search),
                    border: OutlineInputBorder(),
                  ),
                ),
              ),
              
              // Bulk actions bar
              if (_isSelectionMode)
                Container(
                  padding: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  color: Theme.of(context).primaryColor.withOpacity(0.1),
                  child: Row(
                    children: [
                      Expanded(
                        child: Text(
                          '${_selectedUsers.length} users selected',
                          style: TextStyle(fontWeight: FontWeight.bold),
                        ),
                      ),
                      ElevatedButton.icon(
                        onPressed: _bulkUnblock,
                        icon: Icon(Icons.block),
                        label: Text('Unblock All'),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.red,
                          foregroundColor: Colors.white,
                        ),
                      ),
                    ],
                  ),
                ),
              
              // Users list
              Expanded(
                child: StreamBuilder<List<AmityUser>>(
                  stream: _blockedUsersStream,
                  builder: (context, snapshot) {
                    if (snapshot.connectionState == ConnectionState.waiting) {
                      return Center(child: CircularProgressIndicator());
                    }
                    
                    if (snapshot.hasError) {
                      return Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(Icons.error, size: 64, color: Colors.red),
                            SizedBox(height: 16),
                            Text('Failed to load blocked users'),
                            TextButton(
                              onPressed: () => setState(() {}),
                              child: Text('Retry'),
                            ),
                          ],
                        ),
                      );
                    }
                    
                    final blockedUsers = snapshot.data ?? [];
                    
                    if (blockedUsers.isEmpty) {
                      return Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(Icons.block, size: 64, color: Colors.grey),
                            SizedBox(height: 16),
                            Text('No blocked users found'),
                          ],
                        ),
                      );
                    }
                    
                    return ListView.builder(
                      itemCount: blockedUsers.length,
                      itemBuilder: (context, index) {
                        final user = blockedUsers[index];
                        final isSelected = _selectedUsers.contains(user.userId);
                        
                        return BlockedUserTile(
                          user: user,
                          isSelected: isSelected,
                          isSelectionMode: _isSelectionMode,
                          onToggleSelection: () => _toggleUserSelection(user.userId),
                          onUnblock: () => _unblockSingleUser(user),
                        );
                      },
                    );
                  },
                ),
              ),
            ],
          ),
        );
      }
      
      void _selectAllVisibleUsers() {
        // This would need to be implemented with the current visible users
        // For simplicity, we'll skip this implementation
      }
      
      Future<void> _unblockSingleUser(AmityUser user) async {
        final confirmed = await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: Text('Unblock User'),
            content: Text('Are you sure you want to unblock ${user.displayName ?? user.userId}?'),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(false),
                child: Text('Cancel'),
              ),
              TextButton(
                onPressed: () => Navigator.of(context).pop(true),
                child: Text('Unblock'),
                style: TextButton.styleFrom(foregroundColor: Colors.red),
              ),
            ],
          ),
        );
        
        if (confirmed == true) {
          final success = await _manager.unblockUser(user.userId);
          
          final message = success 
              ? 'User unblocked successfully'
              : 'Failed to unblock user';
          
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(message),
              backgroundColor: success ? Colors.green : Colors.red,
            ),
          );
        }
      }
    }
    
    // Individual blocked user tile widget
    class BlockedUserTile extends StatelessWidget {
      final AmityUser user;
      final bool isSelected;
      final bool isSelectionMode;
      final VoidCallback onToggleSelection;
      final VoidCallback onUnblock;
      
      const BlockedUserTile({
        Key? key,
        required this.user,
        required this.isSelected,
        required this.isSelectionMode,
        required this.onToggleSelection,
        required this.onUnblock,
      }) : super(key: key);
      
      @override
      Widget build(BuildContext context) {
        return ListTile(
          leading: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (isSelectionMode)
                Checkbox(
                  value: isSelected,
                  onChanged: (_) => onToggleSelection(),
                ),
              CircleAvatar(
                backgroundImage: user.avatar?.fileUrl != null 
                    ? NetworkImage(user.avatar!.fileUrl!)
                    : null,
                child: user.avatar?.fileUrl == null 
                    ? Icon(Icons.person)
                    : null,
              ),
            ],
          ),
          title: Text(user.displayName ?? 'Unknown User'),
          subtitle: Text(user.userId),
          trailing: isSelectionMode 
              ? null
              : TextButton(
                  onPressed: onUnblock,
                  child: Text('Unblock'),
                  style: TextButton.styleFrom(
                    foregroundColor: Colors.red,
                  ),
                ),
          onTap: isSelectionMode ? onToggleSelection : null,
          selected: isSelected,
        );
      }
    }
    ```
  </Tab>
</Tabs>

## UI/UX Best Practices

<CardGroup cols={2}>
  <Card title="List Management" icon="list">
    - **Pagination**: Load users progressively for better performance
    - **Search**: Provide real-time search with debouncing
    - **Sorting**: Allow sorting by name, date blocked, or activity
    - **Filtering**: Filter by user status or block date ranges
  </Card>
  <Card title="Bulk Operations" icon="users-gear">
    - **Selection Mode**: Clear visual indication of selection state
    - **Bulk Actions**: Prominent bulk action buttons
    - **Progress Feedback**: Show progress for bulk operations
    - **Result Summary**: Clear feedback on operation results
  </Card>
</CardGroup>

## Advanced Features

<AccordionGroup>
  <Accordion title="Export & Import">
    **Data portability and backup capabilities**
    
    - Export blocked users list to JSON/CSV
    - Import blocked users from external sources
    - Backup and restore blocked user data
    - Cross-platform sync capabilities
  </Accordion>
  
  <Accordion title="Analytics & Insights">
    **Understanding blocking patterns and user behavior**
    
    - Blocking frequency analytics
    - Most commonly blocked user types
    - Unblocking patterns and trends
    - User satisfaction metrics
  </Accordion>
  
  <Accordion title="Smart Management">
    **AI-powered blocking suggestions and automation**
    
    - Suggest blocks based on user behavior
    - Identify potential harassment patterns
    - Recommend unblocking inactive accounts
    - Automated cleanup of deleted users
  </Accordion>
</AccordionGroup>

## Performance Considerations

<Tabs>
  <Tab title="List Optimization">
    ```typescript
    // Optimize large blocked users lists
    class BlockedUsersOptimization {
      private cache = new Map<string, BlockedUser>();
      private virtualScrollThreshold = 50;
      
      async optimizeList(users: BlockedUser[]): Promise<BlockedUser[]> {
        // Use virtual scrolling for large lists
        if (users.length > this.virtualScrollThreshold) {
          return this.implementVirtualScrolling(users);
        }
        
        // Cache frequently accessed users
        users.forEach(user => {
          this.cache.set(user.userId, user);
        });
        
        return users;
      }
      
      private implementVirtualScrolling(users: BlockedUser[]): BlockedUser[] {
        // Implement virtual scrolling logic
        // Return only visible items + buffer
        return users.slice(0, this.virtualScrollThreshold);
      }
    }
    ```
  </Tab>
  
  <Tab title="Search Performance">
    ```swift
    // Optimize search performance
    class SearchOptimization {
        private var searchIndex: [String: [AmityUser]] = [:]
        
        func buildSearchIndex(users: [AmityUser]) {
            // Build search index for faster queries
            for user in users {
                let displayName = user.displayName?.lowercased() ?? ""
                let userId = user.userId.lowercased()
                
                // Index by first characters for faster lookup
                for i in 1...min(displayName.count, 3) {
                    let prefix = String(displayName.prefix(i))
                    searchIndex[prefix, default: []].append(user)
                }
                
                for i in 1...min(userId.count, 3) {
                    let prefix = String(userId.prefix(i))
                    searchIndex[prefix, default: []].append(user)
                }
            }
        }
        
        func searchUsers(query: String) -> [AmityUser] {
            let lowercaseQuery = query.lowercased()
            
            // Use index for faster search
            if let indexedUsers = searchIndex[String(lowercaseQuery.prefix(min(lowercaseQuery.count, 3)))] {
                return indexedUsers.filter { user in
                    let displayName = user.displayName?.lowercased() ?? ""
                    let userId = user.userId.lowercased()
                    return displayName.contains(lowercaseQuery) || userId.contains(lowercaseQuery)
                }
            }
            
            return []
        }
    }
    ```
  </Tab>
</Tabs>

## Error Handling

<AccordionGroup>
  <Accordion title="Network Errors">
    **Handle connectivity and API errors gracefully**
    
    ```kotlin
    class NetworkErrorHandler {
        fun handleNetworkError(error: Throwable) {
            when (error) {
                is NetworkException -> {
                    // Show offline mode or retry options
                    showOfflineMode()
                }
                is TimeoutException -> {
                    // Offer manual retry
                    showRetryOption()
                }
                else -> {
                    // Generic network error handling
                    showGenericNetworkError()
                }
            }
        }
    }
    ```
  </Accordion>
  
  <Accordion title="Data Inconsistency">
    **Handle data sync and consistency issues**
    
    ```dart
    class DataConsistencyHandler {
      Future<void> handleDataInconsistency() async {
        try {
          // Refresh data from server
          await refreshBlockedUsersList();
          
          // Clear local cache
          await clearLocalCache();
          
          // Rebuild UI with fresh data
          rebuildUI();
          
        } catch (error) {
          // Fallback to cached data with warning
          showDataInconsistencyWarning();
        }
      }
    }
    ```
  </Accordion>
</AccordionGroup>

---

## Quick Reference

### Essential Operations
- **Get Blocked Users**: Load and display blocked users list with pagination
- **Search Users**: Find specific blocked users with real-time search
- **Unblock Single**: Remove individual users from blocked list
- **Bulk Unblock**: Remove multiple users simultaneously
- **Export Data**: Backup blocked users data for portability

### Integration Points
- **[Block/Unblock User](block-unblock-user)** - Core blocking functionality
- **[User Profiles](../../core-concepts/user/)** - User information and management
- **[Search System](../intelligent-search/)** - User discovery integration
