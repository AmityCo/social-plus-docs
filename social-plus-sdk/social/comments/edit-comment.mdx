# Edit Comment

Enable users to modify their comments with comprehensive editing capabilities including text updates, image management, and edit tracking for enhanced transparency and accountability.

<CardGroup cols={2}>
  <Card title="Text Editing" icon="pen">
    Update comment text content with full formatting support
  </Card>
  <Card title="Image Management" icon="image">
    Add, remove, or replace images in existing comments
  </Card>
  <Card title="Edit Tracking" icon="clock">
    Automatic timestamp tracking with `editedAt` property
  </Card>
  <Card title="Permission Control" icon="shield">
    Users can only edit their own comments for accountability
  </Card>
</CardGroup>

## Architecture Overview

The comment editing system provides controlled content modification with comprehensive tracking:

<AccordionGroup>
  <Accordion title="Edit Permissions">
    - **Owner-Only Editing**: Users can only edit their own comments
    - **Admin Override**: Administrators can edit any comment for moderation
    - **Time Limits**: Optional edit windows can be configured
    - **Status Validation**: Comments must be in editable state
  </Accordion>
  
  <Accordion title="Content Management">
    - **Text Updates**: Full rich text editing capabilities
    - **Image Management**: Add, remove, or replace images
    - **Metadata Preservation**: Original creation data maintained
    - **Version Tracking**: Edit history with timestamps
  </Accordion>
  
  <Accordion title="Real-time Synchronization">
    - **Live Updates**: Changes reflected across all connected clients
    - **Conflict Resolution**: Handles simultaneous edit attempts
    - **Optimistic Updates**: Immediate UI feedback with rollback capability
    - **Edit Indicators**: Visual cues for edited content
  </Accordion>
</AccordionGroup>

## Edit Properties Reference

| Property | Type | Description | Auto-Updated |
|----------|------|-------------|--------------|
| `text` | `string` | Updated comment text content | ❌ |
| `images` | `AmityImage[]` | Array of attached images | ❌ |
| `editedAt` | `Date` | Timestamp of last edit | ✅ |
| `isEdited` | `boolean` | Indicates if comment was modified | ✅ |
| `editCount` | `number` | Number of times comment was edited | ✅ |
| `lastEditedBy` | `string` | User ID who made the last edit | ✅ |

<Info>
The `editedAt` timestamp is automatically updated whenever a comment is modified, providing transparency about content changes.
</Info>

## Text Comment Editing

<Tabs>
<Tab title="iOS">
```swift
import AmitySDK

class CommentEditingManager {
    private let repository: AmityCommentRepository
    
    init(client: AmityClient) {
        self.repository = AmityCommentRepository(client: client)
    }
    
    // MARK: - Basic Text Editing
    func updateCommentText(commentId: String, newText: String) async throws -> AmityComment {
        return try await withCheckedThrowingContinuation { continuation in
            repository.updateComment(withId: commentId, text: newText) { comment, error in
                if let error = error {
                    continuation.resume(throwing: error)
                } else if let comment = comment {
                    continuation.resume(returning: comment)
                } else {
                    continuation.resume(throwing: CommentEditError.updateFailed)
                }
            }
        }
    }
    
    // MARK: - Validation and Error Handling
    func canEditComment(_ comment: AmityComment, by userId: String) -> Bool {
        // Check if user owns the comment
        guard comment.userId == userId else { return false }
        
        // Check if comment is not deleted
        guard !comment.isDeleted else { return false }
        
        // Optional: Check edit time window (e.g., 24 hours)
        if let createdAt = comment.createdAt,
           Date().timeIntervalSince(createdAt) > (24 * 60 * 60) {
            return false
        }
        
        return true
    }
    
    // MARK: - Edit with Validation
    func safeUpdateComment(
        commentId: String,
        newText: String,
        currentUserId: String
    ) async throws -> AmityComment {
        
        // Validate input
        guard !newText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            throw CommentEditError.emptyText
        }
        
        guard newText.count <= 2048 else {
            throw CommentEditError.textTooLong
        }
        
        // Fetch current comment for validation
        let currentComment = try await getComment(commentId: commentId)
        
        guard canEditComment(currentComment, by: currentUserId) else {
            throw CommentEditError.permissionDenied
        }
        
        // Perform update
        return try await updateCommentText(commentId: commentId, newText: newText)
    }
    
    private func getComment(commentId: String) async throws -> AmityComment {
        // Implementation to fetch comment by ID
        // This would use your comment fetching logic
        fatalError("Implement comment fetching")
    }
}

// Error Types
enum CommentEditError: Error, LocalizedError {
    case updateFailed
    case emptyText
    case textTooLong
    case permissionDenied
    case commentNotFound
    
    var errorDescription: String? {
        switch self {
        case .updateFailed:
            return "Failed to update comment"
        case .emptyText:
            return "Comment cannot be empty"
        case .textTooLong:
            return "Comment exceeds maximum length"
        case .permissionDenied:
            return "You don't have permission to edit this comment"
        case .commentNotFound:
            return "Comment not found"
        }
    }
}

// Usage Example
let editingManager = CommentEditingManager(client: amityClient)

Task {
    do {
        let updatedComment = try await editingManager.safeUpdateComment(
            commentId: "comment123",
            newText: "This is my updated comment with better content!",
            currentUserId: currentUser.id
        )
        
        print("Comment updated successfully!")
        print("Edit timestamp: \(updatedComment.editedAt ?? Date())")
        
    } catch {
        print("Failed to edit comment: \(error.localizedDescription)")
    }
}
```
</Tab>

<Tab title="Android">
```kotlin
import com.amity.socialcloud.sdk.api.social.comment.AmityCommentRepository
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers
import io.reactivex.rxjava3.schedulers.Schedulers
import io.reactivex.rxjava3.disposables.CompositeDisposable

class CommentEditingManager(
    private val commentRepository: AmityCommentRepository
) {
    private val disposables = CompositeDisposable()
    
    // Basic text editing
    fun updateCommentText(
        commentId: String,
        newText: String,
        onSuccess: (AmityComment) -> Unit,
        onError: (Throwable) -> Unit
    ) {
        commentRepository.updateComment(commentId, newText)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ comment ->
                onSuccess(comment)
            }, { error ->
                onError(error)
            })
            .let(disposables::add)
    }
    
    // Validation helper
    fun canEditComment(comment: AmityComment, userId: String): Boolean {
        // Check ownership
        if (comment.userId != userId) return false
        
        // Check if not deleted
        if (comment.isDeleted == true) return false
        
        // Optional: Check edit time window (24 hours)
        comment.createdAt?.let { createdAt ->
            val hoursSinceCreation = (System.currentTimeMillis() - createdAt.time) / (1000 * 60 * 60)
            if (hoursSinceCreation > 24) return false
        }
        
        return true
    }
    
    // Safe editing with validation
    fun safeUpdateComment(
        commentId: String,
        newText: String,
        currentUserId: String,
        onValidationError: (String) -> Unit,
        onSuccess: (AmityComment) -> Unit,
        onError: (Throwable) -> Unit
    ) {
        // Input validation
        val trimmedText = newText.trim()
        when {
            trimmedText.isEmpty() -> {
                onValidationError("Comment cannot be empty")
                return
            }
            trimmedText.length > 2048 -> {
                onValidationError("Comment exceeds maximum length")
                return
            }
        }
        
        // First get the comment to validate permissions
        commentRepository.getComment(commentId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ comment ->
                if (canEditComment(comment, currentUserId)) {
                    updateCommentText(commentId, trimmedText, onSuccess, onError)
                } else {
                    onValidationError("You don't have permission to edit this comment")
                }
            }, { error ->
                onError(error)
            })
            .let(disposables::add)
    }
    
    // Edit with optimistic updates
    fun updateCommentWithOptimisticUI(
        commentId: String,
        newText: String,
        onOptimisticUpdate: (String) -> Unit,
        onSuccess: (AmityComment) -> Unit,
        onError: (Throwable) -> Unit,
        onRollback: () -> Unit
    ) {
        // Apply optimistic update
        onOptimisticUpdate(newText)
        
        // Perform actual update
        commentRepository.updateComment(commentId, newText)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ comment ->
                onSuccess(comment)
            }, { error ->
                // Rollback optimistic update on failure
                onRollback()
                onError(error)
            })
            .let(disposables::add)
    }
    
    fun cleanup() {
        disposables.clear()
    }
}

// Usage in Activity/Fragment
class CommentActivity : AppCompatActivity() {
    private lateinit var editingManager: CommentEditingManager
    private lateinit var commentEditText: EditText
    private lateinit var saveButton: Button
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        editingManager = CommentEditingManager(AmityCommentRepository.get())
        
        saveButton.setOnClickListener {
            val newText = commentEditText.text.toString()
            
            editingManager.safeUpdateComment(
                commentId = currentCommentId,
                newText = newText,
                currentUserId = getCurrentUserId(),
                onValidationError = { error ->
                    showError(error)
                },
                onSuccess = { updatedComment ->
                    showSuccess("Comment updated successfully!")
                    displayEditIndicator(updatedComment.editedAt)
                },
                onError = { error ->
                    showError("Failed to update comment: ${error.message}")
                }
            )
        }
    }
    
    private fun displayEditIndicator(editedAt: Date?) {
        if (editedAt != null) {
            val editIndicator = findViewById<TextView>(R.id.editIndicator)
            editIndicator.visibility = View.VISIBLE
            editIndicator.text = "Edited ${formatRelativeTime(editedAt)}"
        }
    }
    
    override fun onDestroy() {
        super.onDestroy()
        editingManager.cleanup()
    }
}
```
</Tab>

<Tab title="TypeScript">
```typescript
import { CommentRepository, AmityComment } from '@amityco/ts-sdk';

interface CommentEditOptions {
  commentId: string;
  newText: string;
  userId: string;
  validatePermissions?: boolean;
  maxLength?: number;
}

interface CommentEditResult {
  success: boolean;
  comment?: AmityComment;
  error?: string;
}

class CommentEditingService {
  private readonly maxLength: number = 2048;
  private readonly editTimeWindow: number = 24 * 60 * 60 * 1000; // 24 hours
  
  // Basic text editing
  async updateCommentText(commentId: string, newText: string): Promise<AmityComment> {
    try {
      const updatedComment = await CommentRepository.updateComment(commentId, newText);
      return updatedComment;
    } catch (error) {
      throw new Error(`Failed to update comment: ${error}`);
    }
  }
  
  // Permission validation
  canEditComment(comment: AmityComment, userId: string): boolean {
    // Check ownership
    if (comment.userId !== userId) return false;
    
    // Check if not deleted
    if (comment.isDeleted) return false;
    
    // Optional: Check edit time window
    if (comment.createdAt) {
      const timeSinceCreation = Date.now() - comment.createdAt.getTime();
      if (timeSinceCreation > this.editTimeWindow) return false;
    }
    
    return true;
  }
  
  // Input validation
  validateCommentText(text: string, maxLength: number = this.maxLength): string | null {
    const trimmedText = text.trim();
    
    if (trimmedText.length === 0) {
      return 'Comment cannot be empty';
    }
    
    if (trimmedText.length > maxLength) {
      return `Comment exceeds maximum length of ${maxLength} characters`;
    }
    
    return null;
  }
  
  // Safe editing with comprehensive validation
  async safeUpdateComment(options: CommentEditOptions): Promise<CommentEditResult> {
    const { commentId, newText, userId, validatePermissions = true, maxLength = this.maxLength } = options;
    
    try {
      // Input validation
      const validationError = this.validateCommentText(newText, maxLength);
      if (validationError) {
        return { success: false, error: validationError };
      }
      
      // Permission validation if requested
      if (validatePermissions) {
        const currentComment = await CommentRepository.getComment(commentId);
        if (!this.canEditComment(currentComment, userId)) {
          return { success: false, error: 'You do not have permission to edit this comment' };
        }
      }
      
      // Perform update
      const updatedComment = await this.updateCommentText(commentId, newText.trim());
      
      return { success: true, comment: updatedComment };
      
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error occurred' 
      };
    }
  }
  
  // Edit with optimistic updates
  async updateCommentWithOptimisticUI(
    commentId: string,
    newText: string,
    onOptimisticUpdate: (text: string) => void,
    onRollback: () => void
  ): Promise<CommentEditResult> {
    
    // Apply optimistic update
    const originalText = getCurrentCommentText(commentId);
    onOptimisticUpdate(newText);
    
    try {
      const updatedComment = await this.updateCommentText(commentId, newText);
      return { success: true, comment: updatedComment };
      
    } catch (error) {
      // Rollback on failure
      onRollback();
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Update failed' 
      };
    }
  }
  
  // Batch text editing
  async batchUpdateComments(
    updates: Array<{ commentId: string; newText: string; userId: string }>,
    onProgress?: (completed: number, total: number) => void
  ): Promise<Array<CommentEditResult>> {
    const results: CommentEditResult[] = [];
    
    for (let i = 0; i < updates.length; i++) {
      const update = updates[i];
      const result = await this.safeUpdateComment(update);
      results.push(result);
      
      onProgress?.(i + 1, updates.length);
    }
    
    return results;
  }
}

// Usage Examples
const editingService = new CommentEditingService();

// Basic editing
async function editComment() {
  const result = await editingService.safeUpdateComment({
    commentId: 'comment123',
    newText: 'This is my updated comment!',
    userId: 'user456'
  });
  
  if (result.success) {
    console.log('Comment updated:', result.comment);
    showEditIndicator(result.comment!.editedAt);
  } else {
    console.error('Edit failed:', result.error);
    showErrorMessage(result.error!);
  }
}

// Optimistic editing for better UX
async function editCommentOptimistically() {
  const commentElement = document.getElementById('comment-123');
  const originalText = commentElement?.textContent || '';
  
  const result = await editingService.updateCommentWithOptimisticUI(
    'comment123',
    'Updated text',
    (newText) => {
      // Optimistic update
      if (commentElement) commentElement.textContent = newText;
    },
    () => {
      // Rollback
      if (commentElement) commentElement.textContent = originalText;
    }
  );
  
  if (result.success) {
    showEditIndicator(result.comment!.editedAt);
  } else {
    showErrorMessage(result.error!);
  }
}

// Helper functions
function getCurrentCommentText(commentId: string): string {
  const element = document.getElementById(`comment-${commentId}`);
  return element?.textContent || '';
}

function showEditIndicator(editedAt?: Date) {
  if (editedAt) {
    const indicator = document.createElement('span');
    indicator.className = 'edit-indicator';
    indicator.textContent = `Edited ${formatRelativeTime(editedAt)}`;
    // Append to comment element
  }
}

function showErrorMessage(error: string) {
  // Display error to user
  console.error(error);
}

function formatRelativeTime(date: Date): string {
  const now = new Date();
  const diff = now.getTime() - date.getTime();
  const minutes = Math.floor(diff / (1000 * 60));
  
  if (minutes < 1) return 'just now';
  if (minutes < 60) return `${minutes}m ago`;
  
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours}h ago`;
  
  const days = Math.floor(hours / 24);
  return `${days}d ago`;
}
```
</Tab>

<Tab title="Flutter">
```dart
import 'package:amity_sdk/amity_sdk.dart';

class CommentEditingService {
  final AmitySocialClient _socialClient;
  static const int maxCommentLength = 2048;
  static const Duration editTimeWindow = Duration(hours: 24);
  
  CommentEditingService(this._socialClient);
  
  // Basic text editing
  Future<AmityComment> updateCommentText(String commentId, String newText) async {
    try {
      final updatedComment = await _socialClient
          .newCommentRepository()
          .updateComment(commentId: commentId, text: newText);
      return updatedComment;
    } catch (error) {
      throw Exception('Failed to update comment: $error');
    }
  }
  
  // Permission validation
  bool canEditComment(AmityComment comment, String userId) {
    // Check ownership
    if (comment.userId != userId) return false;
    
    // Check if not deleted
    if (comment.isDeleted == true) return false;
    
    // Optional: Check edit time window
    if (comment.createdAt != null) {
      final timeSinceCreation = DateTime.now().difference(comment.createdAt!);
      if (timeSinceCreation > editTimeWindow) return false;
    }
    
    return true;
  }
  
  // Input validation
  String? validateCommentText(String text, {int maxLength = maxCommentLength}) {
    final trimmedText = text.trim();
    
    if (trimmedText.isEmpty) {
      return 'Comment cannot be empty';
    }
    
    if (trimmedText.length > maxLength) {
      return 'Comment exceeds maximum length of $maxLength characters';
    }
    
    return null;
  }
  
  // Safe editing with validation
  Future<CommentEditResult> safeUpdateComment({
    required String commentId,
    required String newText,
    required String userId,
    bool validatePermissions = true,
  }) async {
    try {
      // Input validation
      final validationError = validateCommentText(newText);
      if (validationError != null) {
        return CommentEditResult.error(validationError);
      }
      
      // Permission validation if requested
      if (validatePermissions) {
        final currentComment = await _socialClient
            .newCommentRepository()
            .getComment(commentId: commentId);
        if (!canEditComment(currentComment, userId)) {
          return CommentEditResult.error('You do not have permission to edit this comment');
        }
      }
      
      // Perform update
      final updatedComment = await updateCommentText(commentId, newText.trim());
      return CommentEditResult.success(updatedComment);
      
    } catch (error) {
      return CommentEditResult.error('Failed to update comment: $error');
    }
  }
  
  // Edit with user confirmation
  Future<CommentEditResult> updateCommentWithConfirmation({
    required String commentId,
    required String newText,
    required String userId,
    required BuildContext context,
  }) async {
    final bool? confirmed = await showDialog<bool>(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text('Edit Comment'),
          content: Text('Are you sure you want to update this comment?'),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: Text('Update'),
            ),
          ],
        );
      },
    );
    
    if (confirmed != true) {
      return CommentEditResult.error('Update cancelled by user');
    }
    
    return safeUpdateComment(
      commentId: commentId,
      newText: newText,
      userId: userId,
    );
  }
  
  // Batch editing
  Future<List<CommentEditResult>> batchUpdateComments({
    required List<CommentUpdateRequest> updates,
    Function(int completed, int total)? onProgress,
  }) async {
    final List<CommentEditResult> results = [];
    
    for (int i = 0; i < updates.length; i++) {
      final update = updates[i];
      final result = await safeUpdateComment(
        commentId: update.commentId,
        newText: update.newText,
        userId: update.userId,
      );
      results.add(result);
      
      onProgress?.call(i + 1, updates.length);
    }
    
    return results;
  }
}

// Data classes
class CommentEditResult {
  final bool success;
  final AmityComment? comment;
  final String? error;
  
  CommentEditResult.success(this.comment) : success = true, error = null;
  CommentEditResult.error(this.error) : success = false, comment = null;
}

// Usage in Widget
class CommentEditWidget extends StatefulWidget {
  final AmityComment comment;
  final String currentUserId;
  
  const CommentEditWidget({
    Key? key,
    required this.comment,
    required this.currentUserId,
  }) : super(key: key);
  
  @override
  _CommentEditWidgetState createState() => _CommentEditWidgetState();
}

class _CommentEditWidgetState extends State<CommentEditWidget> {
  late TextEditingController _textController;
  late CommentEditingService _editingService;
  bool _isEditing = false;
  bool _isSaving = false;
  
  @override
  void initState() {
    super.initState();
    _textController = TextEditingController(text: widget.comment.text);
    _editingService = CommentEditingService(AmityCoreClient.newClient());
  }
  
  @override
  void dispose() {
    _textController.dispose();
    super.dispose();
  }
  
  Future<void> _saveEdit() async {
    setState(() {
      _isSaving = true;
    });
    
    final result = await _editingService.safeUpdateComment(
      commentId: widget.comment.commentId!,
      newText: _textController.text,
      userId: widget.currentUserId,
    );
    
    setState(() {
      _isSaving = false;
    });
    
    if (result.success) {
      setState(() {
        _isEditing = false;
      });
      
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Comment updated successfully'),
          backgroundColor: Colors.green,
        ),
      );
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(result.error ?? 'Failed to update comment'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (_isEditing) ...[
              TextField(
                controller: _textController,
                maxLines: null,
                maxLength: CommentEditingService.maxCommentLength,
                decoration: InputDecoration(
                  hintText: 'Edit your comment...',
                  border: OutlineInputBorder(),
                ),
              ),
              SizedBox(height: 8),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: _isSaving ? null : () {
                      setState(() {
                        _isEditing = false;
                        _textController.text = widget.comment.text ?? '';
                      });
                    },
                    child: Text('Cancel'),
                  ),
                  SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: _isSaving ? null : _saveEdit,
                    child: _isSaving 
                        ? SizedBox(
                            width: 16,
                            height: 16,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          )
                        : Text('Save'),
                  ),
                ],
              ),
            ] else ...[
              Text(widget.comment.text ?? ''),
              if (widget.comment.editedAt != null) ...[
                SizedBox(height: 4),
                Text(
                  'Edited ${_formatRelativeTime(widget.comment.editedAt!)}',
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey[600],
                    fontStyle: FontStyle.italic,
                  ),
                ),
              ],
              if (widget.comment.userId == widget.currentUserId) ...[
                SizedBox(height: 8),
                Align(
                  alignment: Alignment.centerRight,
                  child: TextButton(
                    onPressed: () {
                      setState(() {
                        _isEditing = true;
                      });
                    },
                    child: Text('Edit'),
                  ),
                ),
              ],
            ],
          ],
        ),
      ),
    );
  }
  
  String _formatRelativeTime(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);
    
    if (difference.inMinutes < 1) return 'just now';
    if (difference.inMinutes < 60) return '${difference.inMinutes}m ago';
    if (difference.inHours < 24) return '${difference.inHours}h ago';
    return '${difference.inDays}d ago';
  }
}
```
</Tab>
</Tabs>

## Image Comment Editing

Enable users to add, remove, or replace images in their existing comments with comprehensive image management capabilities.

<Info>
Before editing images in comments, ensure images are uploaded to obtain file IDs. Refer to the [Image Handling Guide](/social-plus-sdk/core-concepts/content-handling/files-images-and-videos/image-handling#upload-images) for upload procedures.
</Info>

<Tabs>
<Tab title="iOS">
```swift
extension CommentEditingManager {
    
    // MARK: - Image Management
    func updateCommentWithImages(
        commentId: String,
        text: String,
        imageFileIds: [String]
    ) async throws -> AmityComment {
        return try await withCheckedThrowingContinuation { continuation in
            repository.updateComment(
                withId: commentId,
                text: text,
                fileIds: imageFileIds
            ) { comment, error in
                if let error = error {
                    continuation.resume(throwing: error)
                } else if let comment = comment {
                    continuation.resume(returning: comment)
                } else {
                    continuation.resume(throwing: CommentEditError.updateFailed)
                }
            }
        }
    }
    
    // MARK: - Add Images to Existing Comment
    func addImagesToComment(
        commentId: String,
        newImageFileIds: [String]
    ) async throws -> AmityComment {
        
        // Get current comment to preserve existing images
        let currentComment = try await getComment(commentId: commentId)
        let existingImageIds = currentComment.images?.compactMap { $0.fileId } ?? []
        
        // Combine existing and new image IDs
        let allImageIds = existingImageIds + newImageFileIds
        
        // Validate total image count
        guard allImageIds.count <= 10 else {
            throw CommentEditError.tooManyImages
        }
        
        return try await updateCommentWithImages(
            commentId: commentId,
            text: currentComment.text ?? "",
            imageFileIds: allImageIds
        )
    }
    
    // MARK: - Remove Images from Comment
    func removeImagesFromComment(
        commentId: String,
        imageIdsToRemove: [String]
    ) async throws -> AmityComment {
        
        let currentComment = try await getComment(commentId: commentId)
        let existingImageIds = currentComment.images?.compactMap { $0.fileId } ?? []
        
        // Filter out images to remove
        let remainingImageIds = existingImageIds.filter { !imageIdsToRemove.contains($0) }
        
        return try await updateCommentWithImages(
            commentId: commentId,
            text: currentComment.text ?? "",
            imageFileIds: remainingImageIds
        )
    }
    
    // MARK: - Replace All Images
    func replaceCommentImages(
        commentId: String,
        newImageFileIds: [String]
    ) async throws -> AmityComment {
        
        guard newImageFileIds.count <= 10 else {
            throw CommentEditError.tooManyImages
        }
        
        let currentComment = try await getComment(commentId: commentId)
        
        return try await updateCommentWithImages(
            commentId: commentId,
            text: currentComment.text ?? "",
            imageFileIds: newImageFileIds
        )
    }
    
    // MARK: - Image Upload and Update
    func uploadAndUpdateCommentImages(
        commentId: String,
        newImages: [UIImage],
        compressionQuality: CGFloat = 0.8
    ) async throws -> AmityComment {
        
        // Upload new images
        let fileIds = try await uploadImages(newImages, quality: compressionQuality)
        
        // Add to existing comment
        return try await addImagesToComment(commentId: commentId, newImageFileIds: fileIds)
    }
    
    private func uploadImages(_ images: [UIImage], quality: CGFloat) async throws -> [String] {
        return try await withThrowingTaskGroup(of: String.self) { group in
            for image in images {
                group.addTask {
                    return try await self.uploadSingleImage(image, quality: quality)
                }
            }
            
            var fileIds: [String] = []
            for try await fileId in group {
                fileIds.append(fileId)
            }
            return fileIds
        }
    }
    
    private func uploadSingleImage(_ image: UIImage, quality: CGFloat) async throws -> String {
        guard let imageData = image.jpegData(compressionQuality: quality) else {
            throw CommentEditError.imageProcessingFailed
        }
        
        // Upload image using Amity file upload
        return try await withCheckedThrowingContinuation { continuation in
            AmityFileRepository(client: client).uploadImage(
                imageData,
                progress: nil
            ) { result in
                switch result {
                case .success(let fileInfo):
                    continuation.resume(returning: fileInfo.fileId)
                case .failure(let error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
}

// Extended Error Types
extension CommentEditError {
    static let tooManyImages = CommentEditError.validationError("Maximum 10 images allowed per comment")
    static let imageProcessingFailed = CommentEditError.validationError("Failed to process image")
    
    case validationError(String)
}

// Usage Examples
Task {
    do {
        // Add new images to existing comment
        let updatedComment = try await editingManager.addImagesToComment(
            commentId: "comment123",
            newImageFileIds: ["file456", "file789"]
        )
        
        // Remove specific images
        let commentWithRemovedImages = try await editingManager.removeImagesFromComment(
            commentId: "comment123",
            imageIdsToRemove: ["file456"]
        )
        
        // Upload and add new images
        let newImages = [UIImage(named: "photo1")!, UIImage(named: "photo2")!]
        let commentWithNewImages = try await editingManager.uploadAndUpdateCommentImages(
            commentId: "comment123",
            newImages: newImages
        )
        
    } catch {
        print("Image editing failed: \(error)")
    }
}
```
</Tab>

<Tab title="Android">
```kotlin
// Image editing extensions for CommentEditingManager
class ImageCommentEditingManager(
    private val commentRepository: AmityCommentRepository,
    private val fileRepository: AmityFileRepository
) {
    private val maxImagesPerComment = 10
    
    // Update comment with images
    fun updateCommentWithImages(
        commentId: String,
        text: String,
        imageFileIds: List<String>,
        onSuccess: (AmityComment) -> Unit,
        onError: (Throwable) -> Unit
    ) {
        commentRepository.updateComment(commentId, text, imageFileIds)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ comment ->
                onSuccess(comment)
            }, { error ->
                onError(error)
            })
    }
    
    // Add images to existing comment
    fun addImagesToComment(
        commentId: String,
        newImageFileIds: List<String>,
        onSuccess: (AmityComment) -> Unit,
        onError: (Throwable) -> Unit
    ) {
        // First get current comment
        commentRepository.getComment(commentId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ currentComment ->
                val existingImageIds = currentComment.images?.map { it.fileId } ?: emptyList()
                val allImageIds = existingImageIds + newImageFileIds
                
                if (allImageIds.size > maxImagesPerComment) {
                    onError(Exception("Maximum $maxImagesPerComment images allowed per comment"))
                    return@subscribe
                }
                
                updateCommentWithImages(
                    commentId,
                    currentComment.text ?: "",
                    allImageIds,
                    onSuccess,
                    onError
                )
            }, { error ->
                onError(error)
            })
    }
    
    // Remove images from comment
    fun removeImagesFromComment(
        commentId: String,
        imageIdsToRemove: List<String>,
        onSuccess: (AmityComment) -> Unit,
        onError: (Throwable) -> Unit
    ) {
        commentRepository.getComment(commentId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ currentComment ->
                val existingImageIds = currentComment.images?.map { it.fileId } ?: emptyList()
                val remainingImageIds = existingImageIds.filter { !imageIdsToRemove.contains(it) }
                
                updateCommentWithImages(
                    commentId,
                    currentComment.text ?: "",
                    remainingImageIds,
                    onSuccess,
                    onError
                )
            }, { error ->
                onError(error)
            })
    }
    
    // Upload and add images
    fun uploadAndAddImages(
        commentId: String,
        imageUris: List<Uri>,
        context: Context,
        onProgress: (Int, Int) -> Unit,
        onSuccess: (AmityComment) -> Unit,
        onError: (Throwable) -> Unit
    ) {
        val uploadTasks = imageUris.mapIndexed { index, uri ->
            uploadImageFromUri(uri, context)
                .doOnSuccess { 
                    onProgress(index + 1, imageUris.size)
                }
        }
        
        Single.zip(uploadTasks) { results ->
            results.map { it as String }
        }
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe({ fileIds ->
            addImagesToComment(commentId, fileIds, onSuccess, onError)
        }, { error ->
            onError(error)
        })
    }
    
    private fun uploadImageFromUri(uri: Uri, context: Context): Single<String> {
        return Single.create { emitter ->
            try {
                val inputStream = context.contentResolver.openInputStream(uri)
                val bitmap = BitmapFactory.decodeStream(inputStream)
                
                val outputStream = ByteArrayOutputStream()
                bitmap.compress(Bitmap.CompressFormat.JPEG, 80, outputStream)
                val imageData = outputStream.toByteArray()
                
                fileRepository.uploadImage(imageData)
                    .subscribe({ fileInfo ->
                        emitter.onSuccess(fileInfo.fileId)
                    }, { error ->
                        emitter.onError(error)
                    })
                    
            } catch (e: Exception) {
                emitter.onError(e)
            }
        }
    }
}

// Usage in Activity
class CommentEditActivity : AppCompatActivity() {
    private lateinit var imageEditingManager: ImageCommentEditingManager
    private val imagePickerLauncher = registerForActivityResult(
        ActivityResultContracts.GetMultipleContents()
    ) { uris ->
        if (uris.isNotEmpty()) {
            addImagesToComment(uris)
        }
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        imageEditingManager = ImageCommentEditingManager(
            AmityCommentRepository.get(),
            AmityFileRepository.get()
        )
        
        findViewById<Button>(R.id.addImagesButton).setOnClickListener {
            imagePickerLauncher.launch("image/*")
        }
    }
    
    private fun addImagesToComment(imageUris: List<Uri>) {
        val progressDialog = ProgressDialog(this).apply {
            setTitle("Uploading Images")
            setProgressStyle(ProgressDialog.STYLE_HORIZONTAL)
            max = imageUris.size
            show()
        }
        
        imageEditingManager.uploadAndAddImages(
            commentId = currentCommentId,
            imageUris = imageUris,
            context = this,
            onProgress = { completed, total ->
                progressDialog.progress = completed
                progressDialog.setMessage("$completed/$total images uploaded")
            },
            onSuccess = { updatedComment ->
                progressDialog.dismiss()
                Toast.makeText(this, "Images added successfully", Toast.LENGTH_SHORT).show()
                updateCommentDisplay(updatedComment)
            },
            onError = { error ->
                progressDialog.dismiss()
                Toast.makeText(this, "Failed to add images: ${error.message}", Toast.LENGTH_LONG).show()
            }
        )
    }
}
```
</Tab>

<Tab title="TypeScript">
```typescript
interface ImageEditOptions {
  commentId: string;
  text?: string;
  imageFileIds: string[];
  preserveExistingImages?: boolean;
}

interface ImageUploadResult {
  fileId: string;
  url: string;
  filename: string;
}

class ImageCommentEditingService extends CommentEditingService {
  private readonly maxImagesPerComment = 10;
  
  // Update comment with images
  async updateCommentWithImages(options: ImageEditOptions): Promise<AmityComment> {
    const { commentId, text, imageFileIds, preserveExistingImages = false } = options;
    
    let finalImageIds = imageFileIds;
    
    if (preserveExistingImages) {
      const currentComment = await CommentRepository.getComment(commentId);
      const existingImageIds = currentComment.images?.map(img => img.fileId) || [];
      finalImageIds = [...existingImageIds, ...imageFileIds];
    }
    
    if (finalImageIds.length > this.maxImagesPerComment) {
      throw new Error(`Maximum ${this.maxImagesPerComment} images allowed per comment`);
    }
    
    return await CommentRepository.updateComment(commentId, text, finalImageIds);
  }
  
  // Add images to existing comment
  async addImagesToComment(commentId: string, newImageFileIds: string[]): Promise<AmityComment> {
    const currentComment = await CommentRepository.getComment(commentId);
    const existingImageIds = currentComment.images?.map(img => img.fileId) || [];
    const allImageIds = [...existingImageIds, ...newImageFileIds];
    
    if (allImageIds.length > this.maxImagesPerComment) {
      throw new Error(`Maximum ${this.maxImagesPerComment} images allowed per comment`);
    }
    
    return await CommentRepository.updateComment(commentId, currentComment.text, allImageIds);
  }
  
  // Remove specific images from comment
  async removeImagesFromComment(commentId: string, imageIdsToRemove: string[]): Promise<AmityComment> {
    const currentComment = await CommentRepository.getComment(commentId);
    const existingImageIds = currentComment.images?.map(img => img.fileId) || [];
    const remainingImageIds = existingImageIds.filter(id => !imageIdsToRemove.includes(id));
    
    return await CommentRepository.updateComment(commentId, currentComment.text, remainingImageIds);
  }
  
  // Upload and add images
  async uploadAndAddImages(
    commentId: string,
    imageFiles: File[],
    onProgress?: (completed: number, total: number) => void
  ): Promise<AmityComment> {
    
    // Upload images
    const uploadResults = await this.uploadImages(imageFiles, onProgress);
    const fileIds = uploadResults.map(result => result.fileId);
    
    // Add to comment
    return await this.addImagesToComment(commentId, fileIds);
  }
  
  // Batch upload images
  private async uploadImages(
    files: File[],
    onProgress?: (completed: number, total: number) => void
  ): Promise<ImageUploadResult[]> {
    const results: ImageUploadResult[] = [];
    
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const result = await this.uploadSingleImage(file);
      results.push(result);
      
      onProgress?.(i + 1, files.length);
    }
    
    return results;
  }
  
  private async uploadSingleImage(file: File): Promise<ImageUploadResult> {
    // Validate file
    if (!file.type.startsWith('image/')) {
      throw new Error('File must be an image');
    }
    
    if (file.size > 10 * 1024 * 1024) { // 10MB limit
      throw new Error('Image size must be less than 10MB');
    }
    
    // Upload using FileRepository
    const uploadResult = await FileRepository.uploadImage(file);
    
    return {
      fileId: uploadResult.fileId,
      url: uploadResult.fileUrl,
      filename: file.name
    };
  }
  
  // Replace all images in comment
  async replaceCommentImages(commentId: string, newImageFileIds: string[]): Promise<AmityComment> {
    if (newImageFileIds.length > this.maxImagesPerComment) {
      throw new Error(`Maximum ${this.maxImagesPerComment} images allowed per comment`);
    }
    
    const currentComment = await CommentRepository.getComment(commentId);
    return await CommentRepository.updateComment(commentId, currentComment.text, newImageFileIds);
  }
  
  // Get image editing suggestions
  async getImageEditingSuggestions(commentId: string): Promise<ImageEditingSuggestion[]> {
    const comment = await CommentRepository.getComment(commentId);
    const suggestions: ImageEditingSuggestion[] = [];
    
    if (!comment.images || comment.images.length === 0) {
      suggestions.push({
        type: 'ADD_IMAGES',
        title: 'Add Images',
        description: 'Make your comment more engaging by adding images'
      });
    } else if (comment.images.length < this.maxImagesPerComment) {
      suggestions.push({
        type: 'ADD_MORE_IMAGES',
        title: 'Add More Images',
        description: `You can add ${this.maxImagesPerComment - comment.images.length} more images`
      });
    }
    
    if (comment.images && comment.images.length > 0) {
      suggestions.push({
        type: 'REPLACE_IMAGES',
        title: 'Replace Images',
        description: 'Update your comment with different images'
      });
    }
    
    return suggestions;
  }
}

interface ImageEditingSuggestion {
  type: 'ADD_IMAGES' | 'ADD_MORE_IMAGES' | 'REPLACE_IMAGES';
  title: string;
  description: string;
}

// Usage Examples
const imageEditingService = new ImageCommentEditingService();

// Add images with progress tracking
const fileInput = document.getElementById('imageInput') as HTMLInputElement;
const files = Array.from(fileInput.files || []);

try {
  const updatedComment = await imageEditingService.uploadAndAddImages(
    'comment123',
    files,
    (completed, total) => {
      console.log(`Upload progress: ${completed}/${total}`);
      updateProgressBar((completed / total) * 100);
    }
  );
  
  console.log('Images added successfully:', updatedComment);
} catch (error) {
  console.error('Failed to add images:', error);
}

// Remove specific images
const imageIdsToRemove = ['file123', 'file456'];
try {
  const updatedComment = await imageEditingService.removeImagesFromComment(
    'comment123',
    imageIdsToRemove
  );
  
  console.log('Images removed successfully:', updatedComment);
} catch (error) {
  console.error('Failed to remove images:', error);
}
```
</Tab>

<Tab title="Flutter">
```dart
// Image editing extensions for CommentEditingService
extension ImageCommentEditing on CommentEditingService {
  static const int maxImagesPerComment = 10;
  
  // Update comment with images
  Future<AmityComment> updateCommentWithImages({
    required String commentId,
    String? text,
    required List<String> imageFileIds,
    bool preserveExistingImages = false,
  }) async {
    List<String> finalImageIds = imageFileIds;
    
    if (preserveExistingImages) {
      final currentComment = await _socialClient
          .newCommentRepository()
          .getComment(commentId: commentId);
      
      final existingImageIds = currentComment.images
          ?.map((img) => img.fileId)
          .where((id) => id != null)
          .cast<String>()
          .toList() ?? [];
      
      finalImageIds = [...existingImageIds, ...imageFileIds];
    }
    
    if (finalImageIds.length > maxImagesPerComment) {
      throw Exception('Maximum $maxImagesPerComment images allowed per comment');
    }
    
    return await _socialClient.newCommentRepository().updateComment(
      commentId: commentId,
      text: text,
      fileIds: finalImageIds,
    );
  }
  
  // Add images to existing comment
  Future<AmityComment> addImagesToComment({
    required String commentId,
    required List<String> newImageFileIds,
  }) async {
    final currentComment = await _socialClient
        .newCommentRepository()
        .getComment(commentId: commentId);
    
    final existingImageIds = currentComment.images
        ?.map((img) => img.fileId)
        .where((id) => id != null)
        .cast<String>()
        .toList() ?? [];
    
    final allImageIds = [...existingImageIds, ...newImageFileIds];
    
    if (allImageIds.length > maxImagesPerComment) {
      throw Exception('Maximum $maxImagesPerComment images allowed per comment');
    }
    
    return await _socialClient.newCommentRepository().updateComment(
      commentId: commentId,
      text: currentComment.text,
      fileIds: allImageIds,
    );
  }
  
  // Remove images from comment
  Future<AmityComment> removeImagesFromComment({
    required String commentId,
    required List<String> imageIdsToRemove,
  }) async {
    final currentComment = await _socialClient
        .newCommentRepository()
        .getComment(commentId: commentId);
    
    final existingImageIds = currentComment.images
        ?.map((img) => img.fileId)
        .where((id) => id != null)
        .cast<String>()
        .toList() ?? [];
    
    final remainingImageIds = existingImageIds
        .where((id) => !imageIdsToRemove.contains(id))
        .toList();
    
    return await _socialClient.newCommentRepository().updateComment(
      commentId: commentId,
      text: currentComment.text,
      fileIds: remainingImageIds,
    );
  }
  
  // Upload and add images
  Future<AmityComment> uploadAndAddImages({
    required String commentId,
    required List<File> imageFiles,
    Function(int completed, int total)? onProgress,
    double compressionQuality = 0.8,
  }) async {
    // Upload images
    final fileIds = await _uploadImages(
      imageFiles,
      onProgress: onProgress,
      compressionQuality: compressionQuality,
    );
    
    // Add to comment
    return await addImagesToComment(
      commentId: commentId,
      newImageFileIds: fileIds,
    );
  }
  
  // Upload images with progress tracking
  Future<List<String>> _uploadImages(
    List<File> imageFiles, {
    Function(int completed, int total)? onProgress,
    double compressionQuality = 0.8,
  }) async {
    final List<String> fileIds = [];
    
    for (int i = 0; i < imageFiles.length; i++) {
      final file = imageFiles[i];
      
      // Validate file
      if (!_isValidImageFile(file)) {
        throw Exception('Invalid image file: ${file.path}');
      }
      
      // Compress image if needed
      final compressedFile = await _compressImage(file, compressionQuality);
      
      // Upload image
      final fileId = await _uploadSingleImage(compressedFile);
      fileIds.add(fileId);
      
      onProgress?.call(i + 1, imageFiles.length);
    }
    
    return fileIds;
  }
  
  bool _isValidImageFile(File file) {
    final validExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];
    final extension = file.path.split('.').last.toLowerCase();
    return validExtensions.contains(extension);
  }
  
  Future<File> _compressImage(File file, double quality) async {
    // Implement image compression logic
    // This could use packages like image_picker or flutter_image_compress
    return file; // Placeholder - implement actual compression
  }
  
  Future<String> _uploadSingleImage(File file) async {
    // Upload using Amity file upload
    final uploadResult = await _socialClient
        .newFileRepository()
        .uploadImage(file);
    
    return uploadResult.fileId!;
  }
  
  // Replace all images in comment
  Future<AmityComment> replaceCommentImages({
    required String commentId,
    required List<String> newImageFileIds,
  }) async {
    if (newImageFileIds.length > maxImagesPerComment) {
      throw Exception('Maximum $maxImagesPerComment images allowed per comment');
    }
    
    final currentComment = await _socialClient
        .newCommentRepository()
        .getComment(commentId: commentId);
    
    return await _socialClient.newCommentRepository().updateComment(
      commentId: commentId,
      text: currentComment.text,
      fileIds: newImageFileIds,
    );
  }
}

// Widget for image editing interface
class ImageCommentEditor extends StatefulWidget {
  final AmityComment comment;
  final String currentUserId;
  final Function(AmityComment) onCommentUpdated;
  
  const ImageCommentEditor({
    Key? key,
    required this.comment,
    required this.currentUserId,
    required this.onCommentUpdated,
  }) : super(key: key);
  
  @override
  _ImageCommentEditorState createState() => _ImageCommentEditorState();
}

class _ImageCommentEditorState extends State<ImageCommentEditor> {
  late CommentEditingService _editingService;
  bool _isUploading = false;
  double _uploadProgress = 0.0;
  
  @override
  void initState() {
    super.initState();
    _editingService = CommentEditingService(AmityCoreClient.newClient());
  }
  
  Future<void> _pickAndAddImages() async {
    final picker = ImagePicker();
    final images = await picker.pickMultiImage();
    
    if (images.isNotEmpty) {
      setState(() {
        _isUploading = true;
        _uploadProgress = 0.0;
      });
      
      try {
        final imageFiles = images.map((xFile) => File(xFile.path)).toList();
        
        final updatedComment = await _editingService.uploadAndAddImages(
          commentId: widget.comment.commentId!,
          imageFiles: imageFiles,
          onProgress: (completed, total) {
            setState(() {
              _uploadProgress = completed / total;
            });
          },
        );
        
        widget.onCommentUpdated(updatedComment);
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Images added successfully'),
            backgroundColor: Colors.green,
          ),
        );
        
      } catch (error) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to add images: $error'),
            backgroundColor: Colors.red,
          ),
        );
      } finally {
        setState(() {
          _isUploading = false;
        });
      }
    }
  }
  
  Future<void> _removeImage(String imageId) async {
    try {
      final updatedComment = await _editingService.removeImagesFromComment(
        commentId: widget.comment.commentId!,
        imageIdsToRemove: [imageId],
      );
      
      widget.onCommentUpdated(updatedComment);
      
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Image removed successfully'),
          backgroundColor: Colors.green,
        ),
      );
      
    } catch (error) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Failed to remove image: $error'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }
  
  @override
  Widget build(BuildContext context) {
    final images = widget.comment.images ?? [];
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Existing images
        if (images.isNotEmpty) ...[
          Text('Images', style: Theme.of(context).textTheme.subtitle1),
          SizedBox(height: 8),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: images.map((image) {
              return Stack(
                children: [
                  ClipRRect(
                    borderRadius: BorderRadius.circular(8),
                    child: Image.network(
                      image.fileUrl ?? '',
                      width: 100,
                      height: 100,
                      fit: BoxFit.cover,
                    ),
                  ),
                  if (widget.comment.userId == widget.currentUserId)
                    Positioned(
                      top: 4,
                      right: 4,
                      child: GestureDetector(
                        onTap: () => _removeImage(image.fileId!),
                        child: Container(
                          padding: EdgeInsets.all(4),
                          decoration: BoxDecoration(
                            color: Colors.red,
                            shape: BoxShape.circle,
                          ),
                          child: Icon(
                            Icons.close,
                            size: 16,
                            color: Colors.white,
                          ),
                        ),
                      ),
                    ),
                ],
              );
            }).toList(),
          ),
          SizedBox(height: 16),
        ],
        
        // Add images section
        if (widget.comment.userId == widget.currentUserId) ...[
          if (_isUploading) ...[
            LinearProgressIndicator(value: _uploadProgress),
            SizedBox(height: 8),
            Text('Uploading images... ${(_uploadProgress * 100).toInt()}%'),
          ] else ...[
            ElevatedButton.icon(
              onPressed: images.length < ImageCommentEditing.maxImagesPerComment 
                  ? _pickAndAddImages 
                  : null,
              icon: Icon(Icons.add_photo_alternate),
              label: Text('Add Images'),
            ),
            if (images.length >= ImageCommentEditing.maxImagesPerComment)
              Text(
                'Maximum ${ImageCommentEditing.maxImagesPerComment} images allowed',
                style: TextStyle(color: Colors.grey[600], fontSize: 12),
              ),
          ],
        ],
      ],
    );
  }
}
```
</Tab>
</Tabs>

### Supported Image Formats

| Format | Extension | Max Size | Compression |
|--------|-----------|----------|-------------|
| JPEG | `.jpg`, `.jpeg` | 10MB | Lossy |
| PNG | `.png` | 10MB | Lossless |
| GIF | `.gif` | 10MB | Lossless |
| WebP | `.webp` | 10MB | Lossy/Lossless |

### Image Editing Limitations

<Warning>
- Maximum 10 images per comment
- Maximum file size: 10MB per image
- Supported formats: JPEG, PNG, GIF, WebP
- Images are processed asynchronously
</Warning>

<Note>
Image editing functionality may not be available on all platforms. Refer to platform-specific documentation for current limitations.
</Note>

## Error Handling

Comprehensive error handling strategies for comment editing operations:

| Error Type | Cause | Resolution |
|------------|-------|------------|
| `PERMISSION_DENIED` | User lacks edit permissions | Verify comment ownership or admin rights |
| `COMMENT_NOT_FOUND` | Comment ID doesn't exist | Validate comment existence before editing |
| `VALIDATION_ERROR` | Invalid input data | Check text length, image count, and format |
| `EDIT_TIME_EXPIRED` | Comment too old to edit | Implement time-based edit restrictions |
| `CONTENT_FLAGGED` | Comment marked for moderation | Resolve moderation issues before editing |
| `NETWORK_ERROR` | Connection issues | Implement retry logic with exponential backoff |

<Tabs>
<Tab title="iOS Error Handling">
```swift
extension CommentEditError {
    var userFriendlyMessage: String {
        switch self {
        case .permissionDenied:
            return "You can only edit your own comments"
        case .commentNotFound:
            return "This comment no longer exists"
        case .textTooLong:
            return "Comment is too long. Please shorten it and try again"
        case .emptyText:
            return "Comment cannot be empty"
        case .tooManyImages:
            return "You can only add up to 10 images per comment"
        case .imageProcessingFailed:
            return "Failed to process image. Please try a different image"
        case .networkError(let error):
            return "Network error: \(error.localizedDescription)"
        default:
            return "An unexpected error occurred"
        }
    }
}

// Usage with user-friendly error messages
do {
    let updatedComment = try await editingManager.safeUpdateComment(
        commentId: commentId,
        newText: newText,
        currentUserId: currentUserId
    )
    showSuccess("Comment updated successfully!")
} catch let error as CommentEditError {
    showError(error.userFriendlyMessage)
} catch {
    showError("An unexpected error occurred")
}
```
</Tab>

<Tab title="Android Error Handling">
```kotlin
sealed class CommentEditError(val message: String, val userMessage: String) {
    object PermissionDenied : CommentEditError(
        "Permission denied", 
        "You can only edit your own comments"
    )
    object CommentNotFound : CommentEditError(
        "Comment not found", 
        "This comment no longer exists"
    )
    object TextTooLong : CommentEditError(
        "Text too long", 
        "Comment is too long. Please shorten it and try again"
    )
    object EmptyText : CommentEditError(
        "Empty text", 
        "Comment cannot be empty"
    )
    object TooManyImages : CommentEditError(
        "Too many images", 
        "You can only add up to 10 images per comment"
    )
    data class NetworkError(val throwable: Throwable) : CommentEditError(
        "Network error: ${throwable.message}", 
        "Network error. Please check your connection and try again"
    )
}

// Error handling with user feedback
editingManager.safeUpdateComment(
    commentId = commentId,
    newText = newText,
    currentUserId = currentUserId,
    onValidationError = { error ->
        showUserFriendlyError(error)
    },
    onSuccess = { comment ->
        showSuccess("Comment updated successfully!")
    },
    onError = { throwable ->
        val error = mapToCommentEditError(throwable)
        showUserFriendlyError(error.userMessage)
    }
)
```
</Tab>

<Tab title="TypeScript Error Handling">
```typescript
interface CommentEditError {
  code: string;
  message: string;
  userMessage: string;
  retryable: boolean;
}

class CommentEditingErrorHandler {
  static handle(error: any): CommentEditError {
    const baseError: CommentEditError = {
      code: 'UNKNOWN_ERROR',
      message: 'An unexpected error occurred',
      userMessage: 'Something went wrong. Please try again.',
      retryable: true
    };

    if (error?.code) {
      switch (error.code) {
        case 'PERMISSION_DENIED':
          return {
            ...baseError,
            code: 'PERMISSION_DENIED',
            message: 'User lacks edit permissions',
            userMessage: 'You can only edit your own comments',
            retryable: false
          };
        case 'VALIDATION_ERROR':
          return {
            ...baseError,
            code: 'VALIDATION_ERROR',
            message: error.message,
            userMessage: error.message,
            retryable: false
          };
        case 'NETWORK_ERROR':
          return {
            ...baseError,
            code: 'NETWORK_ERROR',
            message: 'Network connection failed',
            userMessage: 'Network error. Please check your connection and try again.',
            retryable: true
          };
        default:
          return baseError;
      }
    }

    return baseError;
  }
}

// Usage with error handling
try {
  const result = await editingService.safeUpdateComment({
    commentId: 'comment123',
    newText: 'Updated text',
    userId: 'user456'
  });
  
  if (result.success) {
    showSuccess('Comment updated successfully!');
  } else {
    const error = CommentEditingErrorHandler.handle({ message: result.error });
    showError(error.userMessage);
  }
} catch (error) {
  const handledError = CommentEditingErrorHandler.handle(error);
  showError(handledError.userMessage);
  
  if (handledError.retryable) {
    showRetryOption();
  }
}
```
</Tab>
</Tabs>

## Best Practices

<CardGroup cols={2}>
  <Card title="User Experience" icon="user">
    - Provide real-time validation feedback
    - Show clear edit indicators and timestamps
    - Implement optimistic updates for responsiveness
    - Offer preview before saving changes
  </Card>
  <Card title="Data Integrity" icon="shield">
    - Validate permissions before allowing edits
    - Implement proper error handling and rollback
    - Track edit history for audit purposes
    - Prevent concurrent edit conflicts
  </Card>
  <Card title="Performance" icon="bolt">
    - Use debounced auto-save for long edits
    - Implement efficient image compression
    - Cache comment data for offline editing
    - Optimize network requests with batching
  </Card>
  <Card title="Content Management" icon="file-text">
    - Set reasonable edit time windows
    - Implement content moderation hooks
    - Provide rich text editing capabilities
    - Support undo/redo functionality
  </Card>
</CardGroup>

### Implementation Guidelines

1. **Permission Validation**
   ```typescript
   // Always check edit permissions before showing edit UI
   const canEdit = await checkEditPermissions(comment, currentUser);
   if (!canEdit) {
     hideEditButton();
     return;
   }
   ```

2. **Input Validation**
   ```typescript
   // Validate input before submission
   const validation = validateCommentInput(newText, images);
   if (!validation.isValid) {
     showValidationErrors(validation.errors);
     return;
   }
   ```

3. **Optimistic Updates**
   ```typescript
   // Update UI immediately, rollback on failure
   updateCommentUI(newText);
   try {
     await updateComment(commentId, newText);
   } catch (error) {
     rollbackCommentUI(originalText);
     showError(error.message);
   }
   ```

4. **Edit History Tracking**
   ```typescript
   // Track edit history for transparency
   const editHistory = {
     editedAt: new Date(),
     editedBy: currentUser.id,
     previousText: originalText,
     newText: updatedText
   };
   await saveEditHistory(commentId, editHistory);
   ```

## Use Cases

<AccordionGroup>
  <Accordion title="Fixing Typos and Grammar">
    **Scenario**: User notices typos after posting a comment
    
    **Implementation**: 
    - Quick edit mode with inline text editing
    - Auto-save functionality to prevent loss
    - Clear indication of edited status
    
    ```typescript
    // Quick edit implementation
    const quickEdit = await editingService.updateCommentWithOptimisticUI(
      commentId,
      correctedText,
      (text) => updateCommentDisplay(text),
      () => revertCommentDisplay(originalText)
    );
    ```
  </Accordion>
  
  <Accordion title="Adding Context with Images">
    **Scenario**: User wants to add supporting images to their text comment
    
    **Implementation**:
    - Drag-and-drop image upload
    - Progress tracking for uploads
    - Image preview and management
    
    ```typescript
    // Add images to existing comment
    const updatedComment = await editingService.uploadAndAddImages(
      commentId,
      selectedImages,
      (progress) => updateUploadProgress(progress)
    );
    ```
  </Accordion>
  
  <Accordion title="Content Moderation Edits">
    **Scenario**: Moderator needs to edit inappropriate content
    
    **Implementation**:
    - Admin override for edit permissions
    - Audit trail for moderation actions
    - Notification to original author
    
    ```typescript
    // Moderator edit with audit trail
    const result = await editingService.moderatorEdit({
      commentId,
      newText: moderatedText,
      moderatorId: currentModerator.id,
      reason: 'Content policy violation'
    });
    ```
  </Accordion>
  
  <Accordion title="Collaborative Editing">
    **Scenario**: Multiple users can edit shared comments
    
    **Implementation**:
    - Real-time conflict detection
    - Merge conflict resolution
    - Version control system
    
    ```typescript
    // Collaborative edit with conflict resolution
    const result = await editingService.collaborativeEdit({
      commentId,
      newText,
      baseVersion: comment.version,
      userId: currentUser.id
    });
    ```
  </Accordion>
</AccordionGroup>

## Advanced Features

### Auto-Save Functionality

```typescript
class AutoSaveManager {
  private saveTimeout: NodeJS.Timeout | null = null;
  private readonly saveDelay = 2000; // 2 seconds
  
  scheduleAutoSave(commentId: string, content: string) {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }
    
    this.saveTimeout = setTimeout(async () => {
      try {
        await this.saveComment(commentId, content);
        this.showAutoSaveIndicator('Saved');
      } catch (error) {
        this.showAutoSaveIndicator('Failed to save');
      }
    }, this.saveDelay);
  }
  
  private async saveComment(commentId: string, content: string) {
    // Implement auto-save logic
    await editingService.updateCommentText(commentId, content);
  }
  
  private showAutoSaveIndicator(status: string) {
    // Show save status to user
    console.log(`Auto-save: ${status}`);
  }
}
```

### Edit Conflict Resolution

```typescript
interface EditConflict {
  commentId: string;
  currentVersion: number;
  conflictingVersion: number;
  userEdit: string;
  serverEdit: string;
}

class ConflictResolver {
  async resolveEditConflict(conflict: EditConflict): Promise<string> {
    // Present conflict resolution options to user
    const resolution = await this.showConflictDialog(conflict);
    
    switch (resolution) {
      case 'use_mine':
        return conflict.userEdit;
      case 'use_theirs':
        return conflict.serverEdit;
      case 'merge':
        return this.attemptAutoMerge(conflict);
      default:
        throw new Error('Conflict resolution cancelled');
    }
  }
  
  private async showConflictDialog(conflict: EditConflict): Promise<string> {
    // Show UI for conflict resolution
    return 'use_mine'; // Default resolution
  }
  
  private attemptAutoMerge(conflict: EditConflict): string {
    // Implement merge logic
    return conflict.userEdit; // Simplified merge
  }
}
```

## Performance Optimization

### Efficient Image Handling

```typescript
class ImageOptimizer {
  async optimizeImages(files: File[]): Promise<File[]> {
    const optimized = await Promise.all(
      files.map(file => this.optimizeImage(file))
    );
    return optimized;
  }
  
  private async optimizeImage(file: File): Promise<File> {
    // Compress image if too large
    if (file.size > 2 * 1024 * 1024) { // 2MB
      return await this.compressImage(file, 0.8);
    }
    return file;
  }
  
  private async compressImage(file: File, quality: number): Promise<File> {
    // Implement image compression
    return file; // Placeholder
  }
}
```

<Warning>
Comment editing should be implemented with proper permission checks and user feedback to ensure a secure and user-friendly experience. Always validate edit permissions before allowing modifications.
</Warning>

<Note>
Edit timestamps are automatically managed by the SDK and provide transparency about content modifications. Use these timestamps to create clear edit indicators in your user interface.
</Note>