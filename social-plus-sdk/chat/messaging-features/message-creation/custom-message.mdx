---
title: "Custom Messages"
description: "Create specialized message types with custom data structures for unique use cases"
---

# Custom Messages

Extend your chat capabilities beyond standard message types by creating custom messages with flexible data structures tailored to your application's unique requirements.

<CardGroup cols={2}>
  <Card title="Flexible Data" icon="code">
    Define custom JSON structures for any data type
  </Card>
  <Card title="Rich Content" icon="palette">
    Support for complex UI components and interactions
  </Card>
  <Card title="Business Logic" icon="gear">
    Embed application-specific logic and workflows
  </Card>
  <Card title="Extensible" icon="arrows-maximize">
    Easily extend functionality without SDK changes
  </Card>
</CardGroup>

## Overview

Custom messages enable you to send structured data that doesn't fit standard message types. Perfect for polls, forms, product cards, interactive widgets, and specialized business content.

### Common Use Cases
- **Polls & Surveys**: Interactive voting and feedback collection
- **Product Cards**: E-commerce product information with actions
- **Forms**: Data collection with structured input fields
- **Widgets**: Interactive components like calendars, maps
- **Business Objects**: CRM records, tickets, invoices

## Quick Start

<Steps>
  <Step title="Define Data Structure">
    Create a JSON object with your custom data fields
  </Step>
  <Step title="Create Custom Message">
    Use the SDK to send the message with custom type
  </Step>
  <Step title="Handle Rendering">
    Parse and display the custom data in your UI
  </Step>
</Steps>

## Parameters

<ParamField path="channelId" type="string" required>
  The unique identifier of the channel where the message will be sent
</ParamField>

<ParamField path="subchannelId" type="string">
  The identifier for the subchannel (thread) within the main channel
</ParamField>

<ParamField path="data" type="object" required>
  Free-form JSON object containing your custom message data
</ParamField>

<ParamField path="tags" type="string[]">
  Array of tags for message categorization and filtering
</ParamField>

<ParamField path="metadata" type="object">
  Additional metadata for the message
</ParamField>

<ParamField path="mentionees" type="object[]">
  Array of users or roles to mention in the message
</ParamField>

## Implementation

### Basic Custom Message

<Tabs>
  <Tab title="iOS">
    ```swift
    import AmitySDK

    class CustomMessageManager {
        private let messageRepository = AmityMessageRepository(client: AmityUIKitManager.client)
        
        func sendCustomMessage(
            channelId: String,
            customData: [String: Any],
            completion: @escaping (Result<AmityMessage, Error>) -> Void
        ) {
            let builder = AmityMessageBuilder()
                .setChannelId(channelId)
                .setMessageType(.custom)
                .setCustomData(customData)
                .setTags(["custom"])
            
            messageRepository.createMessage(with: builder.build()) { result in
                switch result {
                case .success(let message):
                    completion(.success(message))
                case .failure(let error):
                    completion(.failure(error))
                }
            }
        }
        
        // Example: Send a poll message
        func sendPollMessage(
            channelId: String,
            question: String,
            options: [String],
            completion: @escaping (Result<AmityMessage, Error>) -> Void
        ) {
            let pollData: [String: Any] = [
                "type": "poll",
                "question": question,
                "options": options.enumerated().map { index, option in
                    ["id": index, "text": option, "votes": 0]
                },
                "totalVotes": 0,
                "createdAt": ISO8601DateFormatter().string(from: Date())
            ]
            
            sendCustomMessage(channelId: channelId, customData: pollData, completion: completion)
        }
        
        // Example: Send a product card
        func sendProductCard(
            channelId: String,
            productId: String,
            name: String,
            price: Double,
            imageUrl: String,
            completion: @escaping (Result<AmityMessage, Error>) -> Void
        ) {
            let productData: [String: Any] = [
                "type": "product",
                "productId": productId,
                "name": name,
                "price": price,
                "currency": "USD",
                "imageUrl": imageUrl,
                "available": true,
                "categories": ["electronics", "gadgets"]
            ]
            
            sendCustomMessage(channelId: channelId, customData: productData, completion: completion)
        }
    }

    // Usage examples
    let customManager = CustomMessageManager()

    // Send a poll
    customManager.sendPollMessage(
        channelId: "general-chat",
        question: "What's your favorite programming language?",
        options: ["Swift", "Kotlin", "JavaScript", "Python"]
    ) { result in
        switch result {
        case .success(let message):
            print("Poll sent: \(message.messageId)")
        case .failure(let error):
            print("Error: \(error.localizedDescription)")
        }
    }
    ```
  </Tab>

  <Tab title="Android">
    ```kotlin
    import com.amity.socialcloud.sdk.AmityCoreClient
    import com.amity.socialcloud.sdk.chat.message.AmityMessageRepository
    import io.reactivex.android.schedulers.AndroidSchedulers
    import io.reactivex.schedulers.Schedulers

    class CustomMessageManager {
        private val messageRepository = AmityCoreClient.newMessageRepository()
        
        fun sendCustomMessage(
            channelId: String,
            customData: Map<String, Any>,
            onSuccess: (String) -> Unit,
            onError: (Throwable) -> Unit
        ) {
            messageRepository.createMessage(channelId)
                .custom(customData)
                .tags(listOf("custom"))
                .build()
                .send()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                    { message -> onSuccess(message.getMessageId()) },
                    { error -> onError(error) }
                )
        }
        
        // Example: Send a poll message
        fun sendPollMessage(
            channelId: String,
            question: String,
            options: List<String>,
            onSuccess: (String) -> Unit,
            onError: (Throwable) -> Unit
        ) {
            val pollData = mapOf(
                "type" to "poll",
                "question" to question,
                "options" to options.mapIndexed { index, option ->
                    mapOf(
                        "id" to index,
                        "text" to option,
                        "votes" to 0
                    )
                },
                "totalVotes" to 0,
                "createdAt" to System.currentTimeMillis()
            )
            
            sendCustomMessage(channelId, pollData, onSuccess, onError)
        }
        
        // Example: Send a location message
        fun sendLocationMessage(
            channelId: String,
            latitude: Double,
            longitude: Double,
            address: String,
            onSuccess: (String) -> Unit,
            onError: (Throwable) -> Unit
        ) {
            val locationData = mapOf(
                "type" to "location",
                "coordinates" to mapOf(
                    "latitude" to latitude,
                    "longitude" to longitude
                ),
                "address" to address,
                "timestamp" to System.currentTimeMillis()
            )
            
            sendCustomMessage(channelId, locationData, onSuccess, onError)
        }
    }

    // Usage examples
    val customManager = CustomMessageManager()

    // Send a poll
    customManager.sendPollMessage(
        channelId = "general-chat",
        question = "What's your favorite programming language?",
        options = listOf("Swift", "Kotlin", "JavaScript", "Python"),
        onSuccess = { messageId ->
            println("Poll sent: $messageId")
        },
        onError = { error ->
            println("Error: ${error.message}")
        }
    )
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    import { MessageRepository, MessageType } from '@amityco/js-sdk';

    class CustomMessageManager {
        async sendCustomMessage(channelId, customData, options = {}) {
            try {
                const { tags = [], subChannelId, mentionees, metadata } = options;
                
                const messageData = {
                    channelId,
                    type: MessageType.Custom,
                    data: customData,
                    tags: [...tags, 'custom'],
                    ...(subChannelId && { subChannelId }),
                    ...(mentionees && { mentionees }),
                    ...(metadata && { metadata })
                };
                
                const liveMessage = MessageRepository.createMessage(messageData);
                
                return new Promise((resolve, reject) => {
                    liveMessage.on('dataUpdated', (message) => {
                        if (message.messageId) {
                            resolve(message);
                        }
                    });
                    
                    liveMessage.on('dataError', (error) => {
                        reject(error);
                    });
                });
            } catch (error) {
                throw new Error(`Failed to send custom message: ${error.message}`);
            }
        }
        
        // Example: Send a poll message
        async sendPollMessage(channelId, question, options) {
            const pollData = {
                type: 'poll',
                question,
                options: options.map((option, index) => ({
                    id: index,
                    text: option,
                    votes: 0,
                    voters: []
                })),
                totalVotes: 0,
                createdAt: new Date().toISOString(),
                allowMultipleVotes: false,
                anonymous: false
            };
            
            return this.sendCustomMessage(channelId, pollData, {
                tags: ['poll', 'interactive']
            });
        }
        
        // Example: Send a form message
        async sendFormMessage(channelId, formConfig) {
            const formData = {
                type: 'form',
                title: formConfig.title,
                description: formConfig.description,
                fields: formConfig.fields.map((field, index) => ({
                    id: index,
                    type: field.type, // text, number, select, checkbox
                    label: field.label,
                    required: field.required || false,
                    options: field.options || null,
                    value: null
                })),
                responses: [],
                createdAt: new Date().toISOString(),
                expiresAt: formConfig.expiresAt || null
            };
            
            return this.sendCustomMessage(channelId, formData, {
                tags: ['form', 'interactive']
            });
        }
        
        // Example: Send a product card
        async sendProductCard(channelId, product) {
            const productData = {
                type: 'product',
                productId: product.id,
                name: product.name,
                description: product.description,
                price: product.price,
                currency: product.currency || 'USD',
                imageUrl: product.imageUrl,
                available: product.available !== false,
                categories: product.categories || [],
                rating: product.rating || null,
                reviews: product.reviews || 0,
                seller: product.seller || null,
                actions: [
                    { type: 'view', label: 'View Details' },
                    { type: 'buy', label: 'Buy Now' },
                    { type: 'cart', label: 'Add to Cart' }
                ]
            };
            
            return this.sendCustomMessage(channelId, productData, {
                tags: ['product', 'ecommerce']
            });
        }
    }

    // Usage examples
    const customManager = new CustomMessageManager();

    // Send a poll
    const pollMessage = await customManager.sendPollMessage(
        'general-chat',
        'What\'s your favorite programming language?',
        ['Swift', 'Kotlin', 'JavaScript', 'Python']
    );

    // Send a form
    const formMessage = await customManager.sendFormMessage('feedback-channel', {
        title: 'Customer Feedback',
        description: 'Please share your thoughts about our service',
        fields: [
            { type: 'text', label: 'Name', required: true },
            { type: 'number', label: 'Rating (1-5)', required: true },
            { type: 'text', label: 'Comments' }
        ],
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString() // 7 days
    });
    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    import { MessageRepository, MessageType, AmityMessage } from '@amityco/ts-sdk';

    interface CustomMessageOptions {
        tags?: string[];
        subChannelId?: string;
        mentionees?: any[];
        metadata?: Record<string, any>;
    }

    interface PollOption {
        id: number;
        text: string;
        votes: number;
        voters: string[];
    }

    interface PollData {
        type: 'poll';
        question: string;
        options: PollOption[];
        totalVotes: number;
        createdAt: string;
        allowMultipleVotes: boolean;
        anonymous: boolean;
        expiresAt?: string;
    }

    interface FormField {
        id: number;
        type: 'text' | 'number' | 'select' | 'checkbox' | 'email' | 'date';
        label: string;
        required: boolean;
        options?: string[] | null;
        value: any;
        validation?: {
            min?: number;
            max?: number;
            pattern?: string;
        };
    }

    interface FormData {
        type: 'form';
        title: string;
        description: string;
        fields: FormField[];
        responses: Record<string, any>[];
        createdAt: string;
        expiresAt?: string;
    }

    interface ProductData {
        type: 'product';
        productId: string;
        name: string;
        description: string;
        price: number;
        currency: string;
        imageUrl: string;
        available: boolean;
        categories: string[];
        rating?: number;
        reviews: number;
        seller?: string;
        actions: Array<{
            type: string;
            label: string;
            url?: string;
        }>;
    }

    type CustomMessageData = PollData | FormData | ProductData | Record<string, any>;

    class CustomMessageManager {
        async sendCustomMessage(
            channelId: string,
            customData: CustomMessageData,
            options: CustomMessageOptions = {}
        ): Promise<AmityMessage> {
            try {
                const { tags = [], subChannelId, mentionees, metadata } = options;
                
                const messageData = {
                    channelId,
                    type: MessageType.Custom,
                    data: customData,
                    tags: [...tags, 'custom'],
                    ...(subChannelId && { subChannelId }),
                    ...(mentionees && { mentionees }),
                    ...(metadata && { metadata })
                };
                
                const liveMessage = MessageRepository.createMessage(messageData);
                
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Message creation timeout'));
                    }, 30000);

                    liveMessage.on('dataUpdated', (message: AmityMessage) => {
                        if (message.messageId) {
                            clearTimeout(timeout);
                            resolve(message);
                        }
                    });
                    
                    liveMessage.on('dataError', (error: Error) => {
                        clearTimeout(timeout);
                        reject(error);
                    });
                });
            } catch (error) {
                throw new Error(`Failed to send custom message: ${error.message}`);
            }
        }
        
        async sendPollMessage(
            channelId: string,
            question: string,
            options: string[],
            config: {
                allowMultipleVotes?: boolean;
                anonymous?: boolean;
                expiresAt?: string;
            } = {}
        ): Promise<AmityMessage> {
            const pollData: PollData = {
                type: 'poll',
                question,
                options: options.map((option, index) => ({
                    id: index,
                    text: option,
                    votes: 0,
                    voters: []
                })),
                totalVotes: 0,
                createdAt: new Date().toISOString(),
                allowMultipleVotes: config.allowMultipleVotes || false,
                anonymous: config.anonymous || false,
                ...(config.expiresAt && { expiresAt: config.expiresAt })
            };
            
            return this.sendCustomMessage(channelId, pollData, {
                tags: ['poll', 'interactive']
            });
        }
        
        async sendFormMessage(
            channelId: string,
            formConfig: {
                title: string;
                description: string;
                fields: Omit<FormField, 'id' | 'value'>[];
                expiresAt?: string;
            }
        ): Promise<AmityMessage> {
            const formData: FormData = {
                type: 'form',
                title: formConfig.title,
                description: formConfig.description,
                fields: formConfig.fields.map((field, index) => ({
                    id: index,
                    ...field,
                    value: null
                })),
                responses: [],
                createdAt: new Date().toISOString(),
                ...(formConfig.expiresAt && { expiresAt: formConfig.expiresAt })
            };
            
            return this.sendCustomMessage(channelId, formData, {
                tags: ['form', 'interactive']
            });
        }
        
        async sendProductCard(
            channelId: string,
            product: {
                id: string;
                name: string;
                description: string;
                price: number;
                currency?: string;
                imageUrl: string;
                available?: boolean;
                categories?: string[];
                rating?: number;
                reviews?: number;
                seller?: string;
            }
        ): Promise<AmityMessage> {
            const productData: ProductData = {
                type: 'product',
                productId: product.id,
                name: product.name,
                description: product.description,
                price: product.price,
                currency: product.currency || 'USD',
                imageUrl: product.imageUrl,
                available: product.available !== false,
                categories: product.categories || [],
                rating: product.rating,
                reviews: product.reviews || 0,
                seller: product.seller,
                actions: [
                    { type: 'view', label: 'View Details' },
                    { type: 'buy', label: 'Buy Now' },
                    { type: 'cart', label: 'Add to Cart' }
                ]
            };
            
            return this.sendCustomMessage(channelId, productData, {
                tags: ['product', 'ecommerce']
            });
        }
    }

    // Usage examples with proper typing
    const customManager = new CustomMessageManager();

    // Send a poll with configuration
    const pollMessage = await customManager.sendPollMessage(
        'general-chat',
        'What\'s your favorite programming language?',
        ['Swift', 'Kotlin', 'JavaScript', 'Python'],
        {
            allowMultipleVotes: true,
            anonymous: false,
            expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString() // 24 hours
        }
    );

    // Send a form with validation
    const formMessage = await customManager.sendFormMessage('feedback-channel', {
        title: 'Customer Feedback',
        description: 'Please share your thoughts about our service',
        fields: [
            { 
                type: 'text', 
                label: 'Name', 
                required: true,
                validation: { min: 2, max: 50 }
            },
            { 
                type: 'number', 
                label: 'Rating (1-5)', 
                required: true,
                validation: { min: 1, max: 5 }
            },
            { type: 'email', label: 'Email', required: false },
            { type: 'text', label: 'Comments', required: false }
        ],
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()
    });
    ```
  </Tab>

  <Tab title="Flutter">
    ```dart
    import 'package:amity_sdk/amity_sdk.dart';

    class CustomMessageManager {
      Future<AmityMessage> sendCustomMessage({
        required String channelId,
        required Map<String, dynamic> customData,
        List<String>? tags,
        String? subChannelId,
        Map<String, dynamic>? metadata,
      }) async {
        try {
          final AmityMessageRepository messageRepository = AmityMessageRepository();
          
          final AmityMessageBuilder builder = AmityMessageBuilder()
            ..channelId(channelId)
            ..type(AmityMessageType.custom)
            ..data(customData)
            ..tags(tags ?? ['custom']);

          if (subChannelId != null) {
            builder.subChannelId(subChannelId);
          }

          if (metadata != null) {
            builder.metadata(metadata);
          }

          return await messageRepository.createMessage(builder.build());
        } catch (error) {
          throw Exception('Failed to send custom message: $error');
        }
      }
      
      // Example: Send a poll message
      Future<AmityMessage> sendPollMessage({
        required String channelId,
        required String question,
        required List<String> options,
        bool allowMultipleVotes = false,
        bool anonymous = false,
        DateTime? expiresAt,
      }) async {
        final pollData = {
          'type': 'poll',
          'question': question,
          'options': options.asMap().entries.map((entry) => {
            'id': entry.key,
            'text': entry.value,
            'votes': 0,
            'voters': <String>[],
          }).toList(),
          'totalVotes': 0,
          'createdAt': DateTime.now().toIso8601String(),
          'allowMultipleVotes': allowMultipleVotes,
          'anonymous': anonymous,
          if (expiresAt != null) 'expiresAt': expiresAt.toIso8601String(),
        };
        
        return sendCustomMessage(
          channelId: channelId,
          customData: pollData,
          tags: ['poll', 'interactive'],
        );
      }
      
      // Example: Send a location message
      Future<AmityMessage> sendLocationMessage({
        required String channelId,
        required double latitude,
        required double longitude,
        String? address,
        String? name,
      }) async {
        final locationData = {
          'type': 'location',
          'coordinates': {
            'latitude': latitude,
            'longitude': longitude,
          },
          'address': address,
          'name': name,
          'timestamp': DateTime.now().toIso8601String(),
        };
        
        return sendCustomMessage(
          channelId: channelId,
          customData: locationData,
          tags: ['location'],
        );
      }
      
      // Example: Send a calendar event
      Future<AmityMessage> sendCalendarEvent({
        required String channelId,
        required String title,
        required DateTime startTime,
        required DateTime endTime,
        String? description,
        String? location,
        List<String>? attendees,
      }) async {
        final eventData = {
          'type': 'calendar_event',
          'title': title,
          'description': description,
          'startTime': startTime.toIso8601String(),
          'endTime': endTime.toIso8601String(),
          'location': location,
          'attendees': attendees ?? [],
          'createdAt': DateTime.now().toIso8601String(),
          'status': 'pending',
        };
        
        return sendCustomMessage(
          channelId: channelId,
          customData: eventData,
          tags: ['calendar', 'event'],
        );
      }
    }

    // Usage examples
    class CustomMessageExample extends StatefulWidget {
      @override
      _CustomMessageExampleState createState() => _CustomMessageExampleState();
    }

    class _CustomMessageExampleState extends State<CustomMessageExample> {
      final CustomMessageManager _customManager = CustomMessageManager();

      Future<void> _sendPoll() async {
        try {
          final message = await _customManager.sendPollMessage(
            channelId: 'general-chat',
            question: 'What\'s your favorite programming language?',
            options: ['Swift', 'Kotlin', 'JavaScript', 'Python'],
            allowMultipleVotes: true,
            anonymous: false,
            expiresAt: DateTime.now().add(Duration(hours: 24)),
          );

          print('Poll sent: ${message.messageId}');
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Poll sent successfully!')),
          );
        } catch (error) {
          print('Error sending poll: $error');
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Failed to send poll: $error')),
          );
        }
      }

      Future<void> _sendCalendarEvent() async {
        try {
          final message = await _customManager.sendCalendarEvent(
            channelId: 'team-events',
            title: 'Team Standup',
            startTime: DateTime.now().add(Duration(days: 1)),
            endTime: DateTime.now().add(Duration(days: 1, minutes: 30)),
            description: 'Daily team standup meeting',
            location: 'Conference Room A',
            attendees: ['alice', 'bob', 'charlie'],
          );

          print('Calendar event sent: ${message.messageId}');
        } catch (error) {
          print('Error sending calendar event: $error');
        }
      }

      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(title: Text('Custom Message Example')),
          body: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              ElevatedButton(
                onPressed: _sendPoll,
                child: Text('Send Poll'),
              ),
              SizedBox(height: 16),
              ElevatedButton(
                onPressed: _sendCalendarEvent,
                child: Text('Send Calendar Event'),
              ),
            ],
          ),
        );
      }
    }
    ```
  </Tab>
</Tabs>

## Data Structure Examples

### Poll Message Structure

```json
{
  "type": "poll",
  "question": "What's your favorite programming language?",
  "options": [
    {
      "id": 0,
      "text": "Swift",
      "votes": 12,
      "voters": ["user1", "user3", "user7"]
    },
    {
      "id": 1,
      "text": "Kotlin", 
      "votes": 8,
      "voters": ["user2", "user5"]
    }
  ],
  "totalVotes": 20,
  "createdAt": "2024-01-15T10:30:00Z",
  "allowMultipleVotes": false,
  "anonymous": false,
  "expiresAt": "2024-01-16T10:30:00Z"
}
```

### Product Card Structure

```json
{
  "type": "product",
  "productId": "prod_123456",
  "name": "Wireless Earbuds Pro",
  "description": "Premium wireless earbuds with noise cancellation",
  "price": 199.99,
  "currency": "USD",
  "imageUrl": "https://example.com/products/earbuds.jpg",
  "available": true,
  "categories": ["electronics", "audio"],
  "rating": 4.5,
  "reviews": 1247,
  "seller": "TechStore Inc",
  "actions": [
    { "type": "view", "label": "View Details", "url": "/products/prod_123456" },
    { "type": "buy", "label": "Buy Now" },
    { "type": "cart", "label": "Add to Cart" }
  ]
}
```

### Form Message Structure

```json
{
  "type": "form",
  "title": "Customer Feedback",
  "description": "Help us improve our service",
  "fields": [
    {
      "id": 0,
      "type": "text",
      "label": "Full Name",
      "required": true,
      "value": null,
      "validation": { "min": 2, "max": 50 }
    },
    {
      "id": 1,
      "type": "select",
      "label": "Department",
      "required": true,
      "options": ["Sales", "Support", "Engineering"],
      "value": null
    },
    {
      "id": 2,
      "type": "number",
      "label": "Rating (1-5)",
      "required": true,
      "value": null,
      "validation": { "min": 1, "max": 5 }
    }
  ],
  "responses": [
    {
      "userId": "user123",
      "submittedAt": "2024-01-15T14:30:00Z",
      "answers": {
        "0": "John Doe",
        "1": "Engineering",
        "2": 4
      }
    }
  ],
  "createdAt": "2024-01-15T10:00:00Z",
  "expiresAt": "2024-01-22T10:00:00Z"
}
```

## Error Handling

<AccordionGroup>
  <Accordion title="Data Validation">
    ```javascript
    class CustomMessageValidator {
        static validatePollData(data) {
            const errors = [];
            
            if (!data.question || typeof data.question !== 'string') {
                errors.push('Poll question is required and must be a string');
            }
            
            if (!data.options || !Array.isArray(data.options) || data.options.length < 2) {
                errors.push('Poll must have at least 2 options');
            }
            
            if (data.options && data.options.length > 10) {
                errors.push('Poll cannot have more than 10 options');
            }
            
            data.options?.forEach((option, index) => {
                if (!option.text || typeof option.text !== 'string') {
                    errors.push(`Option ${index + 1} text is required`);
                }
            });
            
            return errors;
        }
        
        static validateProductData(data) {
            const errors = [];
            
            if (!data.productId) errors.push('Product ID is required');
            if (!data.name) errors.push('Product name is required');
            if (typeof data.price !== 'number' || data.price < 0) {
                errors.push('Product price must be a positive number');
            }
            if (!data.imageUrl) errors.push('Product image URL is required');
            
            return errors;
        }
        
        static validateFormData(data) {
            const errors = [];
            
            if (!data.title) errors.push('Form title is required');
            if (!data.fields || !Array.isArray(data.fields)) {
                errors.push('Form fields are required');
            }
            
            data.fields?.forEach((field, index) => {
                if (!field.label) errors.push(`Field ${index + 1} label is required`);
                if (!['text', 'number', 'select', 'checkbox', 'email', 'date'].includes(field.type)) {
                    errors.push(`Field ${index + 1} has invalid type: ${field.type}`);
                }
            });
            
            return errors;
        }
    }

    // Usage in message sending
    async function sendValidatedCustomMessage(channelId, messageData) {
        let errors = [];
        
        switch (messageData.type) {
            case 'poll':
                errors = CustomMessageValidator.validatePollData(messageData);
                break;
            case 'product':
                errors = CustomMessageValidator.validateProductData(messageData);
                break;
            case 'form':
                errors = CustomMessageValidator.validateFormData(messageData);
                break;
        }
        
        if (errors.length > 0) {
            throw new Error(`Validation failed: ${errors.join(', ')}`);
        }
        
        return customManager.sendCustomMessage(channelId, messageData);
    }
    ```
  </Accordion>

  <Accordion title="Message Size Limits">
    ```javascript
    class MessageSizeValidator {
        static MAX_MESSAGE_SIZE = 64 * 1024; // 64KB
        static MAX_FIELD_COUNT = 20;
        static MAX_OPTIONS_COUNT = 50;
        
        static validateMessageSize(data) {
            const jsonString = JSON.stringify(data);
            const sizeInBytes = new Blob([jsonString]).size;
            
            if (sizeInBytes > this.MAX_MESSAGE_SIZE) {
                throw new Error(
                    `Message size (${this.formatBytes(sizeInBytes)}) exceeds limit (${this.formatBytes(this.MAX_MESSAGE_SIZE)})`
                );
            }
            
            return true;
        }
        
        static validateComplexity(data) {
            if (data.type === 'form' && data.fields?.length > this.MAX_FIELD_COUNT) {
                throw new Error(`Form cannot have more than ${this.MAX_FIELD_COUNT} fields`);
            }
            
            if (data.type === 'poll' && data.options?.length > this.MAX_OPTIONS_COUNT) {
                throw new Error(`Poll cannot have more than ${this.MAX_OPTIONS_COUNT} options`);
            }
            
            return true;
        }
        
        static formatBytes(bytes) {
            const sizes = ['Bytes', 'KB', 'MB'];
            if (bytes === 0) return '0 Bytes';
            const i = Math.floor(Math.log(bytes) / Math.log(1024));
            return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
        }
    }
    ```
  </Accordion>

  <Accordion title="Custom Message Parsing">
    ```javascript
    class CustomMessageParser {
        static parseCustomMessage(message) {
            try {
                if (!message.data || typeof message.data !== 'object') {
                    throw new Error('Invalid custom message data');
                }
                
                const { type } = message.data;
                
                switch (type) {
                    case 'poll':
                        return this.parsePollMessage(message.data);
                    case 'product':
                        return this.parseProductMessage(message.data);
                    case 'form':
                        return this.parseFormMessage(message.data);
                    default:
                        return this.parseGenericMessage(message.data);
                }
            } catch (error) {
                console.error('Failed to parse custom message:', error);
                return { type: 'unknown', error: error.message };
            }
        }
        
        static parsePollMessage(data) {
            return {
                type: 'poll',
                question: data.question || '',
                options: data.options || [],
                totalVotes: data.totalVotes || 0,
                isExpired: data.expiresAt ? new Date(data.expiresAt) < new Date() : false,
                allowMultipleVotes: data.allowMultipleVotes || false,
                anonymous: data.anonymous || false
            };
        }
        
        static parseProductMessage(data) {
            return {
                type: 'product',
                productId: data.productId,
                name: data.name,
                price: data.price,
                currency: data.currency || 'USD',
                available: data.available !== false,
                rating: data.rating,
                imageUrl: data.imageUrl,
                actions: data.actions || []
            };
        }
        
        static parseFormMessage(data) {
            return {
                type: 'form',
                title: data.title,
                description: data.description,
                fields: data.fields || [],
                responseCount: data.responses?.length || 0,
                isExpired: data.expiresAt ? new Date(data.expiresAt) < new Date() : false
            };
        }
        
        static parseGenericMessage(data) {
            return {
                type: data.type || 'custom',
                data: data
            };
        }
    }
    ```
  </Accordion>
</AccordionGroup>

## Best Practices

<CardGroup cols={2}>
  <Card title="Data Structure" icon="sitemap">
    Design clear, consistent JSON schemas for your custom types
  </Card>
  <Card title="Validation" icon="shield-check">
    Always validate custom data before sending messages
  </Card>
  <Card title="Versioning" icon="code-branch">
    Include version fields for schema evolution
  </Card>
  <Card title="Performance" icon="gauge-high">
    Keep message size reasonable and avoid deep nesting
  </Card>
</CardGroup>

### Design Guidelines

1. **Consistent Schema**: Define clear data structures for each custom type
2. **Version Control**: Include version fields to handle schema changes
3. **Size Optimization**: Keep data compact and avoid unnecessary fields
4. **Error Handling**: Implement robust parsing and validation
5. **Backward Compatibility**: Design schemas to support future changes

### Security Considerations

1. **Input Validation**: Sanitize all custom data fields
2. **XSS Prevention**: Escape HTML content in custom messages
3. **Size Limits**: Enforce reasonable limits on data size
4. **Content Filtering**: Apply content moderation to custom messages

### Performance Tips

1. **Lazy Loading**: Load complex custom message content on demand
2. **Caching**: Cache parsed custom message data
3. **Compression**: Use efficient JSON structures
4. **Batch Processing**: Process multiple custom messages efficiently

## UI Rendering Examples

### Poll Message UI

```javascript
function PollMessageComponent({ message }) {
    const pollData = CustomMessageParser.parsePollMessage(message.data);
    const [selectedOptions, setSelectedOptions] = useState([]);
    
    const handleVote = async (optionId) => {
        try {
            if (pollData.allowMultipleVotes) {
                setSelectedOptions(prev => 
                    prev.includes(optionId) 
                        ? prev.filter(id => id !== optionId)
                        : [...prev, optionId]
                );
            } else {
                setSelectedOptions([optionId]);
            }
            
            // Submit vote to your backend
            await submitPollVote(message.messageId, selectedOptions);
        } catch (error) {
            console.error('Failed to submit vote:', error);
        }
    };
    
    return (
        <div className="poll-message">
            <h3>{pollData.question}</h3>
            <div className="poll-options">
                {pollData.options.map(option => (
                    <div key={option.id} className="poll-option">
                        <button 
                            onClick={() => handleVote(option.id)}
                            className={selectedOptions.includes(option.id) ? 'selected' : ''}
                            disabled={pollData.isExpired}
                        >
                            {option.text}
                        </button>
                        <div className="vote-count">{option.votes} votes</div>
                        <div className="vote-percentage">
                            {pollData.totalVotes > 0 ? 
                                Math.round((option.votes / pollData.totalVotes) * 100) : 0}%
                        </div>
                    </div>
                ))}
            </div>
            <div className="poll-info">
                Total votes: {pollData.totalVotes}
                {pollData.isExpired && <span className="expired">Expired</span>}
            </div>
        </div>
    );
}
```

### Product Card UI

```javascript
function ProductCardComponent({ message }) {
    const productData = CustomMessageParser.parseProductMessage(message.data);
    
    const handleAction = (action) => {
        switch (action.type) {
            case 'view':
                window.open(action.url, '_blank');
                break;
            case 'buy':
                // Handle purchase flow
                break;
            case 'cart':
                // Add to cart
                break;
        }
    };
    
    return (
        <div className="product-card">
            <img src={productData.imageUrl} alt={productData.name} />
            <div className="product-info">
                <h3>{productData.name}</h3>
                <p className="price">
                    {productData.currency} {productData.price}
                </p>
                {productData.rating && (
                    <div className="rating">
                        ‚≠ê {productData.rating}
                    </div>
                )}
                <div className="availability">
                    {productData.available ? 'In Stock' : 'Out of Stock'}
                </div>
            </div>
            <div className="product-actions">
                {productData.actions.map((action, index) => (
                    <button 
                        key={index}
                        onClick={() => handleAction(action)}
                        disabled={!productData.available && action.type === 'buy'}
                    >
                        {action.label}
                    </button>
                ))}
            </div>
        </div>
    );
}
```

## Use Cases

<AccordionGroup>
  <Accordion title="Interactive Polls & Surveys">
    Perfect for gathering feedback, making team decisions, or conducting market research within your chat application.
    
    ```javascript
    // Team decision poll
    await customManager.sendPollMessage(
        'team-channel',
        'Which framework should we use for the new project?',
        ['React', 'Vue.js', 'Angular', 'Svelte']
    );
    
    // Customer satisfaction survey
    await customManager.sendCustomMessage('support-channel', {
        type: 'survey',
        title: 'How was your support experience?',
        questions: [
            { type: 'rating', question: 'Rate our response time', scale: 5 },
            { type: 'rating', question: 'Rate solution quality', scale: 5 },
            { type: 'text', question: 'Additional comments' }
        ]
    });
    ```
  </Accordion>
  
  <Accordion title="E-commerce Integration">
    Share product information, promotions, and shopping experiences directly in chat conversations.
    
    ```javascript
    // Product recommendation
    await customManager.sendProductCard('shopping-chat', {
        id: 'laptop-pro-15',
        name: 'MacBook Pro 15"',
        description: 'Professional laptop for developers',
        price: 2399.99,
        imageUrl: 'https://example.com/macbook.jpg',
        categories: ['computers', 'apple']
    });
    
    // Flash sale notification
    await customManager.sendCustomMessage('deals-channel', {
        type: 'flash_sale',
        title: '24-Hour Flash Sale!',
        discount: 30,
        products: ['laptop-pro-15', 'monitor-4k', 'keyboard-mx'],
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
    });
    ```
  </Accordion>

  <Accordion title="Event & Calendar Integration">
    Schedule meetings, share events, and coordinate activities through custom messages.
    
    ```javascript
    // Meeting invitation
    await customManager.sendCustomMessage('team-channel', {
        type: 'meeting_invite',
        title: 'Sprint Planning',
        startTime: '2024-01-20T10:00:00Z',
        endTime: '2024-01-20T12:00:00Z',
        location: 'Conference Room A',
        agenda: ['Sprint review', 'Story estimation', 'Sprint goals'],
        attendees: ['alice', 'bob', 'charlie'],
        meetingUrl: 'https://zoom.us/j/123456789'
    });
    
    // Event reminder
    await customManager.sendCustomMessage('events-channel', {
        type: 'event_reminder',
        title: 'Company All-Hands',
        startTime: '2024-01-25T15:00:00Z',
        location: 'Main Auditorium',
        reminder: '1 hour before',
        rsvpRequired: true
    });
    ```
  </Accordion>

  <Accordion title="Form & Data Collection">
    Collect structured information, feedback, and user data through interactive forms.
    
    ```javascript
    // Onboarding form
    await customManager.sendFormMessage('new-users', {
        title: 'Welcome! Tell us about yourself',
        description: 'Help us personalize your experience',
        fields: [
            { type: 'text', label: 'Preferred Name', required: true },
            { type: 'select', label: 'Department', options: ['Engineering', 'Sales', 'Marketing'] },
            { type: 'checkbox', label: 'Interests', options: ['Coding', 'Design', 'Analytics'] }
        ]
    });
    
    // Incident report form
    await customManager.sendFormMessage('support-team', {
        title: 'Incident Report',
        description: 'Report system issues or bugs',
        fields: [
            { type: 'select', label: 'Severity', options: ['Low', 'Medium', 'High', 'Critical'] },
            { type: 'text', label: 'Affected System', required: true },
            { type: 'text', label: 'Description', required: true },
            { type: 'text', label: 'Steps to Reproduce' }
        ]
    });
    ```
  </Accordion>
</AccordionGroup>

<Note>
Custom messages provide unlimited flexibility for your chat application. Always validate and sanitize custom data, implement proper error handling, and consider the user experience when designing custom message types.
</Note>