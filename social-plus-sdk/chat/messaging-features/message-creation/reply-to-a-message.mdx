---
title: "Message Replies"
description: "Create threaded conversations with message replies and contextual discussions"
---

# Message Replies

Enable threaded conversations by allowing users to reply to specific messages, creating organized discussions with clear context and improved conversation flow.

<CardGroup cols={2}>
  <Card title="Threaded Conversations" icon="comments">
    Organize discussions with clear parent-child relationships
  </Card>
  <Card title="Context Preservation" icon="link">
    Maintain conversation context with reply references
  </Card>
  <Card title="All Message Types" icon="message">
    Reply to text, media, file, and custom messages
  </Card>
  <Card title="Optimistic Updates" icon="bolt">
    Instant UI updates with optimistic message creation
  </Card>
</CardGroup>

## Overview

Message replies create threaded conversations that help users maintain context and organize discussions around specific topics. Users can reply to any message type, creating hierarchical conversation structures.

### Reply Features
- **Thread Creation**: Automatic thread creation from first reply
- **Context Display**: Show original message content in replies
- **Nested Replies**: Support for multi-level reply chains
- **Reply Indicators**: Visual indicators for messages with replies
- **Thread Navigation**: Easy navigation between parent and child messages

## Quick Start

<Steps>
  <Step title="Get Parent Message">
    Identify the message you want to reply to and get its message ID
  </Step>
  <Step title="Create Reply">
    Create a new message with the parent message ID parameter
  </Step>
  <Step title="Display Thread">
    Show the reply in context with the original message
  </Step>
</Steps>

## Parameters

<ParamField path="channelId" type="string" required>
  The unique identifier of the channel containing the parent message
</ParamField>

<ParamField path="parentId" type="string" required>
  The message ID of the parent message being replied to
</ParamField>

<ParamField path="text" type="string" required>
  The text content of the reply message
</ParamField>

<ParamField path="subchannelId" type="string">
  The identifier for the subchannel if replying within a thread
</ParamField>

<ParamField path="tags" type="string[]">
  Array of tags for message categorization and filtering
</ParamField>

<ParamField path="mentionees" type="object[]">
  Array of users to mention in the reply
</ParamField>

<ParamField path="metadata" type="object">
  Additional metadata to attach to the reply
</ParamField>

## Implementation

### Text Reply

<Tabs>
  <Tab title="iOS">
    ```swift
    import AmitySDK

    class MessageReplyManager {
        private let messageRepository = AmityMessageRepository(client: AmityUIKitManager.client)
        
        func replyToMessage(
            channelId: String,
            parentMessageId: String,
            replyText: String,
            completion: @escaping (Result<AmityMessage, Error>) -> Void
        ) {
            let builder = AmityMessageBuilder()
                .setChannelId(channelId)
                .setText(replyText)
                .setParentId(parentMessageId)
                .setTags(["reply"])
            
            messageRepository.createMessage(with: builder.build()) { result in
                switch result {
                case .success(let message):
                    completion(.success(message))
                case .failure(let error):
                    completion(.failure(error))
                }
            }
        }
        
        func replyWithMention(
            channelId: String,
            parentMessageId: String,
            replyText: String,
            mentionedUsers: [String],
            completion: @escaping (Result<AmityMessage, Error>) -> Void
        ) {
            let mentionees = mentionedUsers.map { userId in
                AmityMentionee.user(userId: userId)
            }
            
            let builder = AmityMessageBuilder()
                .setChannelId(channelId)
                .setText(replyText)
                .setParentId(parentMessageId)
                .setMentionees(mentionees)
                .setTags(["reply", "mention"])
            
            messageRepository.createMessage(with: builder.build()) { result in
                switch result {
                case .success(let message):
                    completion(.success(message))
                case .failure(let error):
                    completion(.failure(error))
                }
            }
        }
        
        func getMessageReplies(
            parentMessageId: String,
            completion: @escaping (Result<[AmityMessage], Error>) -> Void
        ) {
            let query = messageRepository.getMessages()
                .parentId(parentMessageId)
                .includeDeleted(false)
            
            query.query { result in
                switch result {
                case .success(let messages):
                    completion(.success(messages))
                case .failure(let error):
                    completion(.failure(error))
                }
            }
        }
        
        func getMessageWithReplies(
            messageId: String,
            completion: @escaping (Result<AmityMessage, Error>) -> Void
        ) {
            messageRepository.getMessage(messageId) { result in
                switch result {
                case .success(let message):
                    // Message object includes reply count and other metadata
                    completion(.success(message))
                case .failure(let error):
                    completion(.failure(error))
                }
            }
        }
    }

    // Usage examples
    let replyManager = MessageReplyManager()

    // Simple reply
    replyManager.replyToMessage(
        channelId: "general-chat",
        parentMessageId: "msg123",
        replyText: "Great point! I totally agree."
    ) { result in
        switch result {
        case .success(let reply):
            print("Reply sent: \(reply.messageId)")
        case .failure(let error):
            print("Error: \(error.localizedDescription)")
        }
    }

    // Reply with mentions
    replyManager.replyWithMention(
        channelId: "team-discussion",
        parentMessageId: "msg456",
        replyText: "@alice @bob What do you think about this approach?",
        mentionedUsers: ["alice", "bob"]
    ) { result in
        switch result {
        case .success(let reply):
            print("Reply with mentions sent: \(reply.messageId)")
        case .failure(let error):
            print("Error: \(error.localizedDescription)")
        }
    }
    ```
  </Tab>

  <Tab title="Android">
    ```kotlin
    import com.amity.socialcloud.sdk.AmityCoreClient
    import com.amity.socialcloud.sdk.chat.message.AmityMessageRepository
    import io.reactivex.android.schedulers.AndroidSchedulers
    import io.reactivex.schedulers.Schedulers

    class MessageReplyManager {
        private val messageRepository = AmityCoreClient.newMessageRepository()
        
        fun replyToMessage(
            channelId: String,
            parentMessageId: String,
            replyText: String,
            onSuccess: (String) -> Unit,
            onError: (Throwable) -> Unit
        ) {
            messageRepository.createMessage(channelId)
                .text(replyText)
                .parentId(parentMessageId)
                .tags(listOf("reply"))
                .build()
                .send()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                    { message -> onSuccess(message.getMessageId()) },
                    { error -> onError(error) }
                )
        }
        
        fun replyWithMedia(
            channelId: String,
            parentMessageId: String,
            imageFile: File,
            caption: String? = null,
            onSuccess: (String) -> Unit,
            onError: (Throwable) -> Unit
        ) {
            // First upload the image
            val fileRepository = AmityCoreClient.newFileRepository()
            
            fileRepository.uploadImage(imageFile)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .flatMap { uploadedFile ->
                    // Then create reply with image
                    messageRepository.createMessage(channelId)
                        .attachImage(uploadedFile.getFileId())
                        .text(caption ?: "")
                        .parentId(parentMessageId)
                        .tags(listOf("reply", "image"))
                        .build()
                        .send()
                }
                .subscribe(
                    { message -> onSuccess(message.getMessageId()) },
                    { error -> onError(error) }
                )
        }
        
        fun getMessageReplies(
            parentMessageId: String,
            onSuccess: (List<AmityMessage>) -> Unit,
            onError: (Throwable) -> Unit
        ) {
            messageRepository.getMessages()
                .parentId(parentMessageId)
                .includeDeleted(false)
                .build()
                .query()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                    { messages -> onSuccess(messages) },
                    { error -> onError(error) }
                )
        }
        
        fun replyWithCustomData(
            channelId: String,
            parentMessageId: String,
            customData: Map<String, Any>,
            onSuccess: (String) -> Unit,
            onError: (Throwable) -> Unit
        ) {
            messageRepository.createMessage(channelId)
                .custom(customData)
                .parentId(parentMessageId)
                .tags(listOf("reply", "custom"))
                .build()
                .send()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                    { message -> onSuccess(message.getMessageId()) },
                    { error -> onError(error) }
                )
        }
    }

    // Usage examples
    val replyManager = MessageReplyManager()

    // Simple text reply
    replyManager.replyToMessage(
        channelId = "general-chat",
        parentMessageId = "msg123",
        replyText = "Thanks for sharing this!",
        onSuccess = { messageId ->
            println("Reply sent: $messageId")
        },
        onError = { error ->
            println("Error: ${error.message}")
        }
    )

    // Reply with image
    val imageFile = File("/path/to/image.jpg")
    replyManager.replyWithMedia(
        channelId = "project-updates",
        parentMessageId = "msg456",
        imageFile = imageFile,
        caption = "Here's the updated design mockup",
        onSuccess = { messageId ->
            println("Image reply sent: $messageId")
        },
        onError = { error ->
            println("Error: ${error.message}")
        }
    )
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    import { MessageRepository } from '@amityco/js-sdk';

    class MessageReplyManager {
        async replyToMessage(channelId, parentMessageId, replyText, options = {}) {
            try {
                const { tags = [], mentionees, metadata, subChannelId } = options;
                
                const messageData = {
                    channelId,
                    text: replyText,
                    parentId: parentMessageId,
                    tags: [...tags, 'reply'],
                    ...(mentionees && { mentionees }),
                    ...(metadata && { metadata }),
                    ...(subChannelId && { subChannelId })
                };
                
                const liveMessage = MessageRepository.createTextMessage(messageData);
                
                return new Promise((resolve, reject) => {
                    liveMessage.on('dataUpdated', (message) => {
                        if (message.messageId) {
                            resolve(message);
                        }
                    });
                    
                    liveMessage.on('dataError', (error) => {
                        reject(error);
                    });
                });
            } catch (error) {
                throw new Error(`Failed to send reply: ${error.message}`);
            }
        }
        
        async replyWithImage(channelId, parentMessageId, imageFile, caption = '') {
            try {
                // First upload the image
                const uploadedFile = await this.uploadImage(imageFile);
                
                // Then create reply with image
                const messageData = {
                    channelId,
                    fileId: uploadedFile.fileId,
                    text: caption,
                    parentId: parentMessageId,
                    tags: ['reply', 'image']
                };
                
                const liveMessage = MessageRepository.createImageMessage(messageData);
                
                return new Promise((resolve, reject) => {
                    liveMessage.on('dataUpdated', (message) => {
                        if (message.messageId) {
                            resolve(message);
                        }
                    });
                    
                    liveMessage.on('dataError', (error) => {
                        reject(error);
                    });
                });
            } catch (error) {
                throw new Error(`Failed to send image reply: ${error.message}`);
            }
        }
        
        async uploadImage(imageFile) {
            const { FileRepository } = await import('@amityco/js-sdk');
            const liveFile = FileRepository.createFile({ file: imageFile });
            
            return new Promise((resolve, reject) => {
                liveFile.on('dataUpdated', (file) => {
                    if (file.fileId) {
                        resolve(file);
                    }
                });
                
                liveFile.on('dataError', (error) => {
                    reject(error);
                });
            });
        }
        
        async getMessageReplies(parentMessageId) {
            try {
                const liveCollection = MessageRepository.getMessages({
                    parentId: parentMessageId,
                    includeDeleted: false
                });
                
                return new Promise((resolve, reject) => {
                    liveCollection.on('dataUpdated', (messages) => {
                        resolve(messages);
                    });
                    
                    liveCollection.on('dataError', (error) => {
                        reject(error);
                    });
                });
            } catch (error) {
                throw new Error(`Failed to get replies: ${error.message}`);
            }
        }
        
        async replyWithMentions(channelId, parentMessageId, text, userIds) {
            const mentionees = userIds.map(userId => ({
                type: 'user',
                userIds: [userId]
            }));
            
            return this.replyToMessage(channelId, parentMessageId, text, {
                mentionees,
                tags: ['reply', 'mention']
            });
        }
    }

    // Usage examples
    const replyManager = new MessageReplyManager();

    // Simple text reply
    const textReply = await replyManager.replyToMessage(
        'general-chat',
        'msg123',
        'Great point! I completely agree with your analysis.'
    );

    // Reply with mentions
    const mentionReply = await replyManager.replyWithMentions(
        'team-discussion',
        'msg456',
        '@alice @bob What are your thoughts on this approach?',
        ['alice', 'bob']
    );

    // Image reply
    const fileInput = document.getElementById('imageInput');
    if (fileInput.files[0]) {
        const imageReply = await replyManager.replyWithImage(
            'design-feedback',
            'msg789',
            fileInput.files[0],
            'Here\'s the updated mockup based on your feedback'
        );
    }

    // Get all replies to a message
    const replies = await replyManager.getMessageReplies('msg123');
    console.log(`Found ${replies.length} replies`);
    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    import { 
        MessageRepository, 
        FileRepository,
        AmityMessage, 
        AmityFile 
    } from '@amityco/ts-sdk';

    interface ReplyOptions {
        tags?: string[];
        mentionees?: any[];
        metadata?: Record<string, any>;
        subChannelId?: string;
    }

    interface MessageThread {
        parentMessage: AmityMessage;
        replies: AmityMessage[];
        totalReplies: number;
    }

    class MessageReplyManager {
        async replyToMessage(
            channelId: string,
            parentMessageId: string,
            replyText: string,
            options: ReplyOptions = {}
        ): Promise<AmityMessage> {
            try {
                const { tags = [], mentionees, metadata, subChannelId } = options;
                
                const messageData = {
                    channelId,
                    text: replyText,
                    parentId: parentMessageId,
                    tags: [...tags, 'reply'],
                    ...(mentionees && { mentionees }),
                    ...(metadata && { metadata }),
                    ...(subChannelId && { subChannelId })
                };
                
                const liveMessage = MessageRepository.createTextMessage(messageData);
                
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Reply timeout'));
                    }, 30000);

                    liveMessage.on('dataUpdated', (message: AmityMessage) => {
                        if (message.messageId) {
                            clearTimeout(timeout);
                            resolve(message);
                        }
                    });
                    
                    liveMessage.on('dataError', (error: Error) => {
                        clearTimeout(timeout);
                        reject(error);
                    });
                });
            } catch (error) {
                throw new Error(`Failed to send reply: ${error.message}`);
            }
        }
        
        async replyWithFile(
            channelId: string,
            parentMessageId: string,
            file: File,
            caption?: string
        ): Promise<AmityMessage> {
            try {
                // Upload file first
                const uploadedFile = await this.uploadFile(file);
                
                // Determine message type based on file type
                let messageData: any = {
                    channelId,
                    fileId: uploadedFile.fileId,
                    text: caption || '',
                    parentId: parentMessageId,
                    tags: ['reply', this.getFileTypeTag(file.type)]
                };
                
                let liveMessage;
                if (file.type.startsWith('image/')) {
                    liveMessage = MessageRepository.createImageMessage(messageData);
                } else if (file.type.startsWith('video/')) {
                    liveMessage = MessageRepository.createVideoMessage(messageData);
                } else if (file.type.startsWith('audio/')) {
                    liveMessage = MessageRepository.createAudioMessage(messageData);
                } else {
                    liveMessage = MessageRepository.createFileMessage(messageData);
                }
                
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('File reply timeout'));
                    }, 60000); // Longer timeout for file uploads

                    liveMessage.on('dataUpdated', (message: AmityMessage) => {
                        if (message.messageId) {
                            clearTimeout(timeout);
                            resolve(message);
                        }
                    });
                    
                    liveMessage.on('dataError', (error: Error) => {
                        clearTimeout(timeout);
                        reject(error);
                    });
                });
            } catch (error) {
                throw new Error(`Failed to send file reply: ${error.message}`);
            }
        }
        
        private async uploadFile(file: File): Promise<AmityFile> {
            const liveFile = FileRepository.createFile({ file });
            
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('File upload timeout'));
                }, 300000); // 5 minutes

                liveFile.on('dataUpdated', (uploadedFile: AmityFile) => {
                    if (uploadedFile.fileId) {
                        clearTimeout(timeout);
                        resolve(uploadedFile);
                    }
                });
                
                liveFile.on('dataError', (error: Error) => {
                    clearTimeout(timeout);
                    reject(error);
                });
            });
        }
        
        private getFileTypeTag(mimeType: string): string {
            if (mimeType.startsWith('image/')) return 'image';
            if (mimeType.startsWith('video/')) return 'video';
            if (mimeType.startsWith('audio/')) return 'audio';
            return 'file';
        }
        
        async getMessageThread(messageId: string): Promise<MessageThread> {
            try {
                // Get the parent message
                const parentMessage = await this.getMessage(messageId);
                
                // Get all replies
                const replies = await this.getMessageReplies(messageId);
                
                return {
                    parentMessage,
                    replies,
                    totalReplies: replies.length
                };
            } catch (error) {
                throw new Error(`Failed to get message thread: ${error.message}`);
            }
        }
        
        private async getMessage(messageId: string): Promise<AmityMessage> {
            return new Promise((resolve, reject) => {
                const liveMessage = MessageRepository.getMessage(messageId);
                
                liveMessage.on('dataUpdated', (message: AmityMessage) => {
                    if (message) {
                        resolve(message);
                    }
                });
                
                liveMessage.on('dataError', (error: Error) => {
                    reject(error);
                });
            });
        }
        
        async getMessageReplies(parentMessageId: string): Promise<AmityMessage[]> {
            try {
                const liveCollection = MessageRepository.getMessages({
                    parentId: parentMessageId,
                    includeDeleted: false,
                    sortBy: 'createdAt',
                    sortDirection: 'asc'
                });
                
                return new Promise((resolve, reject) => {
                    liveCollection.on('dataUpdated', (messages: AmityMessage[]) => {
                        resolve(messages);
                    });
                    
                    liveCollection.on('dataError', (error: Error) => {
                        reject(error);
                    });
                });
            } catch (error) {
                throw new Error(`Failed to get replies: ${error.message}`);
            }
        }
        
        async replyWithCustomMessage(
            channelId: string,
            parentMessageId: string,
            customData: Record<string, any>
        ): Promise<AmityMessage> {
            try {
                const messageData = {
                    channelId,
                    data: customData,
                    parentId: parentMessageId,
                    tags: ['reply', 'custom', customData.type || 'unknown']
                };
                
                const liveMessage = MessageRepository.createCustomMessage(messageData);
                
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Custom reply timeout'));
                    }, 30000);

                    liveMessage.on('dataUpdated', (message: AmityMessage) => {
                        if (message.messageId) {
                            clearTimeout(timeout);
                            resolve(message);
                        }
                    });
                    
                    liveMessage.on('dataError', (error: Error) => {
                        clearTimeout(timeout);
                        reject(error);
                    });
                });
            } catch (error) {
                throw new Error(`Failed to send custom reply: ${error.message}`);
            }
        }
    }

    // Usage examples with proper typing
    const replyManager = new MessageReplyManager();

    // Text reply with metadata
    const textReply = await replyManager.replyToMessage(
        'project-channel',
        'msg123',
        'I\'ve completed the implementation. Ready for review!',
        {
            tags: ['reply', 'status-update'],
            metadata: { 
                status: 'completed',
                priority: 'high',
                assignee: 'developer123'
            }
        }
    );

    // File reply
    const fileInput = document.getElementById('fileInput') as HTMLInputElement;
    if (fileInput.files?.[0]) {
        const fileReply = await replyManager.replyWithFile(
            'documentation',
            'msg456',
            fileInput.files[0],
            'Updated API documentation with latest changes'
        );
    }

    // Get complete message thread
    const thread = await replyManager.getMessageThread('msg123');
    console.log(`Thread has ${thread.totalReplies} replies`);

    // Custom message reply (e.g., poll response)
    const pollReply = await replyManager.replyWithCustomMessage(
        'feedback-channel',
        'poll-msg789',
        {
            type: 'poll_response',
            selectedOptions: [0, 2],
            userId: 'current-user-id',
            timestamp: new Date().toISOString()
        }
    );
    ```
  </Tab>

  <Tab title="Flutter">
    ```dart
    import 'package:amity_sdk/amity_sdk.dart';
    import 'dart:io';

    class MessageReplyManager {
      Future<AmityMessage> replyToMessage({
        required String channelId,
        required String parentMessageId,
        required String replyText,
        List<String>? tags,
        String? subChannelId,
        Map<String, dynamic>? metadata,
      }) async {
        try {
          final AmityMessageRepository messageRepository = AmityMessageRepository();
          
          final AmityMessageBuilder builder = AmityMessageBuilder()
            ..channelId(channelId)
            ..text(replyText)
            ..parentId(parentMessageId)
            ..tags(tags ?? ['reply']);

          if (subChannelId != null) {
            builder.subChannelId(subChannelId);
          }

          if (metadata != null) {
            builder.metadata(metadata);
          }

          return await messageRepository.createMessage(builder.build());
        } catch (error) {
          throw Exception('Failed to send reply: $error');
        }
      }
      
      Future<AmityMessage> replyWithImage({
        required String channelId,
        required String parentMessageId,
        required File imageFile,
        String? caption,
      }) async {
        try {
          // Upload image first
          final AmityFile uploadedFile = await _uploadImage(imageFile);
          
          // Create image reply
          final AmityMessageRepository messageRepository = AmityMessageRepository();
          
          final AmityMessageBuilder builder = AmityMessageBuilder()
            ..channelId(channelId)
            ..fileId(uploadedFile.fileId!)
            ..text(caption ?? '')
            ..parentId(parentMessageId)
            ..tags(['reply', 'image']);

          return await messageRepository.createMessage(builder.build());
        } catch (error) {
          throw Exception('Failed to send image reply: $error');
        }
      }
      
      Future<AmityFile> _uploadImage(File imageFile) async {
        final AmityFileRepository fileRepository = AmityFileRepository();
        final Uint8List imageBytes = await imageFile.readAsBytes();
        final String fileName = imageFile.path.split('/').last;
        
        return await fileRepository.uploadImage(
          imageBytes,
          fileName: fileName,
        );
      }
      
      Future<List<AmityMessage>> getMessageReplies(String parentMessageId) async {
        try {
          final AmityMessageRepository messageRepository = AmityMessageRepository();
          final AmityMessagesQuery query = messageRepository.getMessages()
            ..parentId(parentMessageId)
            ..includeDeleted(false)
            ..sortBy(AmityMessageSortOption.createdAt)
            ..sortDirection(AmitySortDirection.ascending);
          
          return await query.query();
        } catch (error) {
          throw Exception('Failed to get replies: $error');
        }
      }
      
      Future<MessageThread> getMessageThread(String messageId) async {
        try {
          // Get parent message
          final AmityMessageRepository messageRepository = AmityMessageRepository();
          final AmityMessage parentMessage = await messageRepository.getMessage(messageId);
          
          // Get replies
          final List<AmityMessage> replies = await getMessageReplies(messageId);
          
          return MessageThread(
            parentMessage: parentMessage,
            replies: replies,
            totalReplies: replies.length,
          );
        } catch (error) {
          throw Exception('Failed to get message thread: $error');
        }
      }
      
      Future<AmityMessage> replyWithCustomData({
        required String channelId,
        required String parentMessageId,
        required Map<String, dynamic> customData,
      }) async {
        try {
          final AmityMessageRepository messageRepository = AmityMessageRepository();
          
          final AmityMessageBuilder builder = AmityMessageBuilder()
            ..channelId(channelId)
            ..type(AmityMessageType.custom)
            ..data(customData)
            ..parentId(parentMessageId)
            ..tags(['reply', 'custom']);

          return await messageRepository.createMessage(builder.build());
        } catch (error) {
          throw Exception('Failed to send custom reply: $error');
        }
      }
    }

    class MessageThread {
      final AmityMessage parentMessage;
      final List<AmityMessage> replies;
      final int totalReplies;

      MessageThread({
        required this.parentMessage,
        required this.replies,
        required this.totalReplies,
      });
    }

    // Usage example widget
    class MessageReplyExample extends StatefulWidget {
      final String channelId;
      final String parentMessageId;

      const MessageReplyExample({
        Key? key,
        required this.channelId,
        required this.parentMessageId,
      }) : super(key: key);

      @override
      _MessageReplyExampleState createState() => _MessageReplyExampleState();
    }

    class _MessageReplyExampleState extends State<MessageReplyExample> {
      final MessageReplyManager _replyManager = MessageReplyManager();
      final TextEditingController _replyController = TextEditingController();
      List<AmityMessage> _replies = [];
      bool _isLoading = false;

      @override
      void initState() {
        super.initState();
        _loadReplies();
      }

      Future<void> _loadReplies() async {
        try {
          setState(() {
            _isLoading = true;
          });

          final replies = await _replyManager.getMessageReplies(widget.parentMessageId);
          
          setState(() {
            _replies = replies;
            _isLoading = false;
          });
        } catch (error) {
          setState(() {
            _isLoading = false;
          });
          print('Error loading replies: $error');
        }
      }

      Future<void> _sendReply() async {
        if (_replyController.text.trim().isEmpty) return;

        try {
          final reply = await _replyManager.replyToMessage(
            channelId: widget.channelId,
            parentMessageId: widget.parentMessageId,
            replyText: _replyController.text.trim(),
            tags: ['reply', 'user-generated'],
            metadata: {
              'replyType': 'text',
              'timestamp': DateTime.now().toIso8601String(),
            },
          );

          _replyController.clear();
          _loadReplies(); // Refresh replies

          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Reply sent successfully!')),
          );
        } catch (error) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Failed to send reply: $error')),
          );
        }
      }

      Future<void> _sendImageReply() async {
        final result = await FilePicker.platform.pickFiles(
          type: FileType.image,
        );

        if (result != null && result.files.single.path != null) {
          try {
            final imageFile = File(result.files.single.path!);
            
            final reply = await _replyManager.replyWithImage(
              channelId: widget.channelId,
              parentMessageId: widget.parentMessageId,
              imageFile: imageFile,
              caption: 'Image reply',
            );

            _loadReplies(); // Refresh replies

            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Image reply sent successfully!')),
            );
          } catch (error) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Failed to send image reply: $error')),
            );
          }
        }
      }

      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(
            title: Text('Message Thread'),
            actions: [
              IconButton(
                icon: Icon(Icons.refresh),
                onPressed: _loadReplies,
              ),
            ],
          ),
          body: Column(
            children: [
              // Replies list
              Expanded(
                child: _isLoading
                    ? Center(child: CircularProgressIndicator())
                    : ListView.builder(
                        itemCount: _replies.length,
                        itemBuilder: (context, index) {
                          final reply = _replies[index];
                          return ListTile(
                            title: Text(reply.data?['text'] ?? ''),
                            subtitle: Text('Reply #${index + 1}'),
                            trailing: Text(
                              DateTime.fromMillisecondsSinceEpoch(
                                reply.createdAt?.millisecondsSinceEpoch ?? 0
                              ).toString(),
                            ),
                          );
                        },
                      ),
              ),
              
              // Reply input
              Container(
                padding: EdgeInsets.all(16),
                child: Row(
                  children: [
                    Expanded(
                      child: TextField(
                        controller: _replyController,
                        decoration: InputDecoration(
                          hintText: 'Type your reply...',
                          border: OutlineInputBorder(),
                        ),
                        onSubmitted: (_) => _sendReply(),
                      ),
                    ),
                    SizedBox(width: 8),
                    IconButton(
                      icon: Icon(Icons.image),
                      onPressed: _sendImageReply,
                    ),
                    IconButton(
                      icon: Icon(Icons.send),
                      onPressed: _sendReply,
                    ),
                  ],
                ),
              ),
            ],
          ),
        );
      }

      @override
      void dispose() {
        _replyController.dispose();
        super.dispose();
      }
    }
    ```
  </Tab>
</Tabs>

### Advanced Reply Features

<AccordionGroup>
  <Accordion title="Thread Management">
    ```javascript
    class ThreadManager {
        async getThreadSummary(parentMessageId) {
            const replies = await replyManager.getMessageReplies(parentMessageId);
            
            return {
                totalReplies: replies.length,
                lastReplyAt: replies.length > 0 ? replies[replies.length - 1].createdAt : null,
                participants: [...new Set(replies.map(r => r.userId))],
                hasUnreadReplies: this.checkUnreadReplies(replies),
                replyTypes: this.categorizeReplies(replies)
            };
        }
        
        checkUnreadReplies(replies) {
            const lastReadTime = this.getLastReadTime();
            return replies.some(reply => 
                new Date(reply.createdAt) > new Date(lastReadTime)
            );
        }
        
        categorizeReplies(replies) {
            const types = {};
            replies.forEach(reply => {
                const type = reply.type || 'text';
                types[type] = (types[type] || 0) + 1;
            });
            return types;
        }
    }
    ```
  </Accordion>

  <Accordion title="Reply Notifications">
    ```javascript
    class ReplyNotificationManager {
        async subscribeToReplies(parentMessageId, callback) {
            const liveCollection = MessageRepository.getMessages({
                parentId: parentMessageId,
                includeDeleted: false
            });
            
            liveCollection.on('dataUpdated', (messages) => {
                const newReplies = this.findNewReplies(messages);
                if (newReplies.length > 0) {
                    callback({
                        type: 'new_replies',
                        parentId: parentMessageId,
                        newReplies,
                        totalReplies: messages.length
                    });
                }
            });
            
            return liveCollection;
        }
        
        findNewReplies(currentReplies) {
            const lastKnownCount = this.getLastKnownReplyCount();
            return currentReplies.slice(lastKnownCount);
        }
        
        sendReplyNotification(parentMessage, reply) {
            // Notify parent message author about new reply
            if (parentMessage.userId !== reply.userId) {
                this.notificationService.send({
                    type: 'message_reply',
                    recipientId: parentMessage.userId,
                    data: {
                        replyId: reply.messageId,
                        parentId: parentMessage.messageId,
                        replyText: reply.data.text,
                        replyAuthor: reply.userId
                    }
                });
            }
        }
    }
    ```
  </Accordion>

  <Accordion title="Reply Analytics">
    ```javascript
    class ReplyAnalytics {
        trackReplyEngagement(parentMessageId, replies) {
            return {
                engagementRate: this.calculateEngagementRate(replies),
                averageReplyLength: this.calculateAverageLength(replies),
                responseTime: this.calculateResponseTime(replies),
                participantCount: this.countUniqueParticipants(replies),
                peakReplyTime: this.findPeakReplyTime(replies)
            };
        }
        
        calculateEngagementRate(replies) {
            // Calculate based on unique participants vs channel members
            const uniqueRepliers = new Set(replies.map(r => r.userId));
            const channelMemberCount = this.getChannelMemberCount();
            return (uniqueRepliers.size / channelMemberCount) * 100;
        }
        
        calculateResponseTime(replies) {
            if (replies.length < 2) return null;
            
            const responseTimes = [];
            for (let i = 1; i < replies.length; i++) {
                const timeDiff = new Date(replies[i].createdAt) - new Date(replies[i-1].createdAt);
                responseTimes.push(timeDiff);
            }
            
            return {
                average: responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length,
                median: this.calculateMedian(responseTimes),
                fastest: Math.min(...responseTimes)
            };
        }
    }
    ```
  </Accordion>
</AccordionGroup>

## Error Handling

<AccordionGroup>
  <Accordion title="Reply Validation">
    ```javascript
    class ReplyValidator {
        static validateReply(channelId, parentMessageId, replyData) {
            const errors = [];
            
            // Check if parent message exists and is accessible
            if (!this.isValidParentMessage(parentMessageId)) {
                errors.push('Parent message not found or not accessible');
            }
            
            // Check channel permissions
            if (!this.canReplyToChannel(channelId)) {
                errors.push('No permission to reply in this channel');
            }
            
            // Validate reply content
            if (!replyData || !replyData.text?.trim()) {
                errors.push('Reply content cannot be empty');
            }
            
            // Check reply depth (prevent excessive nesting)
            if (this.getReplyDepth(parentMessageId) >= 5) {
                errors.push('Maximum reply depth exceeded');
            }
            
            // Check rate limiting
            if (this.isRateLimited(channelId)) {
                errors.push('Rate limit exceeded. Please wait before sending another reply');
            }
            
            return errors;
        }
        
        static async isValidParentMessage(messageId) {
            try {
                const message = await MessageRepository.getMessage(messageId);
                return message && !message.isDeleted;
            } catch (error) {
                return false;
            }
        }
        
        static getReplyDepth(messageId, depth = 0) {
            // Recursively check parent messages to determine depth
            const message = this.getCachedMessage(messageId);
            if (!message || !message.parentId) {
                return depth;
            }
            return this.getReplyDepth(message.parentId, depth + 1);
        }
    }
    ```
  </Accordion>

  <Accordion title="Network Error Recovery">
    ```javascript
    class ReplyRetryManager {
        async sendReplyWithRetry(channelId, parentMessageId, replyText, maxRetries = 3) {
            let lastError;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    return await replyManager.replyToMessage(channelId, parentMessageId, replyText);
                } catch (error) {
                    lastError = error;
                    
                    if (this.isRetryableError(error) && attempt < maxRetries) {
                        const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
                        console.log(`Reply attempt ${attempt} failed, retrying in ${delay}ms...`);
                        await this.delay(delay);
                    } else {
                        break;
                    }
                }
            }
            
            throw new Error(`Reply failed after ${maxRetries} attempts: ${lastError.message}`);
        }
        
        isRetryableError(error) {
            const retryableErrors = [
                'network_error',
                'timeout',
                'server_error',
                'rate_limit_exceeded'
            ];
            return retryableErrors.some(code => error.message.includes(code));
        }
        
        delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    }
    ```
  </Accordion>

  <Accordion title="Offline Reply Queue">
    ```javascript
    class OfflineReplyQueue {
        constructor() {
            this.pendingReplies = this.loadPendingReplies();
            this.setupNetworkListener();
        }
        
        async queueReply(channelId, parentMessageId, replyData) {
            const queueItem = {
                id: this.generateId(),
                channelId,
                parentMessageId,
                replyData,
                timestamp: Date.now(),
                attempts: 0,
                status: 'pending'
            };
            
            this.pendingReplies.push(queueItem);
            this.savePendingReplies();
            
            // Try to send immediately if online
            if (navigator.onLine) {
                await this.processPendingReplies();
            }
            
            return queueItem.id;
        }
        
        async processPendingReplies() {
            const pending = this.pendingReplies.filter(item => item.status === 'pending');
            
            for (const item of pending) {
                try {
                    await replyManager.replyToMessage(
                        item.channelId,
                        item.parentMessageId,
                        item.replyData.text
                    );
                    
                    item.status = 'sent';
                    this.removePendingReply(item.id);
                } catch (error) {
                    item.attempts++;
                    if (item.attempts >= 3) {
                        item.status = 'failed';
                    }
                }
            }
            
            this.savePendingReplies();
        }
        
        setupNetworkListener() {
            window.addEventListener('online', () => {
                this.processPendingReplies();
            });
        }
    }
    ```
  </Accordion>
</AccordionGroup>

## Best Practices

<CardGroup cols={2}>
  <Card title="Thread Organization" icon="sitemap">
    Keep reply threads focused and limit nesting depth
  </Card>
  <Card title="Context Preservation" icon="link">
    Always show parent message context in reply UI
  </Card>
  <Card title="Performance" icon="gauge-high">
    Implement pagination for threads with many replies
  </Card>
  <Card title="User Experience" icon="heart">
    Provide clear visual indicators for threaded conversations
  </Card>
</CardGroup>

### Reply Design Guidelines

1. **Visual Hierarchy**: Use indentation and connecting lines to show reply relationships
2. **Context Display**: Show parent message content or preview in replies
3. **Thread Indicators**: Clear visual cues for messages that have replies
4. **Navigation**: Easy navigation between parent and child messages
5. **Collapse/Expand**: Allow users to collapse long reply threads

### Performance Optimization

1. **Lazy Loading**: Load replies on demand rather than all at once
2. **Pagination**: Implement pagination for threads with many replies
3. **Caching**: Cache frequently accessed reply threads
4. **Virtual Scrolling**: Use virtual scrolling for long reply lists

### User Experience Tips

1. **Reply Notifications**: Notify users when their messages receive replies
2. **Mention Integration**: Support mentions in replies with proper notifications
3. **Reply Drafts**: Save reply drafts to prevent data loss
4. **Quick Actions**: Provide quick reply options for common responses

## UI Components

### Reply Thread Component

```javascript
function ReplyThread({ parentMessage, onReply }) {
    const [replies, setReplies] = useState([]);
    const [showReplies, setShowReplies] = useState(false);
    const [replyText, setReplyText] = useState('');
    const [loading, setLoading] = useState(false);
    
    useEffect(() => {
        if (showReplies) {
            loadReplies();
        }
    }, [showReplies, parentMessage.messageId]);
    
    const loadReplies = async () => {
        try {
            setLoading(true);
            const replyData = await replyManager.getMessageReplies(parentMessage.messageId);
            setReplies(replyData);
        } catch (error) {
            console.error('Failed to load replies:', error);
        } finally {
            setLoading(false);
        }
    };
    
    const handleSendReply = async () => {
        if (!replyText.trim()) return;
        
        try {
            await replyManager.replyToMessage(
                parentMessage.channelId,
                parentMessage.messageId,
                replyText
            );
            setReplyText('');
            onReply?.();
            loadReplies();
        } catch (error) {
            console.error('Failed to send reply:', error);
        }
    };
    
    return (
        <div className="reply-thread">
            <div className="parent-message">
                <MessageComponent message={parentMessage} />
                
                {parentMessage.replyCount > 0 && (
                    <button 
                        className="toggle-replies"
                        onClick={() => setShowReplies(!showReplies)}
                    >
                        {showReplies ? 'Hide' : 'Show'} {parentMessage.replyCount} replies
                    </button>
                )}
            </div>
            
            {showReplies && (
                <div className="replies">
                    {loading ? (
                        <div className="loading">Loading replies...</div>
                    ) : (
                        replies.map(reply => (
                            <div key={reply.messageId} className="reply-item">
                                <MessageComponent message={reply} isReply />
                            </div>
                        ))
                    )}
                    
                    <div className="reply-input">
                        <textarea
                            value={replyText}
                            onChange={(e) => setReplyText(e.target.value)}
                            placeholder="Write a reply..."
                            rows={3}
                        />
                        <button onClick={handleSendReply} disabled={!replyText.trim()}>
                            Reply
                        </button>
                    </div>
                </div>
            )}
        </div>
    );
}
```

### Reply Indicator Component

```css
.message-with-replies {
    border-left: 3px solid #007bff;
    padding-left: 12px;
}

.reply-count {
    font-size: 0.875rem;
    color: #6c757d;
    margin-top: 4px;
}

.reply-thread {
    margin-left: 20px;
    border-left: 2px solid #e9ecef;
    padding-left: 16px;
}

.reply-item {
    margin-bottom: 8px;
    background-color: #f8f9fa;
    padding: 8px;
    border-radius: 8px;
}

.toggle-replies {
    background: none;
    border: none;
    color: #007bff;
    cursor: pointer;
    font-size: 0.875rem;
    text-decoration: underline;
}
```

## Use Cases

<AccordionGroup>
  <Accordion title="Team Discussions">
    Enable focused discussions around specific topics or decisions within team channels.
    
    ```javascript
    // Initial discussion starter
    const discussionMessage = await messageManager.sendTextMessage(
        'team-channel',
        'What do you think about switching to microservices architecture?'
    );
    
    // Team members can reply with their thoughts
    await replyManager.replyToMessage(
        'team-channel',
        discussionMessage.messageId,
        'I think it would improve our scalability, but we need to consider the complexity.'
    );
    
    await replyManager.replyToMessage(
        'team-channel', 
        discussionMessage.messageId,
        'Agreed on scalability. We should also think about monitoring and debugging across services.'
    );
    ```
  </Accordion>

  <Accordion title="Customer Support Threads">
    Create organized support conversations where multiple team members can collaborate on customer issues.
    
    ```javascript
    // Customer reports an issue
    const supportTicket = await messageManager.sendTextMessage(
        'support-channel',
        'Customer ID 12345 is experiencing login issues with their account.'
    );
    
    // Support agents can reply with updates and solutions
    await replyManager.replyToMessage(
        'support-channel',
        supportTicket.messageId,
        'I\'ve checked their account - looks like their password expired. Sending reset email.'
    );
    
    await replyManager.replyToMessage(
        'support-channel',
        supportTicket.messageId,
        'Password reset successful. Customer can now log in normally.'
    );
    ```
  </Accordion>

  <Accordion title="Code Review Discussions">
    Facilitate detailed code review conversations with context-specific feedback.
    
    ```javascript
    // Developer shares code for review
    const codeReview = await messageManager.sendFileMessage(
        'code-review-channel',
        codeFile,
        'Please review this authentication module implementation'
    );
    
    // Reviewers can provide specific feedback
    await replyManager.replyToMessage(
        'code-review-channel',
        codeReview.messageId,
        'Line 45: Consider using bcrypt for password hashing instead of SHA256'
    );
    
    await replyManager.replyToMessage(
        'code-review-channel',
        codeReview.messageId,
        'The error handling looks good, but we should add rate limiting for login attempts'
    );
    ```
  </Accordion>

  <Accordion title="Project Updates with Feedback">
    Share project updates and gather feedback through organized reply threads.
    
    ```javascript
    // Project manager shares update
    const projectUpdate = await messageManager.sendTextMessage(
        'project-channel',
        'Sprint 12 completed! We delivered 15 story points and fixed 8 bugs. Next sprint focuses on mobile optimization.'
    );
    
    // Team members can provide feedback and ask questions
    await replyManager.replyToMessage(
        'project-channel',
        projectUpdate.messageId,
        'Great progress! Are we on track for the mobile release deadline?'
    );
    
    await replyManager.replyToMessage(
        'project-channel',
        projectUpdate.messageId,
        'The bug fixes really improved app stability. Users are reporting much better performance.'
    );
    ```
  </Accordion>
</AccordionGroup>

## Reply Analytics

Track and analyze reply engagement to understand conversation patterns:

```javascript
class ReplyInsights {
    async generateThreadAnalytics(channelId, timeRange) {
        const messages = await this.getChannelMessages(channelId, timeRange);
        const threads = messages.filter(m => m.replyCount > 0);
        
        return {
            totalThreads: threads.length,
            avgRepliesPerThread: this.calculateAverage(threads.map(t => t.replyCount)),
            mostActiveThreads: this.getTopThreads(threads, 5),
            threadEngagementRate: (threads.length / messages.length) * 100,
            peakThreadTime: this.findPeakThreadTime(threads),
            threadParticipation: this.analyzeParticipation(threads)
        };
    }
    
    getTopContributors(threads) {
        const contributors = {};
        threads.forEach(thread => {
            thread.replies?.forEach(reply => {
                contributors[reply.userId] = (contributors[reply.userId] || 0) + 1;
            });
        });
        
        return Object.entries(contributors)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10);
    }
}
```

<Note>
Message replies are essential for creating organized, contextual conversations. Implement proper visual hierarchy, performance optimization, and user experience features to maximize the effectiveness of threaded discussions in your chat application.
</Note>