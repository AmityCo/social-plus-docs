# Video Messages

Share dynamic video content with automatic thumbnail generation, compression, and cross-platform playback support.

<CardGroup cols={3}>
  <Card title="Rich Media Sharing" icon="video">
    Share videos for engaging communication
  </Card>
  <Card title="Auto Thumbnails" icon="image">
    Automatic thumbnail generation
  </Card>
  <Card title="Smart Compression" icon="compress">
    Optimized for mobile playback
  </Card>
</CardGroup>

## Overview

Video messages enable users to share dynamic visual content, from quick clips to longer detailed videos. The SDK automatically handles video compression, thumbnail generation, and cross-platform compatibility to ensure optimal playback across all devices.

## Key Features

- **Automatic Compression**: Videos are automatically resized to 480p maximum
- **Thumbnail Generation**: Video thumbnails are created automatically
- **Caption Support**: Up to 1,000 characters of text with each video
- **Cross-Platform**: Consistent playback across iOS, Android, and web
- **Large File Support**: Support for videos up to 1GB in size

<Info>
**Automatic Processing**: Videos are automatically resized to a maximum of 480p resolution, and thumbnails are generated automatically for better user experience.
</Info>

## Parameters

<ParamField path="subchannelId" type="string" required>
  The unique identifier of the subchannel where the video message will be sent
</ParamField>

<ParamField path="videoPath" type="string" required>
  The local file path or URL of the video to be sent
</ParamField>

<ParamField path="caption" type="string">
  Optional text caption to accompany the video (maximum 1,000 characters)
</ParamField>

<ParamField path="tags" type="string[]">
  Array of arbitrary strings for message categorization and querying
</ParamField>

<Warning>
**File Limitations**: Maximum video file size is 1GB. Videos are automatically compressed to 480p resolution for optimal performance.
</Warning>

## Implementation

<Steps>
<Step title="Upload Video">
  Upload your video file to get a file ID for message creation
</Step>
<Step title="Create Message">
  Use the file ID to create a video message with optional caption
</Step>
<Step title="Automatic Processing">
  SDK handles compression, thumbnail generation, and delivery
</Step>
</Steps>

## Video Processing & Optimization

The SDK automatically handles video processing to ensure optimal playback and storage efficiency across all platforms.

### Automatic Compression

<AccordionGroup>
<Accordion title="Resolution Processing">
- **Maximum Resolution**: Videos are automatically resized to 480p
- **Aspect Ratio**: Original aspect ratio is preserved during compression
- **Quality Balance**: Optimized for good quality while maintaining reasonable file sizes
- **Cross-Platform**: Ensures consistent playback across all devices
</Accordion>

<Accordion title="Thumbnail Generation">
- **Automatic Creation**: Video thumbnails are generated automatically during upload
- **Preview Quality**: High-quality thumbnails for better user experience
- **Loading Efficiency**: Thumbnails load quickly for instant preview
- **Fallback Support**: Graceful handling when thumbnail generation fails
</Accordion>

<Accordion title="File Format Support">
- **Input Formats**: MP4, MOV, AVI, WebM, and other common video formats
- **Output Optimization**: Converted to web-optimized formats for playback
- **Codec Compatibility**: Ensures compatibility across different platforms
- **Progressive Download**: Supports streaming playback during download
</Accordion>
</AccordionGroup>

## Best Practices

<AccordionGroup>
<Accordion title="Video Optimization">
- Record videos in landscape mode for better viewing experience
- Keep video duration reasonable (under 5 minutes for better engagement)
- Test video quality on different network conditions
- Consider pre-compression for very large files to speed up upload
</Accordion>

<Accordion title="User Experience">
- Show upload progress indicators for video files
- Provide video preview before sending
- Implement play/pause controls in message display
- Show video duration and file size information
</Accordion>

<Accordion title="Performance Considerations">
- Cache video thumbnails for quick loading
- Implement lazy loading for video content in message history
- Use appropriate video quality based on network conditions
- Consider bandwidth usage for mobile users
</Accordion>

<Accordion title="Error Handling">
- Handle large file upload failures gracefully
- Provide retry mechanisms for failed uploads
- Show clear error messages for unsupported formats
- Implement timeout handling for long uploads
</Accordion>
</AccordionGroup>

## Use Cases

<CardGroup cols={2}>
  <Card title="Personal Communication" icon="heart">
    Share personal moments, experiences, and messages with friends and family
  </Card>
  <Card title="Educational Content" icon="graduation-cap">
    Create instructional videos, tutorials, and educational materials
  </Card>
  <Card title="Business Communication" icon="briefcase">
    Share product demos, presentations, and professional content
  </Card>
  <Card title="Creative Expression" icon="film">
    Share artistic videos, performances, and creative content
  </Card>
</CardGroup>

## Technical Specifications

- **Maximum File Size**: 1GB
- **Maximum Resolution**: 480p (automatically compressed)
- **Supported Formats**: MP4, MOV, AVI, WebM
- **Caption Length**: Up to 1,000 characters
- **Thumbnail**: Automatically generated
- **Streaming**: Progressive download support

<Tabs>
<Tab title="iOS">
**Version 6**

```swift
import AmitySDK

// Send video message with full options
func sendVideoMessage(videoPath: String, subchannelId: String, caption: String?) {
    let messageRepository = AmityMessageRepository(client: client)
    
    messageRepository.createVideoMessage(
        subchannelId: subchannelId,
        videoPath: videoPath,
        caption: caption,
        tags: ["video", "media"]
    ) { [weak self] message, error in
        if let error = error {
            print("Failed to send video: \(error.localizedDescription)")
            return
        }
        
        if let message = message {
            print("Video message sent: \(message.messageId)")
            print("Caption: \(message.data?["caption"] as? String ?? "No caption")")
            print("Thumbnail available: \(message.data?["thumbnail"] != nil)")
            
            // Update UI
            DispatchQueue.main.async {
                self?.updateMessageList(with: message)
            }
        }
    }
}

// Record and send video
func recordAndSendVideo(subchannelId: String) {
    // Present video recording interface
    let videoPicker = UIImagePickerController()
    videoPicker.mediaTypes = [UTType.movie.identifier]
    videoPicker.videoQuality = .typeMedium
    videoPicker.videoMaximumDuration = 300 // 5 minutes
    
    videoPicker.completion = { [weak self] result in
        switch result {
        case .success(let media):
            if let videoURL = media.url {
                self?.sendVideoMessage(
                    videoPath: videoURL.path,
                    subchannelId: subchannelId,
                    caption: "Just recorded this! ðŸŽ¬"
                )
            }
        case .failure(let error):
            print("Video recording failed: \(error)")
        }
    }
    
    present(videoPicker, animated: true)
}

// Send video from gallery
func sendVideoFromGallery(subchannelId: String) {
    let videoPicker = UIImagePickerController()
    videoPicker.sourceType = .photoLibrary
    videoPicker.mediaTypes = [UTType.movie.identifier]
    
    videoPicker.completion = { [weak self] result in
        switch result {
        case .success(let media):
            if let videoURL = media.url {
                // Get video caption from user
                let caption = self?.showCaptionInput()
                
                self?.sendVideoMessage(
                    videoPath: videoURL.path,
                    subchannelId: subchannelId,
                    caption: caption
                )
            }
        case .failure(let error):
            print("Video selection failed: \(error)")
        }
    }
    
    present(videoPicker, animated: true)
}
```

**Version 5 (Maintained)**

```swift
// Legacy version support
let messageRepository = AmityMessageRepository(client: client)

messageRepository.createVideoMessage(
    subchannelId: subchannelId,
    videoData: videoData,
    caption: caption
) { message, error in
    // Handle result
}
```
</Tab>

<Tab title="Android">
**Version 6**

```kotlin
import com.amity.socialcloud.sdk.api.chat.message.AmityMessageRepository

class VideoMessageSender(private val client: AmityClient) {
    private val messageRepository = AmityMessageRepository(client)
    
    // Send video message
    fun sendVideoMessage(
        subchannelId: String,
        videoPath: String,
        caption: String? = null
    ) {
        messageRepository.createVideoMessage(subchannelId)
            .video(File(videoPath))
            .caption(caption)
            .tags(listOf("video", "media"))
            .build()
            .send()
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ message ->
                Log.d("VideoMessage", "Sent: ${message.messageId}")
                Log.d("VideoMessage", "Caption: ${message.data?.get("caption")}")
                Log.d("VideoMessage", "Thumbnail: ${message.data?.get("thumbnail")}")
                
                // Update UI
                updateMessageUI(message)
            }, { error ->
                Log.e("VideoMessage", "Failed to send: ${error.message}")
                showErrorToUser(error)
            })
    }
    
    // Record and send video
    fun recordAndSendVideo(activity: Activity, subchannelId: String) {
        val intent = Intent(MediaStore.ACTION_VIDEO_CAPTURE).apply {
            putExtra(MediaStore.EXTRA_DURATION_LIMIT, 300) // 5 minutes
            putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1) // High quality
        }
        
        activity.startActivityForResult(intent, REQUEST_VIDEO_CAPTURE)
    }
    
    // Handle video capture result
    fun handleVideoCaptureResult(data: Intent?, subchannelId: String) {
        val videoUri = data?.data
        if (videoUri != null) {
            val videoPath = getRealPathFromURI(videoUri)
            sendVideoMessage(
                subchannelId = subchannelId,
                videoPath = videoPath,
                caption = "Just recorded this! ðŸŽ¬"
            )
        }
    }
    
    // Send video from gallery
    fun sendVideoFromGallery(activity: Activity, subchannelId: String) {
        val intent = Intent(Intent.ACTION_PICK, MediaStore.Video.Media.EXTERNAL_CONTENT_URI)
        activity.startActivityForResult(intent, REQUEST_VIDEO_PICK)
    }
    
    // Handle gallery video selection
    fun handleVideoGalleryResult(data: Intent?, subchannelId: String) {
        val videoUri = data?.data
        if (videoUri != null) {
            // Validate video file
            val videoFile = File(getRealPathFromURI(videoUri))
            
            if (videoFile.length() > 1024 * 1024 * 1024) { // 1GB limit
                showError("Video file is too large (max 1GB)")
                return
            }
            
            // Show caption input dialog
            showCaptionDialog { caption ->
                sendVideoMessage(
                    subchannelId = subchannelId,
                    videoPath = videoFile.path,
                    caption = caption
                )
            }
        }
    }
    
    // Video compression for large files
    fun compressAndSendVideo(
        subchannelId: String,
        videoPath: String,
        onProgress: (Int) -> Unit
    ) {
        // Use MediaMetadataRetriever to check video properties
        val retriever = MediaMetadataRetriever()
        retriever.setDataSource(videoPath)
        
        val width = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH)?.toInt() ?: 0
        val height = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT)?.toInt() ?: 0
        
        // Compress if needed (SDK handles this automatically, but you can pre-compress)
        if (width > 854 || height > 480) {
            // Compress video before sending
            compressVideo(videoPath) { compressedPath ->
                sendVideoMessage(subchannelId, compressedPath)
            }
        } else {
            sendVideoMessage(subchannelId, videoPath)
        }
    }
    
    companion object {
        const val REQUEST_VIDEO_CAPTURE = 1001
        const val REQUEST_VIDEO_PICK = 1002
    }
}
```

**Version 5 (Maintained)**

```kotlin
// Legacy version support
val messageRepository = AmityMessageRepository(client)

messageRepository.createVideoMessage(subchannelId, videoFile)
    .caption(caption)
    .build()
    .send()
    .subscribe({ message ->
        // Handle success
    }, { error ->
        // Handle error
    })
```
</Tab>

<Tab title="JavaScript">
```javascript
import { FileRepository, MessageRepository } from '@amityco/js-sdk';

// Complete video message workflow
async function sendVideoMessage(videoFile, subchannelId, caption) {
    try {
        // Validate video file
        if (!validateVideoFile(videoFile)) {
            throw new Error('Invalid video file');
        }
        
        // Show upload progress
        const progressBar = document.getElementById('upload-progress');
        
        // Step 1: Upload the video file
        const liveFile = FileRepository.createFile({ file: videoFile });
        
        // Track upload progress
        liveFile.on('loadingStatusChanged', (isLoading) => {
            progressBar.style.display = isLoading ? 'block' : 'none';
        });
        
        // Wait for upload to complete
        const uploadedFile = await new Promise((resolve, reject) => {
            liveFile.on('dataUpdated', (fileData) => {
                if (fileData.isUploaded) {
                    resolve(fileData);
                }
            });
            
            liveFile.on('dataError', reject);
        });
        
        // Step 2: Create video message
        const liveMessage = MessageRepository.createVideoMessage({
            subchannelId: subchannelId,
            videoId: uploadedFile.fileId,
            caption: caption || '',
            tags: ['video', 'media']
        });
        
        // Handle message creation
        liveMessage.on('dataUpdated', (message) => {
            console.log('Video message sent:', message.messageId);
            console.log('Thumbnail available:', !!message.data?.thumbnail);
            updateMessageUI(message);
        });
        
        liveMessage.on('dataError', (error) => {
            console.error('Failed to send video message:', error);
            showErrorNotification(error);
        });
        
        return liveMessage;
    } catch (error) {
        console.error('Video upload failed:', error);
        throw error;
    }
}

// Validate video file
function validateVideoFile(file) {
    const allowedTypes = ['video/mp4', 'video/mov', 'video/avi', 'video/webm'];
    const maxSize = 1024 * 1024 * 1024; // 1GB
    
    if (!allowedTypes.includes(file.type)) {
        alert('Please select a valid video file (MP4, MOV, AVI, WebM)');
        return false;
    }
    
    if (file.size > maxSize) {
        alert('Video file is too large. Maximum size is 1GB');
        return false;
    }
    
    return true;
}

// Handle video file selection
function handleVideoSelection(event, subchannelId) {
    const file = event.target.files[0];
    if (!file) return;
    
    // Show video preview
    const video = document.createElement('video');
    video.src = URL.createObjectURL(file);
    video.controls = true;
    video.style.maxWidth = '300px';
    
    const preview = document.getElementById('video-preview');
    preview.innerHTML = '';
    preview.appendChild(video);
    
    // Get caption from user
    const caption = prompt('Enter a caption for your video (optional):');
    
    // Send video message
    sendVideoMessage(file, subchannelId, caption);
}

// Record video using getUserMedia
async function recordVideo(subchannelId) {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 640, height: 480 },
            audio: true
        });
        
        const mediaRecorder = new MediaRecorder(stream);
        const chunks = [];
        
        mediaRecorder.ondataavailable = (event) => {
            chunks.push(event.data);
        };
        
        mediaRecorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'video/webm' });
            const file = new File([blob], 'recorded-video.webm', { type: 'video/webm' });
            
            // Send recorded video
            sendVideoMessage(file, subchannelId, 'Just recorded this! ðŸŽ¬');
        };
        
        // Start recording
        mediaRecorder.start();
        
        // Stop recording after 5 minutes or when user clicks stop
        setTimeout(() => {
            mediaRecorder.stop();
            stream.getTracks().forEach(track => track.stop());
        }, 300000); // 5 minutes
        
    } catch (error) {
        console.error('Video recording failed:', error);
        alert('Could not access camera/microphone');
    }
}
```
</Tab>

<Tab title="TypeScript">
**Version 6**

```typescript
import { 
    FileRepository, 
    MessageRepository, 
    AmityMessage,
    AmityFile 
} from '@amityco/ts-sdk';

interface VideoMessageOptions {
    subchannelId: string;
    videoFile: File;
    caption?: string;
    tags?: string[];
    onProgress?: (progress: number) => void;
}

class VideoMessageService {
    private fileRepository: FileRepository;
    private messageRepository: MessageRepository;
    
    constructor() {
        this.fileRepository = new FileRepository();
        this.messageRepository = new MessageRepository();
    }
    
    // Type-safe video message sending
    async sendVideoMessage(options: VideoMessageOptions): Promise<AmityMessage> {
        const { subchannelId, videoFile, caption, tags = [], onProgress } = options;
        
        try {
            // Validate video file
            this.validateVideoFile(videoFile);
            
            // Upload video with progress tracking
            const liveFile = this.fileRepository.createFile({ file: videoFile });
            
            if (onProgress) {
                liveFile.on('loadingStatusChanged', (isLoading: boolean) => {
                    // Handle loading state
                    if (isLoading) {
                        onProgress(50); // Simplified progress
                    }
                });
            }
            
            // Wait for upload completion
            const uploadedFile: AmityFile = await new Promise((resolve, reject) => {
                liveFile.on('dataUpdated', (fileData: AmityFile) => {
                    if (fileData.isUploaded) {
                        resolve(fileData);
                    }
                });
                
                liveFile.on('dataError', reject);
            });
            
            // Create video message
            const liveMessage = this.messageRepository.createVideoMessage({
                subchannelId,
                videoId: uploadedFile.fileId,
                caption: caption || '',
                tags
            });
            
            // Return message promise
            return new Promise<AmityMessage>((resolve, reject) => {
                liveMessage.on('dataUpdated', (message: AmityMessage) => {
                    console.log(`Video message sent: ${message.messageId}`);
                    console.log(`Thumbnail available: ${!!message.data?.thumbnail}`);
                    
                    if (onProgress) {
                        onProgress(100);
                    }
                    
                    resolve(message);
                });
                
                liveMessage.on('dataError', reject);
            });
            
        } catch (error) {
            console.error('Failed to send video message:', error);
            throw error;
        }
    }
    
    // File validation
    private validateVideoFile(file: File): void {
        const allowedTypes = ['video/mp4', 'video/mov', 'video/avi', 'video/webm'];
        const maxSize = 1024 * 1024 * 1024; // 1GB
        
        if (!allowedTypes.includes(file.type)) {
            throw new Error('Invalid file type. Supported formats: MP4, MOV, AVI, WebM');
        }
        
        if (file.size > maxSize) {
            throw new Error('File too large. Maximum size is 1GB.');
        }
    }
    
    // Record video using browser APIs
    async recordVideo(subchannelId: string): Promise<AmityMessage> {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480 },
                audio: true
            });
            
            const mediaRecorder = new MediaRecorder(stream);
            const chunks: Blob[] = [];
            
            return new Promise((resolve, reject) => {
                mediaRecorder.ondataavailable = (event) => {
                    chunks.push(event.data);
                };
                
                mediaRecorder.onstop = async () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const file = new File([blob], 'recorded-video.webm', { 
                        type: 'video/webm' 
                    });
                    
                    try {
                        const message = await this.sendVideoMessage({
                            subchannelId,
                            videoFile: file,
                            caption: 'Just recorded this! ðŸŽ¬',
                            tags: ['recorded', 'live']
                        });
                        
                        resolve(message);
                    } catch (error) {
                        reject(error);
                    }
                };
                
                mediaRecorder.start();
                
                // Auto-stop after 5 minutes
                setTimeout(() => {
                    mediaRecorder.stop();
                    stream.getTracks().forEach(track => track.stop());
                }, 300000);
            });
            
        } catch (error) {
            console.error('Video recording failed:', error);
            throw new Error('Could not access camera/microphone');
        }
    }
    
    // Get video metadata
    getVideoMetadata(file: File): Promise<{duration: number, width: number, height: number}> {
        return new Promise((resolve, reject) => {
            const video = document.createElement('video');
            video.preload = 'metadata';
            
            video.onloadedmetadata = () => {
                resolve({
                    duration: video.duration,
                    width: video.videoWidth,
                    height: video.videoHeight
                });
            };
            
            video.onerror = reject;
            video.src = URL.createObjectURL(file);
        });
    }
}

// Usage example
const videoService = new VideoMessageService();

// Send video message
videoService.sendVideoMessage({
    subchannelId: 'subchannel-123',
    videoFile: selectedVideoFile,
    caption: 'Check out this awesome video! ðŸŽ¥',
    tags: ['awesome', 'video'],
    onProgress: (progress) => {
        console.log(`Upload progress: ${progress}%`);
        updateProgressBar(progress);
    }
}).then(message => {
    console.log('Video message sent successfully:', message);
}).catch(error => {
    console.error('Send failed:', error);
});
```

**Beta (v0.0.1)**

```typescript
// Legacy TypeScript support
const messageRepository = new MessageRepository();

try {
    const message = await messageRepository.createVideoMessage({
        subchannelId: 'subchannel-123',
        videoId: 'uploaded-video-id',
        caption: 'My video caption'
    });
    
    console.log('Video message created:', message);
} catch (error) {
    console.error('Failed to create video message:', error);
}
```
</Tab>

<Tab title="Flutter">
```dart
import 'package:amity_sdk/amity_sdk.dart';
import 'package:image_picker/image_picker.dart';
import 'dart:io';

class VideoMessageService {
    final AmityClient client;
    late final AmityMessageRepository messageRepository;
    
    VideoMessageService(this.client) {
        messageRepository = AmityMessageRepository(client);
    }
    
    // Send video message
    Future<AmityMessage> sendVideoMessage({
        required String subchannelId,
        required String videoPath,
        String? caption,
        List<String>? tags,
    }) async {
        try {
            final message = await messageRepository.createVideoMessage(
                subchannelId: subchannelId,
                videoPath: videoPath,
                caption: caption,
                tags: tags ?? ['video'],
            );
            
            print('Video message sent: ${message.messageId}');
            print('Caption: ${message.data?['caption'] ?? 'No caption'}');
            print('Thumbnail: ${message.data?['thumbnail'] != null ? 'Available' : 'Not available'}');
            
            return message;
        } catch (error) {
            print('Failed to send video message: $error');
            rethrow;
        }
    }
    
    // Record video and send
    Future<void> recordAndSendVideo(String subchannelId) async {
        try {
            final picker = ImagePicker();
            final recordedVideo = await picker.pickVideo(
                source: ImageSource.camera,
                maxDuration: Duration(minutes: 5),
            );
            
            if (recordedVideo == null) return;
            
            // Validate file size
            final file = File(recordedVideo.path);
            final fileSize = await file.length();
            
            if (fileSize > 1024 * 1024 * 1024) { // 1GB limit
                throw Exception('Video file is too large (max 1GB)');
            }
            
            await sendVideoMessage(
                subchannelId: subchannelId,
                videoPath: recordedVideo.path,
                caption: 'Just recorded this! ðŸŽ¬',
                tags: ['recorded', 'live'],
            );
            
        } catch (error) {
            print('Error recording video: $error');
            // Show error to user
        }
    }
    
    // Send video from gallery
    Future<void> sendVideoFromGallery(String subchannelId) async {
        try {
            final picker = ImagePicker();
            final pickedVideo = await picker.pickVideo(
                source: ImageSource.gallery,
            );
            
            if (pickedVideo == null) return;
            
            // Validate file size
            final file = File(pickedVideo.path);
            final fileSize = await file.length();
            
            if (fileSize > 1024 * 1024 * 1024) { // 1GB limit
                throw Exception('Video file is too large (max 1GB)');
            }
            
            // Get caption from user
            final caption = await _showCaptionDialog();
            
            await sendVideoMessage(
                subchannelId: subchannelId,
                videoPath: pickedVideo.path,
                caption: caption,
                tags: ['gallery', 'user_upload'],
            );
            
        } catch (error) {
            print('Error sending video from gallery: $error');
            // Show error to user
        }
    }
    
    // Get video metadata
    Future<VideoMetadata> getVideoMetadata(String videoPath) async {
        try {
            final file = File(videoPath);
            final fileSize = await file.length();
            
            // You can use video_player package or similar to get more metadata
            return VideoMetadata(
                path: videoPath,
                size: fileSize,
                duration: Duration.zero, // Would need video_player to get actual duration
            );
        } catch (error) {
            print('Error getting video metadata: $error');
            rethrow;
        }
    }
    
    // Helper method for caption input
    Future<String?> _showCaptionDialog() async {
        // Implementation depends on your UI framework
        // Return user input or null
        return null;
    }
}

// Video metadata class
class VideoMetadata {
    final String path;
    final int size;
    final Duration duration;
    
    VideoMetadata({
        required this.path,
        required this.size,
        required this.duration,
    });
}

// Usage in a widget
class VideoMessageWidget extends StatefulWidget {
    final String subchannelId;
    
    const VideoMessageWidget({Key? key, required this.subchannelId}) : super(key: key);
    
    @override
    _VideoMessageWidgetState createState() => _VideoMessageWidgetState();
}

class _VideoMessageWidgetState extends State<VideoMessageWidget> {
    late final VideoMessageService _videoService;
    bool _sending = false;
    
    @override
    void initState() {
        super.initState();
        _videoService = VideoMessageService(AmityClient.instance);
    }
    
    @override
    Widget build(BuildContext context) {
        return Row(
            children: [
                IconButton(
                    icon: Icon(Icons.videocam),
                    onPressed: _sending ? null : () => _recordVideo(),
                ),
                IconButton(
                    icon: Icon(Icons.video_library),
                    onPressed: _sending ? null : () => _sendFromGallery(),
                ),
                if (_sending)
                    CircularProgressIndicator(),
            ],
        );
    }
    
    Future<void> _recordVideo() async {
        setState(() => _sending = true);
        try {
            await _videoService.recordAndSendVideo(widget.subchannelId);
        } finally {
            setState(() => _sending = false);
        }
    }
    
    Future<void> _sendFromGallery() async {
        setState(() => _sending = true);
        try {
            await _videoService.sendVideoFromGallery(widget.subchannelId);
        } finally {
            setState(() => _sending = false);
        }
    }
}
```
</Tab>
</Tabs>