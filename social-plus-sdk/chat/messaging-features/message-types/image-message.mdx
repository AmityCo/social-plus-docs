# Image Messages

Send visual content including photos, screenshots, and graphics with optional captions and automatic multi-size optimization.

<CardGroup cols={3}>
  <Card title="Visual Communication" icon="image">
    Share photos and graphics instantly
  </Card>
  <Card title="Auto Optimization" icon="gauge-high">
    Automatic resizing and compression
  </Card>
  <Card title="Flexible Sizing" icon="expand">
    Multiple size options for different needs
  </Card>
</CardGroup>

## Overview

Image messages enable rich visual communication by allowing users to share photos, screenshots, documents, and other visual content. The SDK automatically handles image optimization, resizing, and compression to ensure optimal performance across different network conditions.

## Key Features

- **Automatic Processing**: Images are automatically resized and optimized
- **Multiple Sizes**: Small, medium, large, and optionally full-size variants
- **Smart Compression**: Maintains quality while reducing file size
- **Caption Support**: Up to 1,000 characters of text with each image
- **Format Support**: JPG, PNG, and HEIC formats supported

<Warning>
**File Limitations**: Supported formats are JPG, PNG, and HEIC with a maximum file size of 1GB
</Warning>

## Parameters

<ParamField path="subchannelId" type="string" required>
  The unique identifier of the subchannel where the image message will be sent
</ParamField>

<ParamField path="imageId" type="string" required>
  The file ID of the uploaded image. See [File Upload Guide](/social-plus-sdk/core-concepts/files-images-and-videos/image-handling#upload-images) for upload instructions
</ParamField>

<ParamField path="caption" type="string">
  Optional text caption to accompany the image (maximum 1,000 characters)
</ParamField>

<ParamField path="tags" type="string[]">
  Array of arbitrary strings for message categorization and querying
</ParamField>

<ParamField path="isFullImage" type="boolean">
  Whether to preserve the original image size (may affect sending speed)
  - `true`: Include original size option
  - `false`: Limit to optimized sizes (up to 1500x1500 pixels)
</ParamField>

## Implementation

<Steps>
<Step title="Upload Image">
  First, upload your image file to get a file ID
</Step>
<Step title="Create Message">
  Use the file ID to create an image message
</Step>
<Step title="Send to Subchannel">
  The message is automatically sent to the specified subchannel
</Step>
</Steps>

<Tabs>
<Tab title="iOS">
**Version 6**

```swift
import AmitySDK

// Upload and send image message
func sendImageMessage(imagePath: String, subchannelId: String, caption: String?) {
    let messageRepository = AmityMessageRepository(client: client)
    
    // Create image message with full size option
    messageRepository.createImageMessage(
        subchannelId: subchannelId,
        imagePath: imagePath,
        caption: caption,
        tags: ["photo", "shared"],
        isFullImage: true
    ) { [weak self] message, error in
        if let error = error {
            print("Failed to send image: \(error.localizedDescription)")
            return
        }
        
        if let message = message {
            print("Image message sent: \(message.messageId)")
            print("Caption: \(message.data?["caption"] as? String ?? "No caption")")
            
            // Update UI
            DispatchQueue.main.async {
                self?.updateMessageList(with: message)
            }
        }
    }
}

// Send with optimized sizing
messageRepository.createImageMessage(
    subchannelId: "subchannel-123",
    imagePath: localImagePath,
    caption: "Check out this amazing sunset! ðŸŒ…",
    tags: ["nature", "photography"],
    isFullImage: false  // Optimized for faster sending
) { message, error in
    // Handle result
}

// Batch image sending
func sendMultipleImages(imagePaths: [String], subchannelId: String) {
    for (index, imagePath) in imagePaths.enumerated() {
        messageRepository.createImageMessage(
            subchannelId: subchannelId,
            imagePath: imagePath,
            caption: "Image \(index + 1) of \(imagePaths.count)",
            tags: ["batch", "gallery"]
        ) { message, error in
            // Handle each result
        }
    }
}
```

**Version 5 (Maintained)**

```swift
// Legacy version support
let messageRepository = AmityMessageRepository(client: client)

messageRepository.createImageMessage(
    subchannelId: subchannelId,
    imageData: imageData,
    caption: caption
) { message, error in
    // Handle result
}
```
</Tab>

<Tab title="Android">
**Version 6**

```kotlin
import com.amity.socialcloud.sdk.api.chat.message.AmityMessageRepository

class ImageMessageSender(private val client: AmityClient) {
    private val messageRepository = AmityMessageRepository(client)
    
    // Send image with full quality
    fun sendImageMessage(
        subchannelId: String,
        imagePath: String,
        caption: String? = null,
        isFullImage: Boolean = false
    ) {
        messageRepository.createImageMessage(subchannelId)
            .image(File(imagePath))
            .caption(caption)
            .tags(listOf("photo", "shared"))
            .isFullImage(isFullImage)  // Set to true for original size
            .build()
            .send()
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ message ->
                Log.d("ImageMessage", "Sent: ${message.messageId}")
                Log.d("ImageMessage", "Caption: ${message.data?.get("caption")}")
                
                // Update UI
                updateMessageUI(message)
            }, { error ->
                Log.e("ImageMessage", "Failed to send: ${error.message}")
                showErrorToUser(error)
            })
    }
    
    // Send optimized image
    fun sendOptimizedImage(subchannelId: String, imageUri: Uri, caption: String) {
        val inputStream = contentResolver.openInputStream(imageUri)
        
        messageRepository.createImageMessage(subchannelId)
            .image(inputStream)
            .caption(caption)
            .tags(listOf("optimized", "mobile"))
            .isFullImage(false)  // Automatically optimized
            .build()
            .send()
            .subscribe({ message ->
                // Handle success
                handleImageMessageSent(message)
            }, { error ->
                // Handle error
                handleSendError(error)
            })
    }
    
    // Batch image sending
    fun sendImageGallery(subchannelId: String, imagePaths: List<String>) {
        imagePaths.forEachIndexed { index, imagePath ->
            sendImageMessage(
                subchannelId = subchannelId,
                imagePath = imagePath,
                caption = "Photo ${index + 1} of ${imagePaths.size}",
                isFullImage = false
            )
        }
    }
}
```

**Version 5 (Maintained)**

```kotlin
// Legacy version support
val messageRepository = AmityMessageRepository(client)

messageRepository.createImageMessage(subchannelId, imageFile)
    .caption(caption)
    .build()
    .send()
    .subscribe({ message ->
        // Handle success
    }, { error ->
        // Handle error
    })
```
</Tab>

<Tab title="JavaScript">
```javascript
import { FileRepository, MessageRepository } from '@amityco/js-sdk';

// Complete image message workflow
async function sendImageMessage(file, subchannelId, caption) {
    try {
        // Step 1: Upload the image file
        const liveFile = FileRepository.createFile({ file });
        
        // Wait for upload to complete
        await new Promise((resolve, reject) => {
            liveFile.on('dataUpdated', (fileData) => {
                if (fileData.isUploaded) {
                    resolve(fileData);
                }
            });
            
            liveFile.on('dataError', reject);
        });
        
        // Step 2: Create image message
        const liveMessage = MessageRepository.createImageMessage({
            subchannelId: subchannelId,
            imageId: liveFile.model.fileId,
            caption: caption || '',
            tags: ['photo', 'upload']
        });
        
        // Handle message creation
        liveMessage.on('dataUpdated', (message) => {
            console.log('Image message sent:', message.messageId);
            console.log('Image sizes available:', message.data?.imageSize);
            updateMessageUI(message);
        });
        
        liveMessage.on('dataError', (error) => {
            console.error('Failed to send image message:', error);
            showErrorNotification(error);
        });
        
        return liveMessage;
    } catch (error) {
        console.error('Image upload failed:', error);
        throw error;
    }
}

// Handle file input from user
function handleImageSelection(event, subchannelId) {
    const file = event.target.files[0];
    
    if (!file) return;
    
    // Validate file type
    const allowedTypes = ['image/jpeg', 'image/png', 'image/heic'];
    if (!allowedTypes.includes(file.type)) {
        alert('Please select a JPG, PNG, or HEIC image file');
        return;
    }
    
    // Check file size (1GB limit)
    if (file.size > 1024 * 1024 * 1024) {
        alert('Image file is too large. Maximum size is 1GB');
        return;
    }
    
    // Show preview and send
    const caption = prompt('Enter a caption (optional):');
    sendImageMessage(file, subchannelId, caption);
}

// Batch image upload
async function sendMultipleImages(files, subchannelId) {
    const uploadPromises = Array.from(files).map((file, index) => {
        const caption = `Image ${index + 1} of ${files.length}`;
        return sendImageMessage(file, subchannelId, caption);
    });
    
    try {
        await Promise.all(uploadPromises);
        console.log('All images sent successfully');
    } catch (error) {
        console.error('Some images failed to send:', error);
    }
}
```
</Tab>

<Tab title="TypeScript">
**Version 6**

```typescript
import { 
    FileRepository, 
    MessageRepository, 
    AmityMessage,
    AmityFile 
} from '@amityco/ts-sdk';

interface ImageMessageOptions {
    subchannelId: string;
    file: File;
    caption?: string;
    tags?: string[];
    onProgress?: (progress: number) => void;
}

class ImageMessageService {
    private fileRepository: FileRepository;
    private messageRepository: MessageRepository;
    
    constructor() {
        this.fileRepository = new FileRepository();
        this.messageRepository = new MessageRepository();
    }
    
    // Type-safe image message sending
    async sendImageMessage(options: ImageMessageOptions): Promise<AmityMessage> {
        const { subchannelId, file, caption, tags = [], onProgress } = options;
        
        try {
            // Validate file
            this.validateImageFile(file);
            
            // Upload file with progress tracking
            const liveFile = this.fileRepository.createFile({ file });
            
            if (onProgress) {
                liveFile.on('loadingStatusChanged', (isLoading: boolean) => {
                    // Handle loading state
                });
            }
            
            // Wait for upload completion
            const uploadedFile: AmityFile = await new Promise((resolve, reject) => {
                liveFile.on('dataUpdated', (fileData: AmityFile) => {
                    if (fileData.isUploaded) {
                        resolve(fileData);
                    }
                });
                
                liveFile.on('dataError', reject);
            });
            
            // Create image message
            const liveMessage = this.messageRepository.createImageMessage({
                subchannelId,
                imageId: uploadedFile.fileId,
                caption: caption || '',
                tags
            });
            
            // Return message promise
            return new Promise<AmityMessage>((resolve, reject) => {
                liveMessage.on('dataUpdated', (message: AmityMessage) => {
                    console.log(`Image message sent: ${message.messageId}`);
                    resolve(message);
                });
                
                liveMessage.on('dataError', reject);
            });
            
        } catch (error) {
            console.error('Failed to send image message:', error);
            throw error;
        }
    }
    
    // File validation
    private validateImageFile(file: File): void {
        const allowedTypes = ['image/jpeg', 'image/png', 'image/heic'];
        const maxSize = 1024 * 1024 * 1024; // 1GB
        
        if (!allowedTypes.includes(file.type)) {
            throw new Error('Invalid file type. Only JPG, PNG, and HEIC are supported.');
        }
        
        if (file.size > maxSize) {
            throw new Error('File too large. Maximum size is 1GB.');
        }
    }
    
    // Batch upload with progress
    async sendImageBatch(
        files: File[], 
        subchannelId: string,
        onBatchProgress?: (completed: number, total: number) => void
    ): Promise<AmityMessage[]> {
        const results: AmityMessage[] = [];
        
        for (let i = 0; i < files.length; i++) {
            try {
                const message = await this.sendImageMessage({
                    subchannelId,
                    file: files[i],
                    caption: `Image ${i + 1} of ${files.length}`,
                    tags: ['batch', 'gallery']
                });
                
                results.push(message);
                
                if (onBatchProgress) {
                    onBatchProgress(i + 1, files.length);
                }
            } catch (error) {
                console.error(`Failed to send image ${i + 1}:`, error);
            }
        }
        
        return results;
    }
}

// Usage example
const imageService = new ImageMessageService();

// Send single image
imageService.sendImageMessage({
    subchannelId: 'subchannel-123',
    file: selectedFile,
    caption: 'Beautiful sunset from my vacation! ðŸŒ…',
    tags: ['vacation', 'nature'],
    onProgress: (progress) => {
        console.log(`Upload progress: ${progress}%`);
    }
}).then(message => {
    console.log('Message sent successfully:', message);
}).catch(error => {
    console.error('Send failed:', error);
});
```

**Beta (v0.0.1)**

```typescript
// Legacy TypeScript support
const messageRepository = new MessageRepository();

try {
    const message = await messageRepository.createImageMessage({
        subchannelId: 'subchannel-123',
        imageId: 'uploaded-file-id',
        caption: 'My image caption'
    });
    
    console.log('Image message created:', message);
} catch (error) {
    console.error('Failed to create image message:', error);
}
```
</Tab>

<Tab title="Flutter">
```dart
import 'package:amity_sdk/amity_sdk.dart';
import 'dart:io';

class ImageMessageService {
    final AmityClient client;
    late final AmityMessageRepository messageRepository;
    
    ImageMessageService(this.client) {
        messageRepository = AmityMessageRepository(client);
    }
    
    // Send image message with full options
    Future<AmityMessage> sendImageMessage({
        required String subchannelId,
        required String imagePath,
        String? caption,
        List<String>? tags,
        bool isFullImage = false,
    }) async {
        try {
            final message = await messageRepository.createImageMessage(
                subchannelId: subchannelId,
                imagePath: imagePath,
                caption: caption,
                tags: tags ?? ['photo'],
                isFullImage: isFullImage,  // Set to true for original size
            );
            
            print('Image message sent: ${message.messageId}');
            print('Caption: ${message.data?['caption'] ?? 'No caption'}');
            
            return message;
        } catch (error) {
            print('Failed to send image message: $error');
            rethrow;
        }
    }
    
    // Send image from file picker
    Future<void> sendImageFromPicker(String subchannelId) async {
        try {
            // Use file picker to select image
            final picker = ImagePicker();
            final pickedFile = await picker.pickImage(
                source: ImageSource.gallery,
                maxWidth: 1920,
                maxHeight: 1920,
                imageQuality: 85,
            );
            
            if (pickedFile == null) return;
            
            // Validate file size
            final file = File(pickedFile.path);
            final fileSize = await file.length();
            
            if (fileSize > 1024 * 1024 * 1024) { // 1GB limit
                throw Exception('Image file is too large (max 1GB)');
            }
            
            // Get caption from user
            final caption = await _showCaptionDialog();
            
            // Send image message
            await sendImageMessage(
                subchannelId: subchannelId,
                imagePath: pickedFile.path,
                caption: caption,
                tags: ['gallery', 'user_upload'],
                isFullImage: false, // Optimized for mobile
            );
            
        } catch (error) {
            print('Error sending image from picker: $error');
            // Show error to user
        }
    }
    
    // Send multiple images
    Future<List<AmityMessage>> sendImageBatch({
        required String subchannelId,
        required List<String> imagePaths,
        String? batchCaption,
    }) async {
        final List<AmityMessage> sentMessages = [];
        
        for (int i = 0; i < imagePaths.length; i++) {
            try {
                final caption = batchCaption ?? 'Image ${i + 1} of ${imagePaths.length}';
                
                final message = await sendImageMessage(
                    subchannelId: subchannelId,
                    imagePath: imagePaths[i],
                    caption: caption,
                    tags: ['batch', 'gallery'],
                    isFullImage: false,
                );
                
                sentMessages.add(message);
            } catch (error) {
                print('Failed to send image ${i + 1}: $error');
            }
        }
        
        return sentMessages;
    }
    
    // Camera capture and send
    Future<void> captureAndSendImage(String subchannelId) async {
        try {
            final picker = ImagePicker();
            final capturedImage = await picker.pickImage(
                source: ImageSource.camera,
                maxWidth: 1920,
                maxHeight: 1920,
                imageQuality: 90,
            );
            
            if (capturedImage == null) return;
            
            await sendImageMessage(
                subchannelId: subchannelId,
                imagePath: capturedImage.path,
                caption: 'Captured just now ðŸ“¸',
                tags: ['camera', 'live'],
                isFullImage: false,
            );
            
        } catch (error) {
            print('Error capturing and sending image: $error');
        }
    }
    
    // Helper method for caption input
    Future<String?> _showCaptionDialog() async {
        // Implementation depends on your UI framework
        // Return user input or null
        return null;
    }
}

// Usage in a widget
class ImageMessageWidget extends StatefulWidget {
    final String subchannelId;
    
    const ImageMessageWidget({Key? key, required this.subchannelId}) : super(key: key);
    
    @override
    _ImageMessageWidgetState createState() => _ImageMessageWidgetState();
}

class _ImageMessageWidgetState extends State<ImageMessageWidget> {
    late final ImageMessageService _imageService;
    bool _sending = false;
    
    @override
    void initState() {
        super.initState();
        _imageService = ImageMessageService(AmityClient.instance);
    }
    
    @override
    Widget build(BuildContext context) {
        return Row(
            children: [
                IconButton(
                    icon: Icon(Icons.photo_library),
                    onPressed: _sending ? null : () => _sendFromGallery(),
                ),
                IconButton(
                    icon: Icon(Icons.camera_alt),
                    onPressed: _sending ? null : () => _sendFromCamera(),
                ),
                if (_sending)
                    CircularProgressIndicator(),
            ],
        );
    }
    
    Future<void> _sendFromGallery() async {
        setState(() => _sending = true);
        try {
            await _imageService.sendImageFromPicker(widget.subchannelId);
        } finally {
            setState(() => _sending = false);
        }
    }
    
    Future<void> _sendFromCamera() async {
        setState(() => _sending = true);
        try {
            await _imageService.captureAndSendImage(widget.subchannelId);
        } finally {
            setState(() => _sending = false);
        }
    }
}
```
</Tab>
</Tabs>

## Image Processing & Optimization

The SDK automatically handles image processing to provide optimal performance across different network conditions and device capabilities.

### Automatic Sizing

When an image is uploaded, it's automatically processed into multiple size variants:

<AccordionGroup>
<Accordion title="Size Options">
- **Small**: Optimized for thumbnails and previews
- **Medium**: Balanced quality and size for general viewing
- **Large**: High quality for detailed viewing
- **Full Size**: Original image (only if `isFullImage` is enabled)
</Accordion>

<Accordion title="Processing Rules">
- Size is determined by the longest dimension in pixels
- Aspect ratio is always preserved during resizing
- Maximum file size limit is 1GB for original images
- Optimized versions are automatically compressed for efficiency
</Accordion>

<Accordion title="Performance Impact">
- **Full Size Enabled**: May significantly slow message sending
- **Optimized Only**: Faster sending, maximum 1500x1500 pixels
- **Smart Compression**: Maintains visual quality while reducing file size
</Accordion>
</AccordionGroup>

### Caption Support

Image messages support rich captions with the following features:
- **Length**: Up to 1,000 characters per message
- **Accessibility**: Available under the `data.caption` property
- **Formatting**: Supports basic text formatting and emojis
- **Searchability**: Captions are indexed for message search

## Best Practices

<AccordionGroup>
<Accordion title="Image Optimization">
- Use `isFullImage: false` for faster sending in most cases
- Pre-compress images on the client side for very large files
- Consider image quality vs. file size trade-offs
- Test performance with different image sizes and formats
</Accordion>

<Accordion title="User Experience">
- Show upload progress indicators for large images
- Provide image preview before sending
- Implement image compression settings for users
- Support both camera capture and gallery selection
</Accordion>

<Accordion title="Error Handling">
- Validate file types and sizes before upload
- Handle network failures gracefully with retry options
- Provide clear error messages for unsupported formats
- Implement fallback mechanisms for failed uploads
</Accordion>

<Accordion title="Performance Considerations">
- Batch multiple images efficiently
- Use appropriate image quality settings for mobile
- Consider lazy loading for image message history
- Implement proper memory management for large images
</Accordion>
</AccordionGroup>

## Use Cases

<CardGroup cols={2}>
  <Card title="Social Sharing" icon="share">
    Share photos, moments, and experiences with friends and communities
  </Card>
  <Card title="Visual Documentation" icon="file-image">
    Send screenshots, documents, and visual information for work or projects
  </Card>
  <Card title="Product Showcase" icon="store">
    Display products, services, or portfolio items in business communications
  </Card>
  <Card title="Creative Expression" icon="palette">
    Share artwork, designs, and creative content with visual impact
  </Card>
</CardGroup>