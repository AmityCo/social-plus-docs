---
title: "Mentions in Messages"
description: "Implement user and channel mentions in messages with Social Plus SDK for enhanced engagement and notification capabilities"
---

import { Card, Cards, CardGroup } from "/snippets/card-group.mdx";
import { Callout } from "/snippets/callout.mdx";
import { CodeGroup } from "/snippets/code-group.mdx";
import { Tabs, Tab } from "/snippets/tabs.mdx";
import { AccordionGroup, Accordion } from "/snippets/accordion-group.mdx";

# Mentions in Messages

Enable rich user interactions through @mentions functionality, allowing users to tag specific individuals or entire channels for targeted notifications and enhanced engagement.

<CardGroup cols={2}>
  <Card
    title="User Mentions"
    icon="at"
    href="#user-mentions"
  >
    Tag individual users with @username syntax
  </Card>
  <Card
    title="Channel Mentions"
    icon="bullhorn"
    href="#channel-mentions"
  >
    Notify all channel members with @all mentions
  </Card>
  <Card
    title="Message Updates"
    icon="pen-to-square"
    href="#updating-mentions"
  >
    Modify mentions in existing messages
  </Card>
  <Card
    title="Mention Rendering"
    icon="paintbrush"
    href="#mention-rendering"
  >
    Display mentions with custom styling
  </Card>
</CardGroup>

## Architecture Overview

```mermaid
graph TB
    A[User Types Message] --> B{Contains @?}
    B -->|Yes| C[Parse Mentions]
    B -->|No| D[Regular Message]
    
    C --> E{Mention Type}
    E -->|@username| F[User Mention]
    E -->|@all| G[Channel Mention]
    
    F --> H[Validate User IDs]
    G --> I[Validate Channel Access]
    
    H --> J[Create Mention Metadata]
    I --> J
    
    J --> K[Send Message with Mentions]
    K --> L[Push Notifications]
    
    L --> M{Notification Target}
    M -->|User Mention| N[Individual Users]
    M -->|Channel Mention| O[All Channel Members]
    
    N --> P[Delivery & Read Status]
    O --> P
```

## Supported Channel Types

<Callout type="info">
Mentions are currently supported in **Community** and **Live** channel types only.
</Callout>

<AccordionGroup>
  <Accordion title="Channel Type Compatibility" icon="list-check">
    | Channel Type | User Mentions | Channel Mentions | Push Notifications |
    |--------------|---------------|------------------|-------------------|
    | **Community** | ✅ Supported | ✅ Supported | ✅ Yes |
    | **Live** | ✅ Supported | ✅ Supported | ✅ Yes |
    | Conversation | ❌ Not supported | ❌ Not supported | ❌ No |
    | Broadcast | ❌ Not supported | ❌ Not supported | ❌ No |
  </Accordion>
  
  <Accordion title="Mention Limitations" icon="info-circle">
    - **User Mentions**: Maximum 30 users per message
    - **Push Notifications**: Individual notifications for user mentions
    - **Channel Mentions**: Notifies all channel members
    - **Update Behavior**: Updating mentions doesn't trigger new notifications
  </Accordion>
</AccordionGroup>

## User Mentions

Tag specific users in messages to send targeted notifications and create engaging conversations.

<Callout type="tip">
User mentions support up to 30 individual users per message, with each mentioned user receiving a push notification.
</Callout>

### Implementation Examples

<Tabs>
  <Tab title="iOS Swift">
    ```swift
    import AmitySDK
    
    class MentionMessageManager {
        private let messageRepository: AmityMessageRepository
        
        init() {
            self.messageRepository = AmityMessageRepository(client: AmityUIKitManagerInternal.shared.client)
        }
        
        func createMessageWithUserMentions(
            channelId: String,
            text: String,
            mentionedUserIds: [String],
            mentionMetadata: [MentionMetadata]
        ) {
            // Create mention users
            let mentionUsers = mentionedUserIds.map { userId in
                AmityMentionUser(userId: userId, type: .user)
            }
            
            // Prepare message data
            let messageData = AmityMessageTextData(text: text)
            
            // Create metadata for mention rendering
            let metadata = createMentionMetadata(mentions: mentionMetadata)
            
            // Create message with mentions
            messageRepository.createMessage(
                channelId: channelId,
                messageType: .text,
                data: messageData,
                mentionUsers: mentionUsers,
                metadata: metadata
            ) { [weak self] result in
                switch result {
                case .success(let message):
                    self?.handleMessageCreated(message)
                case .failure(let error):
                    self?.handleError(error)
                }
            }
        }
        
        private func createMentionMetadata(mentions: [MentionMetadata]) -> [String: Any] {
            let mentionData = mentions.map { mention in
                [
                    "type": "user",
                    "userId": mention.userId,
                    "index": mention.index,
                    "length": mention.length
                ]
            }
            
            return [
                "mentioned": mentionData
            ]
        }
        
        private func handleMessageCreated(_ message: AmityMessage) {
            print("Message with mentions created: \(message.messageId)")
            // Update UI, show success feedback
        }
        
        private func handleError(_ error: AmityError) {
            print("Failed to create message with mentions: \(error.localizedDescription)")
            // Show error message to user
        }
    }
    
    struct MentionMetadata {
        let userId: String
        let index: Int
        let length: Int
    }
    ```
  </Tab>
  
  <Tab title="Android Kotlin">
    ```kotlin
    import com.amity.socialcloud.sdk.api.chat.AmityMessageRepository
    import com.amity.socialcloud.sdk.model.chat.message.AmityMessage
    import com.amity.socialcloud.sdk.model.core.mention.AmityMentionMetadata
    
    class MentionMessageManager {
        private val messageRepository = AmityMessageRepository()
        
        fun createMessageWithUserMentions(
            channelId: String,
            text: String,
            mentionedUserIds: List<String>,
            mentionMetadata: List<MentionMetadata>
        ) {
            // Create mention users
            val mentionUsers = listOf(
                AmityMentionees.user(mentionedUserIds)
            )
            
            // Create metadata for rendering
            val metadata = createMentionMetadata(mentionMetadata)
            
            // Create message with mentions
            messageRepository.createTextMessage(channelId, text)
                .mentionUsers(mentionUsers)
                .metadata(metadata)
                .build()
                .subscribe(
                    { message ->
                        handleMessageCreated(message)
                    },
                    { error ->
                        handleError(error)
                    }
                )
        }
        
        private fun createMentionMetadata(mentions: List<MentionMetadata>): AmityMentionMetadata {
            val mentionData = mentions.map { mention ->
                mapOf(
                    "type" to "user",
                    "userId" to mention.userId,
                    "index" to mention.index,
                    "length" to mention.length
                )
            }
            
            return AmityMentionMetadata.Builder()
                .setMentioned(mentionData)
                .build()
        }
        
        private fun handleMessageCreated(message: AmityMessage) {
            Log.d("MentionMessage", "Message created: ${message.getMessageId()}")
            // Update UI
        }
        
        private fun handleError(error: Throwable) {
            Log.e("MentionMessage", "Error creating message with mentions", error)
            // Show error to user
        }
    }
    
    data class MentionMetadata(
        val userId: String,
        val index: Int,
        val length: Int
    )
    ```
  </Tab>
  
  <Tab title="JavaScript">
    ```javascript
    import { MentionType, MessageRepository, MessageTools } from '@amityco/js-sdk';
    
    class MentionMessageManager {
        async createMessageWithUserMentions({
            channelId,
            text,
            mentionedUserIds,
            mentionPositions
        }) {
            try {
                // Create mention metadata
                const mentionMetadata = this.createMentionMetadata(
                    mentionedUserIds,
                    mentionPositions
                );
                
                // Create message with user mentions
                const message = await MessageRepository.createTextMessage({
                    channelId,
                    text,
                    mentionees: [{
                        type: MentionType.User,
                        userIds: mentionedUserIds
                    }],
                    metadata: mentionMetadata
                });
                
                this.handleMessageCreated(message);
                return message;
                
            } catch (error) {
                this.handleError(error);
                throw error;
            }
        }
        
        createMentionMetadata(userIds, positions) {
            const mentions = userIds.map((userId, index) => ({
                type: MentionType.User,
                userId,
                index: positions[index].index,
                length: positions[index].length
            }));
            
            return MessageTools.createMentionMetadata(mentions);
        }
        
        handleMessageCreated(message) {
            console.log('Message with mentions created:', message.messageId);
            // Update UI, show success state
        }
        
        handleError(error) {
            console.error('Failed to create message with mentions:', error);
            // Show error message to user
        }
        
        // Helper method to parse mentions from text
        parseMentionsFromText(text) {
            const mentionRegex = /@(\w+)/g;
            const mentions = [];
            let match;
            
            while ((match = mentionRegex.exec(text)) !== null) {
                mentions.push({
                    username: match[1],
                    index: match.index,
                    length: match[0].length
                });
            }
            
            return mentions;
        }
    }
    ```
  </Tab>
  
  <Tab title="TypeScript">
    ```typescript
    import { 
        MentionType, 
        MessageRepository, 
        MessageTools,
        AmityMessage,
        CreateTextMessageRequest
    } from '@amityco/ts-sdk';
    
    interface MentionPosition {
        index: number;
        length: number;
    }
    
    interface UserMentionRequest {
        channelId: string;
        text: string;
        mentionedUserIds: string[];
        mentionPositions: MentionPosition[];
    }
    
    class MentionMessageManager {
        async createMessageWithUserMentions(
            request: UserMentionRequest
        ): Promise<AmityMessage> {
            try {
                const {
                    channelId,
                    text,
                    mentionedUserIds,
                    mentionPositions
                } = request;
                
                // Validate mention data
                this.validateMentionData(mentionedUserIds, mentionPositions);
                
                // Create mention metadata with type safety
                const mentionMetadata = this.createTypedMentionMetadata(
                    mentionedUserIds,
                    mentionPositions
                );
                
                // Prepare message request
                const messageRequest: CreateTextMessageRequest = {
                    channelId,
                    text,
                    mentionees: [{
                        type: MentionType.User,
                        userIds: mentionedUserIds
                    }],
                    metadata: mentionMetadata
                };
                
                const message = await MessageRepository.createTextMessage(messageRequest);
                
                this.handleMessageCreated(message);
                return message;
                
            } catch (error) {
                this.handleError(error as Error);
                throw error;
            }
        }
        
        private validateMentionData(
            userIds: string[],
            positions: MentionPosition[]
        ): void {
            if (userIds.length === 0) {
                throw new Error('At least one user ID is required for mentions');
            }
            
            if (userIds.length > 30) {
                throw new Error('Maximum 30 users can be mentioned per message');
            }
            
            if (userIds.length !== positions.length) {
                throw new Error('User IDs and positions arrays must have the same length');
            }
        }
        
        private createTypedMentionMetadata(
            userIds: string[],
            positions: MentionPosition[]
        ): ReturnType<typeof MessageTools.createMentionMetadata> {
            const mentions = userIds.map((userId, index) => ({
                type: MentionType.User,
                userId,
                index: positions[index].index,
                length: positions[index].length
            }));
            
            return MessageTools.createMentionMetadata(mentions);
        }
        
        private handleMessageCreated(message: AmityMessage): void {
            console.log(`Message created with ID: ${message.messageId}`);
            // Type-safe message handling
        }
        
        private handleError(error: Error): void {
            console.error('Mention message creation failed:', error.message);
            // Implement proper error handling
        }
    }
    ```
  </Tab>
  
  <Tab title="Flutter Dart">
    ```dart
    import 'package:amity_sdk/amity_sdk.dart';
    
    class MentionMessageManager {
        Future<AmityMessage> createMessageWithUserMentions({
            required String channelId,
            required String text,
            required List<String> mentionedUserIds,
            required List<MentionPosition> mentionPositions,
        }) async {
            try {
                // Validate mention data
                _validateMentionData(mentionedUserIds, mentionPositions);
                
                // Create mention users
                final mentionUsers = [
                    AmityMentionees.users(mentionedUserIds)
                ];
                
                // Create mention metadata
                final metadata = _createMentionMetadata(
                    mentionedUserIds,
                    mentionPositions,
                );
                
                // Create message with mentions
                final message = await AmitySocialClient.newMessageRepository()
                    .createTextMessage(
                        channelId: channelId,
                        text: text,
                        mentionUsers: mentionUsers,
                        metadata: metadata,
                    );
                
                _handleMessageCreated(message);
                return message;
                
            } catch (error) {
                _handleError(error);
                rethrow;
            }
        }
        
        void _validateMentionData(
            List<String> userIds,
            List<MentionPosition> positions,
        ) {
            if (userIds.isEmpty) {
                throw ArgumentError('At least one user ID is required');
            }
            
            if (userIds.length > 30) {
                throw ArgumentError('Maximum 30 users can be mentioned');
            }
            
            if (userIds.length != positions.length) {
                throw ArgumentError('User IDs and positions must have same length');
            }
        }
        
        Map<String, dynamic> _createMentionMetadata(
            List<String> userIds,
            List<MentionPosition> positions,
        ) {
            final mentions = List.generate(userIds.length, (index) => {
                'type': 'user',
                'userId': userIds[index],
                'index': positions[index].index,
                'length': positions[index].length,
            });
            
            return {
                'mentioned': mentions,
            };
        }
        
        void _handleMessageCreated(AmityMessage message) {
            print('Message with mentions created: ${message.messageId}');
            // Update UI
        }
        
        void _handleError(dynamic error) {
            print('Error creating message with mentions: $error');
            // Show error to user
        }
    }
    
    class MentionPosition {
        final int index;
        final int length;
        
        const MentionPosition({
            required this.index,
            required this.length,
        });
    }
    ```
  </Tab>
</Tabs>

## Channel Mentions

Notify all channel members at once using channel mentions (@all functionality).

<Callout type="warning">
Channel mentions will send push notifications to **all members** of the channel. Use sparingly to avoid notification fatigue.
</Callout>

### Channel Mention Implementation

<Tabs>
  <Tab title="iOS Swift">
    ```swift
    func createMessageWithChannelMention(
        channelId: String,
        text: String,
        mentionMetadata: [ChannelMentionMetadata]
    ) {
        // Create channel mention
        let mentionChannel = AmityMentionUser(type: .channel)
        
        // Prepare message data
        let messageData = AmityMessageTextData(text: text)
        
        // Create metadata for @all rendering
        let metadata = createChannelMentionMetadata(mentions: mentionMetadata)
        
        // Create message with channel mention
        messageRepository.createMessage(
            channelId: channelId,
            messageType: .text,
            data: messageData,
            mentionUsers: [mentionChannel],
            metadata: metadata
        ) { [weak self] result in
            switch result {
            case .success(let message):
                self?.handleChannelMentionCreated(message)
            case .failure(let error):
                self?.handleError(error)
            }
        }
    }
    
    private func createChannelMentionMetadata(mentions: [ChannelMentionMetadata]) -> [String: Any] {
        let mentionData = mentions.map { mention in
            [
                "type": "channel",
                "index": mention.index,
                "length": mention.length
            ]
        }
        
        return [
            "mentioned": mentionData
        ]
    }
    
    struct ChannelMentionMetadata {
        let index: Int
        let length: Int
    }
    ```
  </Tab>
  
  <Tab title="Android Kotlin">
    ```kotlin
    fun createMessageWithChannelMention(
        channelId: String,
        text: String,
        mentionPositions: List<ChannelMentionPosition>
    ) {
        // Create channel mention
        val mentionChannel = listOf(
            AmityMentionees.channel()
        )
        
        // Create metadata for @all rendering
        val metadata = createChannelMentionMetadata(mentionPositions)
        
        // Create message with channel mention
        messageRepository.createTextMessage(channelId, text)
            .mentionUsers(mentionChannel)
            .metadata(metadata)
            .build()
            .subscribe(
                { message ->
                    handleChannelMentionCreated(message)
                },
                { error ->
                    handleError(error)
                }
            )
    }
    
    private fun createChannelMentionMetadata(
        positions: List<ChannelMentionPosition>
    ): AmityMentionMetadata {
        val mentionData = positions.map { position ->
            mapOf(
                "type" to "channel",
                "index" to position.index,
                "length" to position.length
            )
        }
        
        return AmityMentionMetadata.Builder()
            .setMentioned(mentionData)
            .build()
    }
    
    data class ChannelMentionPosition(
        val index: Int,
        val length: Int
    )
    ```
  </Tab>
  
  <Tab title="JavaScript">
    ```javascript
    async createMessageWithChannelMention({
        channelId,
        text,
        mentionPositions
    }) {
        try {
            // Create mention metadata for @all
            const mentionMetadata = MessageTools.createMentionMetadata(
                mentionPositions.map(pos => ({
                    type: MentionType.Channel,
                    index: pos.index,
                    length: pos.length
                }))
            );
            
            // Create message with channel mention
            const message = await MessageRepository.createTextMessage({
                channelId,
                text,
                mentionees: [{
                    type: MentionType.Channel
                }],
                metadata: mentionMetadata
            });
            
            this.handleChannelMentionCreated(message);
            return message;
            
        } catch (error) {
            this.handleError(error);
            throw error;
        }
    }
    
    handleChannelMentionCreated(message) {
        console.log('Channel mention message created:', message.messageId);
        // Update UI, show that all members were notified
    }
    
    // Helper to parse @all mentions
    parseChannelMentions(text) {
        const channelMentionRegex = /@all/g;
        const mentions = [];
        let match;
        
        while ((match = channelMentionRegex.exec(text)) !== null) {
            mentions.push({
                index: match.index,
                length: match[0].length
            });
        }
        
        return mentions;
    }
    ```
  </Tab>
  
  <Tab title="TypeScript">
    ```typescript
    interface ChannelMentionRequest {
        channelId: string;
        text: string;
        mentionPositions: MentionPosition[];
    }
    
    async createMessageWithChannelMention(
        request: ChannelMentionRequest
    ): Promise<AmityMessage> {
        try {
            const { channelId, text, mentionPositions } = request;
            
            // Validate channel mention data
            this.validateChannelMentionData(text, mentionPositions);
            
            // Create mention metadata for @all
            const mentionMetadata = MessageTools.createMentionMetadata(
                mentionPositions.map(pos => ({
                    type: MentionType.Channel,
                    index: pos.index,
                    length: pos.length
                }))
            );
            
            // Create message with channel mention
            const messageRequest: CreateTextMessageRequest = {
                channelId,
                text,
                mentionees: [{
                    type: MentionType.Channel
                }],
                metadata: mentionMetadata
            };
            
            const message = await MessageRepository.createTextMessage(messageRequest);
            
            this.handleChannelMentionCreated(message);
            return message;
            
        } catch (error) {
            this.handleError(error as Error);
            throw error;
        }
    }
    
    private validateChannelMentionData(
        text: string,
        positions: MentionPosition[]
    ): void {
        if (!text.includes('@all')) {
            throw new Error('Text must contain @all for channel mentions');
        }
        
        if (positions.length === 0) {
            throw new Error('At least one mention position is required');
        }
    }
    
    private handleChannelMentionCreated(message: AmityMessage): void {
        console.log(`Channel mention message created: ${message.messageId}`);
        // Handle successful channel mention creation
    }
    ```
  </Tab>
  
  <Tab title="Flutter Dart">
    ```dart
    Future<AmityMessage> createMessageWithChannelMention({
        required String channelId,
        required String text,
        required List<MentionPosition> mentionPositions,
    }) async {
        try {
            // Validate channel mention data
            _validateChannelMentionData(text, mentionPositions);
            
            // Create channel mention
            final mentionChannel = [
                AmityMentionees.channel()
            ];
            
            // Create mention metadata for @all
            final metadata = _createChannelMentionMetadata(mentionPositions);
            
            // Create message with channel mention
            final message = await AmitySocialClient.newMessageRepository()
                .createTextMessage(
                    channelId: channelId,
                    text: text,
                    mentionUsers: mentionChannel,
                    metadata: metadata,
                );
            
            _handleChannelMentionCreated(message);
            return message;
            
        } catch (error) {
            _handleError(error);
            rethrow;
        }
    }
    
    void _validateChannelMentionData(
        String text,
        List<MentionPosition> positions,
    ) {
        if (!text.contains('@all')) {
            throw ArgumentError('Text must contain @all for channel mentions');
        }
        
        if (positions.isEmpty) {
            throw ArgumentError('At least one mention position is required');
        }
    }
    
    Map<String, dynamic> _createChannelMentionMetadata(
        List<MentionPosition> positions,
    ) {
        final mentions = positions.map((position) => {
            'type': 'channel',
            'index': position.index,
            'length': position.length,
        }).toList();
        
        return {
            'mentioned': mentions,
        };
    }
    
    void _handleChannelMentionCreated(AmityMessage message) {
        print('Channel mention message created: ${message.messageId}');
        // Update UI, show all members were notified
    }
    ```
  </Tab>
</Tabs>

## Updating Mentions

Modify mentions in existing messages without triggering new notifications.

<Callout type="important">
**Important**: Updating mentions in existing messages will **not** send new push notifications to the mentioned users.
</Callout>

<AccordionGroup>
  <Accordion title="Update Scenarios" icon="list">
    - **Add Mentions**: Include new user or channel mentions
    - **Remove Mentions**: Clear all mentions by passing empty arrays
    - **Modify Mentions**: Change which users are mentioned
    - **Update Positions**: Adjust mention positions after text changes
  </Accordion>
  
  <Accordion title="Removing Mentions" icon="eraser">
    To remove all mentions from a message:
    - Pass empty array `[]` for `mentionees`
    - Pass empty object `{}` for `metadata`
    - This preserves message structure while clearing mentions
  </Accordion>
</AccordionGroup>

### Update Implementation Examples

<Tabs>
  <Tab title="iOS Swift">
    ```swift
    func updateMessageWithMentions(
        messageId: String,
        newText: String,
        mentionedUserIds: [String],
        mentionMetadata: [MentionMetadata]
    ) {
        // Create updated mention users
        let mentionUsers = mentionedUserIds.map { userId in
            AmityMentionUser(userId: userId, type: .user)
        }
        
        // Create updated metadata
        let metadata = createMentionMetadata(mentions: mentionMetadata)
        
        // Update message with new mentions
        messageRepository.updateMessage(
            messageId: messageId,
            text: newText,
            mentionUsers: mentionUsers,
            metadata: metadata
        ) { [weak self] result in
            switch result {
            case .success(let message):
                self?.handleMessageUpdated(message)
            case .failure(let error):
                self?.handleError(error)
            }
        }
    }
    
    func removeMentionsFromMessage(messageId: String, newText: String) {
        // Remove all mentions by passing empty arrays
        messageRepository.updateMessage(
            messageId: messageId,
            text: newText,
            mentionUsers: [], // Empty array removes mentions
            metadata: [:]    // Empty metadata
        ) { [weak self] result in
            switch result {
            case .success(let message):
                self?.handleMentionsRemoved(message)
            case .failure(let error):
                self?.handleError(error)
            }
        }
    }
    
    private func handleMessageUpdated(_ message: AmityMessage) {
        print("Message mentions updated: \(message.messageId)")
        // Update UI with new mention display
    }
    
    private func handleMentionsRemoved(_ message: AmityMessage) {
        print("Mentions removed from message: \(message.messageId)")
        // Update UI to show plain text
    }
    ```
  </Tab>
  
  <Tab title="Android Kotlin">
    ```kotlin
    fun updateMessageWithMentions(
        messageId: String,
        newText: String,
        mentionedUserIds: List<String>,
        mentionMetadata: List<MentionMetadata>
    ) {
        // Create updated mention users
        val mentionUsers = if (mentionedUserIds.isNotEmpty()) {
            listOf(AmityMentionees.user(mentionedUserIds))
        } else {
            emptyList()
        }
        
        // Create updated metadata
        val metadata = if (mentionMetadata.isNotEmpty()) {
            createMentionMetadata(mentionMetadata)
        } else {
            AmityMentionMetadata.Builder().build() // Empty metadata
        }
        
        // Update message
        messageRepository.updateTextMessage(messageId, newText)
            .mentionUsers(mentionUsers)
            .metadata(metadata)
            .build()
            .subscribe(
                { message ->
                    handleMessageUpdated(message)
                },
                { error ->
                    handleError(error)
                }
            )
    }
    
    fun removeMentionsFromMessage(messageId: String, newText: String) {
        // Remove mentions by passing empty collections
        messageRepository.updateTextMessage(messageId, newText)
            .mentionUsers(emptyList())
            .metadata(AmityMentionMetadata.Builder().build())
            .build()
            .subscribe(
                { message ->
                    handleMentionsRemoved(message)
                },
                { error ->
                    handleError(error)
                }
            )
    }
    
    private fun handleMessageUpdated(message: AmityMessage) {
        Log.d("MentionUpdate", "Message mentions updated: ${message.getMessageId()}")
        // Update UI
    }
    
    private fun handleMentionsRemoved(message: AmityMessage) {
        Log.d("MentionUpdate", "Mentions removed: ${message.getMessageId()}")
        // Update UI to plain text display
    }
    ```
  </Tab>
  
  <Tab title="JavaScript">
    ```javascript
    async updateMessageWithMentions({
        messageId,
        newText,
        mentionedUserIds = [],
        mentionPositions = []
    }) {
        try {
            // Create updated mention data
            const mentionees = mentionedUserIds.length > 0 ? [{
                type: MentionType.User,
                userIds: mentionedUserIds
            }] : [];
            
            const metadata = mentionPositions.length > 0 
                ? this.createMentionMetadata(mentionedUserIds, mentionPositions)
                : {};
            
            // Update message with new mentions
            const message = await MessageRepository.updateMessage({
                messageId,
                data: { text: newText },
                mentionees,
                metadata
            });
            
            this.handleMessageUpdated(message);
            return message;
            
        } catch (error) {
            this.handleError(error);
            throw error;
        }
    }
    
    async removeMentionsFromMessage(messageId, newText) {
        try {
            // Remove mentions by passing empty arrays
            const message = await MessageRepository.updateMessage({
                messageId,
                data: { text: newText },
                mentionees: [],     // Empty array removes mentions
                metadata: {}        // Empty object removes metadata
            });
            
            this.handleMentionsRemoved(message);
            return message;
            
        } catch (error) {
            this.handleError(error);
            throw error;
        }
    }
    
    handleMessageUpdated(message) {
        console.log('Message mentions updated:', message.messageId);
        // Update UI with new mention styling
    }
    
    handleMentionsRemoved(message) {
        console.log('Mentions removed from message:', message.messageId);
        // Update UI to show plain text
    }
    ```
  </Tab>
  
  <Tab title="TypeScript">
    ```typescript
    interface UpdateMentionRequest {
        messageId: string;
        newText: string;
        mentionedUserIds?: string[];
        mentionPositions?: MentionPosition[];
    }
    
    async updateMessageWithMentions(
        request: UpdateMentionRequest
    ): Promise<AmityMessage> {
        try {
            const {
                messageId,
                newText,
                mentionedUserIds = [],
                mentionPositions = []
            } = request;
            
            // Validate update data
            this.validateUpdateData(newText, mentionedUserIds, mentionPositions);
            
            // Create mention data for update
            const mentionees = mentionedUserIds.length > 0 ? [{
                type: MentionType.User,
                userIds: mentionedUserIds
            }] : [];
            
            const metadata = mentionPositions.length > 0 
                ? this.createTypedMentionMetadata(mentionedUserIds, mentionPositions)
                : {};
            
            // Update message
            const message = await MessageRepository.updateMessage({
                messageId,
                data: { text: newText },
                mentionees,
                metadata
            });
            
            this.handleMessageUpdated(message);
            return message;
            
        } catch (error) {
            this.handleError(error as Error);
            throw error;
        }
    }
    
    async removeMentionsFromMessage(
        messageId: string,
        newText: string
    ): Promise<AmityMessage> {
        try {
            const message = await MessageRepository.updateMessage({
                messageId,
                data: { text: newText },
                mentionees: [],
                metadata: {}
            });
            
            this.handleMentionsRemoved(message);
            return message;
            
        } catch (error) {
            this.handleError(error as Error);
            throw error;
        }
    }
    
    private validateUpdateData(
        text: string,
        userIds: string[],
        positions: MentionPosition[]
    ): void {
        if (userIds.length !== positions.length) {
            throw new Error('User IDs and positions must have same length');
        }
        
        if (userIds.length > 30) {
            throw new Error('Cannot mention more than 30 users');
        }
    }
    
    private handleMessageUpdated(message: AmityMessage): void {
        console.log(`Message ${message.messageId} mentions updated`);
        // Handle successful update
    }
    
    private handleMentionsRemoved(message: AmityMessage): void {
        console.log(`Mentions removed from message ${message.messageId}`);
        // Handle successful mention removal
    }
    ```
  </Tab>
  
  <Tab title="Flutter Dart">
    ```dart
    Future<AmityMessage> updateMessageWithMentions({
        required String messageId,
        required String newText,
        List<String> mentionedUserIds = const [],
        List<MentionPosition> mentionPositions = const [],
    }) async {
        try {
            // Validate update data
            _validateUpdateData(newText, mentionedUserIds, mentionPositions);
            
            // Create mention data for update
            final mentionUsers = mentionedUserIds.isNotEmpty
                ? [AmityMentionees.users(mentionedUserIds)]
                : <AmityMentionees>[];
            
            final metadata = mentionPositions.isNotEmpty
                ? _createMentionMetadata(mentionedUserIds, mentionPositions)
                : <String, dynamic>{};
            
            // Update message
            final message = await AmitySocialClient.newMessageRepository()
                .updateTextMessage(
                    messageId: messageId,
                    text: newText,
                    mentionUsers: mentionUsers,
                    metadata: metadata,
                );
            
            _handleMessageUpdated(message);
            return message;
            
        } catch (error) {
            _handleError(error);
            rethrow;
        }
    }
    
    Future<AmityMessage> removeMentionsFromMessage({
        required String messageId,
        required String newText,
    }) async {
        try {
            // Remove mentions by passing empty collections
            final message = await AmitySocialClient.newMessageRepository()
                .updateTextMessage(
                    messageId: messageId,
                    text: newText,
                    mentionUsers: <AmityMentionees>[],
                    metadata: <String, dynamic>{},
                );
            
            _handleMentionsRemoved(message);
            return message;
            
        } catch (error) {
            _handleError(error);
            rethrow;
        }
    }
    
    void _validateUpdateData(
        String text,
        List<String> userIds,
        List<MentionPosition> positions,
    ) {
        if (userIds.length != positions.length) {
            throw ArgumentError('User IDs and positions must have same length');
        }
        
        if (userIds.length > 30) {
            throw ArgumentError('Cannot mention more than 30 users');
        }
    }
    
    void _handleMessageUpdated(AmityMessage message) {
        print('Message mentions updated: ${message.messageId}');
        // Update UI
    }
    
    void _handleMentionsRemoved(AmityMessage message) {
        print('Mentions removed from message: ${message.messageId}');
        // Update UI to plain text
    }
    ```
  </Tab>
</Tabs>

## Mention Rendering

Implement custom mention rendering to provide rich visual feedback and interaction capabilities.

<Callout type="tip">
For detailed mention rendering implementation, refer to the [Mentions Overview](../../core-concepts/content-handling/mentions) documentation.
</Callout>

<AccordionGroup>
  <Accordion title="Mention Rendering Components" icon="paintbrush">
    <CardGroup cols={2}>
      <Card title="Mention Styling" icon="palette">
        Custom colors, fonts, and background for mentions
      </Card>
      <Card title="Click Handling" icon="hand-pointer">
        Handle user interactions with mention elements
      </Card>
      <Card title="User Profiles" icon="user-circle">
        Show user info on mention hover/tap
      </Card>
      <Card title="Accessibility" icon="universal-access">
        Screen reader support and keyboard navigation
      </Card>
    </CardGroup>
  </Accordion>
  
  <Accordion title="Metadata Structure" icon="code">
    ```json
    {
      "mentioned": [
        {
          "type": "user",
          "userId": "user123",
          "index": 3,
          "length": 8
        },
        {
          "type": "channel",
          "index": 15,
          "length": 4
        }
      ]
    }
    ```
  </Accordion>
</AccordionGroup>

### Mention Rendering Examples

<Tabs>
  <Tab title="iOS Swift">
    ```swift
    import UIKit
    
    class MentionRenderer {
        func renderMessageWithMentions(
            message: AmityMessage,
            in textView: UITextView
        ) {
            guard let text = message.data?.text,
                  let metadata = message.metadata else {
                textView.text = message.data?.text
                return
            }
            
            let attributedString = NSMutableAttributedString(string: text)
            
            // Extract mention data from metadata
            if let mentionData = metadata["mentioned"] as? [[String: Any]] {
                for mention in mentionData {
                    self.applyMentionStyling(
                        to: attributedString,
                        mention: mention
                    )
                }
            }
            
            textView.attributedText = attributedString
        }
        
        private func applyMentionStyling(
            to attributedString: NSMutableAttributedString,
            mention: [String: Any]
        ) {
            guard let index = mention["index"] as? Int,
                  let length = mention["length"] as? Int,
                  let type = mention["type"] as? String else { return }
            
            let range = NSRange(location: index, length: length)
            
            // Apply mention styling
            attributedString.addAttribute(
                .foregroundColor,
                value: UIColor.systemBlue,
                range: range
            )
            
            attributedString.addAttribute(
                .backgroundColor,
                value: UIColor.systemBlue.withAlphaComponent(0.1),
                range: range
            )
            
            // Add tap gesture handling
            if type == "user", let userId = mention["userId"] as? String {
                attributedString.addAttribute(
                    .link,
                    value: "mention://user/\(userId)",
                    range: range
                )
            } else if type == "channel" {
                attributedString.addAttribute(
                    .link,
                    value: "mention://channel/all",
                    range: range
                )
            }
        }
    }
    ```
  </Tab>
  
  <Tab title="Android Kotlin">
    ```kotlin
    import android.text.SpannableStringBuilder
    import android.text.Spanned
    import android.text.style.ClickableSpan
    import android.text.style.BackgroundColorSpan
    import android.text.style.ForegroundColorSpan
    
    class MentionRenderer {
        fun renderMessageWithMentions(
            message: AmityMessage,
            textView: TextView
        ) {
            val text = message.getData()?.getText() ?: return
            val metadata = message.getMetadata()
            
            val spannableBuilder = SpannableStringBuilder(text)
            
            // Extract and render mentions
            metadata?.get("mentioned")?.let { mentionData ->
                if (mentionData is List<*>) {
                    mentionData.forEach { mention ->
                        if (mention is Map<*, *>) {
                            applyMentionSpan(spannableBuilder, mention)
                        }
                    }
                }
            }
            
            textView.text = spannableBuilder
            textView.movementMethod = LinkMovementMethod.getInstance()
        }
        
        private fun applyMentionSpan(
            spannableBuilder: SpannableStringBuilder,
            mention: Map<*, *>
        ) {
            val index = mention["index"] as? Int ?: return
            val length = mention["length"] as? Int ?: return
            val type = mention["type"] as? String ?: return
            
            val start = index
            val end = index + length
            
            // Apply styling
            spannableBuilder.setSpan(
                ForegroundColorSpan(Color.BLUE),
                start, end,
                Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
            )
            
            spannableBuilder.setSpan(
                BackgroundColorSpan(Color.LTGRAY),
                start, end,
                Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
            )
            
            // Add click handling
            val clickableSpan = when (type) {
                "user" -> {
                    val userId = mention["userId"] as? String
                    createUserMentionClickSpan(userId)
                }
                "channel" -> createChannelMentionClickSpan()
                else -> null
            }
            
            clickableSpan?.let {
                spannableBuilder.setSpan(
                    it,
                    start, end,
                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                )
            }
        }
        
        private fun createUserMentionClickSpan(userId: String?) = object : ClickableSpan() {
            override fun onClick(widget: View) {
                // Handle user mention click
                userId?.let { onUserMentionClicked(it) }
            }
        }
        
        private fun createChannelMentionClickSpan() = object : ClickableSpan() {
            override fun onClick(widget: View) {
                // Handle channel mention click
                onChannelMentionClicked()
            }
        }
    }
    ```
  </Tab>
  
  <Tab title="React TypeScript">
    ```typescript
    import React from 'react';
    import { AmityMessage } from '@amityco/ts-sdk';
    
    interface MentionProps {
        type: 'user' | 'channel';
        userId?: string;
        text: string;
        onUserClick?: (userId: string) => void;
        onChannelClick?: () => void;
    }
    
    const MentionComponent: React.FC<MentionProps> = ({
        type,
        userId,
        text,
        onUserClick,
        onChannelClick
    }) => {
        const handleClick = () => {
            if (type === 'user' && userId && onUserClick) {
                onUserClick(userId);
            } else if (type === 'channel' && onChannelClick) {
                onChannelClick();
            }
        };
        
        return (
            <span
                className={`mention mention-${type}`}
                onClick={handleClick}
                style={{
                    color: '#007bff',
                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                    padding: '2px 4px',
                    borderRadius: '3px',
                    cursor: 'pointer'
                }}
            >
                {text}
            </span>
        );
    };
    
    interface MessageWithMentionsProps {
        message: AmityMessage;
        onUserMentionClick?: (userId: string) => void;
        onChannelMentionClick?: () => void;
    }
    
    const MessageWithMentions: React.FC<MessageWithMentionsProps> = ({
        message,
        onUserMentionClick,
        onChannelMentionClick
    }) => {
        const renderMessageWithMentions = () => {
            const text = message.data?.text || '';
            const metadata = message.metadata;
            
            if (!metadata?.mentioned) {
                return <span>{text}</span>;
            }
            
            const mentions = metadata.mentioned as Array<{
                type: string;
                userId?: string;
                index: number;
                length: number;
            }>;
            
            // Sort mentions by index for proper rendering
            const sortedMentions = [...mentions].sort((a, b) => a.index - b.index);
            
            const elements: React.ReactNode[] = [];
            let lastIndex = 0;
            
            sortedMentions.forEach((mention, i) => {
                // Add text before mention
                if (mention.index > lastIndex) {
                    elements.push(
                        <span key={`text-${i}`}>
                            {text.substring(lastIndex, mention.index)}
                        </span>
                    );
                }
                
                // Add mention component
                const mentionText = text.substring(
                    mention.index,
                    mention.index + mention.length
                );
                
                elements.push(
                    <MentionComponent
                        key={`mention-${i}`}
                        type={mention.type as 'user' | 'channel'}
                        userId={mention.userId}
                        text={mentionText}
                        onUserClick={onUserMentionClick}
                        onChannelClick={onChannelMentionClick}
                    />
                );
                
                lastIndex = mention.index + mention.length;
            });
            
            // Add remaining text
            if (lastIndex < text.length) {
                elements.push(
                    <span key="text-end">
                        {text.substring(lastIndex)}
                    </span>
                );
            }
            
            return <>{elements}</>;
        };
        
        return (
            <div className="message-with-mentions">
                {renderMessageWithMentions()}
            </div>
        );
    };
    ```
  </Tab>
  
  <Tab title="Flutter Dart">
    ```dart
    import 'package:flutter/material.dart';
    import 'package:flutter/gestures.dart';
    
    class MentionRenderer {
        Widget renderMessageWithMentions({
            required AmityMessage message,
            Function(String)? onUserMentionTap,
            VoidCallback? onChannelMentionTap,
        }) {
            final text = message.data?.text ?? '';
            final metadata = message.metadata;
            
            if (metadata == null || metadata['mentioned'] == null) {
                return Text(text);
            }
            
            return RichText(
                text: _buildTextSpanWithMentions(
                    text,
                    metadata['mentioned'] as List<dynamic>,
                    onUserMentionTap,
                    onChannelMentionTap,
                ),
            );
        }
        
        TextSpan _buildTextSpanWithMentions(
            String text,
            List<dynamic> mentions,
            Function(String)? onUserMentionTap,
            VoidCallback? onChannelMentionTap,
        ) {
            final List<TextSpan> spans = [];
            
            // Sort mentions by index
            final sortedMentions = List<Map<String, dynamic>>.from(mentions)
                ..sort((a, b) => (a['index'] as int).compareTo(b['index'] as int));
            
            int lastIndex = 0;
            
            for (final mention in sortedMentions) {
                final int index = mention['index'] as int;
                final int length = mention['length'] as int;
                final String type = mention['type'] as String;
                
                // Add text before mention
                if (index > lastIndex) {
                    spans.add(TextSpan(
                        text: text.substring(lastIndex, index),
                        style: const TextStyle(color: Colors.black),
                    ));
                }
                
                // Add mention span
                final mentionText = text.substring(index, index + length);
                spans.add(TextSpan(
                    text: mentionText,
                    style: const TextStyle(
                        color: Colors.blue,
                        backgroundColor: Color(0x1A0075FF),
                        fontWeight: FontWeight.w500,
                    ),
                    recognizer: TapGestureRecognizer()
                        ..onTap = () => _handleMentionTap(
                            type,
                            mention['userId'] as String?,
                            onUserMentionTap,
                            onChannelMentionTap,
                        ),
                ));
                
                lastIndex = index + length;
            }
            
            // Add remaining text
            if (lastIndex < text.length) {
                spans.add(TextSpan(
                    text: text.substring(lastIndex),
                    style: const TextStyle(color: Colors.black),
                ));
            }
            
            return TextSpan(children: spans);
        }
        
        void _handleMentionTap(
            String type,
            String? userId,
            Function(String)? onUserMentionTap,
            VoidCallback? onChannelMentionTap,
        ) {
            if (type == 'user' && userId != null && onUserMentionTap != null) {
                onUserMentionTap(userId);
            } else if (type == 'channel' && onChannelMentionTap != null) {
                onChannelMentionTap();
            }
        }
    }
    ```
  </Tab>
</Tabs>

## Unread Mention Status

Track unread mentions to provide users with notification indicators and mention-specific read states.

<AccordionGroup>
  <Accordion title="Mention Read Status" icon="envelope">
    The `hasMention` property in the `Channel` class indicates whether a channel has unread messages containing mentions:
    
    - **`true`**: Channel has unread messages with mentions
    - **`false`**: No unread mentions in the channel
    - **Updates**: Property updates when messages are read or new mentions arrive
  </Accordion>
  
  <Accordion title="Implementation Examples" icon="code">
    ```typescript
    // Check for unread mentions
    if (channel.hasMention) {
        // Show mention indicator in UI
        showMentionBadge();
        
        // Get unread count with mentions
        const unreadCount = channel.unreadCount;
        updateMentionNotification(unreadCount);
    }
    
    // Listen for mention status changes
    channel.on('mentionStatusChanged', (hasMention: boolean) => {
        updateMentionIndicator(hasMention);
    });
    ```
  </Accordion>
</AccordionGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="User Experience Guidelines" icon="star">
    - **Visual Distinction**: Make mentions visually distinct with color and background
    - **Interactive Feedback**: Provide hover/tap states for mention elements
    - **Accessibility**: Include proper ARIA labels and keyboard navigation
    - **Performance**: Efficiently parse and render mentions in large messages
    
    ```css
    .mention {
        color: #007bff;
        background-color: rgba(0, 123, 255, 0.1);
        padding: 2px 4px;
        border-radius: 3px;
        cursor: pointer;
        transition: background-color 0.2s ease;
    }
    
    .mention:hover {
        background-color: rgba(0, 123, 255, 0.2);
    }
    ```
  </Accordion>
  
  <Accordion title="Performance Optimization" icon="gauge-high">
    - **Lazy Parsing**: Parse mentions only when rendering messages
    - **Caching**: Cache parsed mention data for frequently viewed messages
    - **Debounced Updates**: Batch mention updates to avoid excessive re-renders
    - **Memory Management**: Clean up mention event listeners properly
    
    ```javascript
    class MentionCache {
        private cache = new Map();
        
        getParsedMentions(messageId: string, text: string) {
            if (this.cache.has(messageId)) {
                return this.cache.get(messageId);
            }
            
            const mentions = this.parseMentions(text);
            this.cache.set(messageId, mentions);
            return mentions;
        }
    }
    ```
  </Accordion>
  
  <Accordion title="Error Handling" icon="shield-exclamation">
    - **Invalid User IDs**: Handle mentions of non-existent users gracefully
    - **Permission Errors**: Show appropriate errors for unauthorized mentions
    - **Network Failures**: Implement retry logic for mention operations
    - **Malformed Metadata**: Validate mention metadata before processing
    
    ```typescript
    try {
        await createMessageWithMentions(messageData);
    } catch (error) {
        if (error.code === 'INVALID_USER_ID') {
            showError('Some mentioned users could not be found');
        } else if (error.code === 'PERMISSION_DENIED') {
            showError('You cannot mention users in this channel');
        } else {
            showError('Failed to send message with mentions');
        }
    }
    ```
  </Accordion>
  
  <Accordion title="Security Considerations" icon="lock">
    - **Input Validation**: Sanitize mention data to prevent XSS attacks
    - **Permission Checks**: Verify user can mention others in the channel
    - **Rate Limiting**: Prevent mention spam with appropriate limits
    - **Content Moderation**: Filter mentions in moderated channels
    
    ```typescript
    function validateMentionInput(text: string, userIds: string[]): boolean {
        // Sanitize text input
        const sanitizedText = sanitizeHtml(text);
        
        // Validate user IDs format
        const validUserIds = userIds.every(id => isValidUserId(id));
        
        // Check mention limits
        const withinLimits = userIds.length <= 30;
        
        return sanitizedText === text && validUserIds && withinLimits;
    }
    ```
  </Accordion>
</AccordionGroup>

## Advanced Features

<CardGroup cols={2}>
  <Card
    title="Mention Auto-completion"
    icon="magic-wand-sparkles"
    href="#mention-autocomplete"
  >
    Implement typeahead search for user mentions
  </Card>
  <Card
    title="Mention Analytics"
    icon="chart-line"
    href="#mention-analytics"
  >
    Track mention usage and engagement metrics
  </Card>
  <Card
    title="Custom Mention Types"
    icon="wrench"
    href="#custom-mentions"
  >
    Implement custom mention behaviors and styling
  </Card>
  <Card
    title="Mention Notifications"
    icon="bell"
    href="#mention-notifications"
  >
    Advanced notification handling for mentions
  </Card>
</CardGroup>

### Mention Auto-completion

```typescript
class MentionAutocomplete {
    private userRepository: UserRepository;
    private debounceTimer: NodeJS.Timeout | null = null;
    
    searchUsers(query: string, channelId: string): Promise<User[]> {
        return new Promise((resolve) => {
            if (this.debounceTimer) {
                clearTimeout(this.debounceTimer);
            }
            
            this.debounceTimer = setTimeout(async () => {
                try {
                    const users = await this.userRepository.searchChannelMembers({
                        channelId,
                        query,
                        limit: 10
                    });
                    resolve(users);
                } catch (error) {
                    console.error('User search failed:', error);
                    resolve([]);
                }
            }, 300);
        });
    }
    
    handleMentionInput(text: string, cursorPosition: number) {
        const mentionMatch = this.extractMentionQuery(text, cursorPosition);
        
        if (mentionMatch) {
            return this.searchUsers(mentionMatch.query, mentionMatch.channelId);
        }
        
        return Promise.resolve([]);
    }
}
```

## Related Documentation

<CardGroup cols={2}>
  <Card
    title="Mentions Overview"
    icon="at"
    href="../../core-concepts/content-handling/mentions"
  >
    Comprehensive guide to mention implementation
  </Card>
  <Card
    title="Push Notifications"
    icon="bell"
    href="../../core-concepts/realtime-communication/push-notifications"
  >
    Configure mention-triggered notifications
  </Card>
  <Card
    title="Message Creation"
    icon="message"
    href="./create-and-send-a-message"
  >
    Basic message creation and sending
  </Card>
  <Card
    title="Content Moderation"
    icon="shield"
    href="../../chat/moderation-safety/content-moderation/overview"
  >
    Moderate mentions and prevent abuse
  </Card>
</CardGroup>