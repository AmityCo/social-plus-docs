---
title: "Channel Unread Count"
description: "Track and display unread message counts for channels with real-time updates and mention status"
---

# Channel Unread Count

Monitor unread message counts for individual channels and across all channels, providing users with clear visibility into pending conversations and mentions.

<CardGroup cols={2}>
  <Card title="Channel Tracking" icon="eye">
    Track unread counts for individual channels in real-time
  </Card>
  <Card title="Total Overview" icon="list">
    Get aggregated unread counts across all channels
  </Card>
  <Card title="Mention Status" icon="at">
    Monitor when users are mentioned in conversations
  </Card>
  <Card title="Real-time Updates" icon="bolt">
    Automatic updates when new messages arrive
  </Card>
</CardGroup>

## Overview

Channel unread count provides essential engagement metrics that help users prioritize their conversations and stay informed about new activity. The system tracks both individual channel counts and global aggregated counts.

### Key Features
- **Individual Channel Counts**: Track unread messages per channel
- **Total Aggregated Count**: Get total unread across all channels
- **Mention Detection**: Special handling for messages that mention users
- **Real-time Updates**: Automatic count updates as messages arrive
- **Cached Performance**: Efficient counting from cached channel data

## Channel Unread Count

### Get Individual Channel Count

Retrieve the unread count for a specific channel:

<Tabs>
  <Tab title="iOS">
    ```swift
    import AmitySDK

    class ChannelUnreadManager {
        private let channelRepository = AmityChannelRepository(client: AmityUIKitManager.client)
        
        func observeChannelUnreadCount(channelId: String) {
            let liveObject = channelRepository.getChannel(channelId)
            
            liveObject.observe { [weak self] channel, error in
                if let error = error {
                    print("Error observing channel: \(error)")
                    return
                }
                
                guard let channel = channel else { return }
                
                // Get unread count
                let unreadCount = channel.unreadCount
                let isMentioned = channel.isMentioned
                let hasUnread = unreadCount > 0
                
                print("Channel \(channel.displayName): \(unreadCount) unread messages")
                if isMentioned {
                    print("You have unread mentions in this channel")
                }
                
                // Update UI
                DispatchQueue.main.async {
                    self?.updateChannelBadge(
                        channelId: channelId,
                        unreadCount: unreadCount,
                        isMentioned: isMentioned,
                        hasUnread: hasUnread
                    )
                }
            }
        }
        
        func getChannelUnreadCount(channel: AmityChannel) -> (count: Int, isMentioned: Bool) {
            return (count: channel.unreadCount, isMentioned: channel.isMentioned)
        }
        
        private func updateChannelBadge(
            channelId: String,
            unreadCount: Int,
            isMentioned: Bool,
            hasUnread: Bool
        ) {
            // Update your UI elements here
            let badgeText = unreadCount > 99 ? "99+" : "\(unreadCount)"
            
            // Example: Update chat list item
            if let chatItem = getChatListItem(for: channelId) {
                chatItem.unreadBadge.text = hasUnread ? badgeText : ""
                chatItem.unreadBadge.isHidden = !hasUnread
                chatItem.mentionIndicator.isHidden = !isMentioned
                
                // Highlight mentioned channels
                chatItem.backgroundColor = isMentioned ? 
                    UIColor.systemBlue.withAlphaComponent(0.1) : 
                    UIColor.systemBackground
            }
        }
        
        private func getChatListItem(for channelId: String) -> ChatListItemView? {
            // Return your actual chat list item view
            return nil
        }
    }

    // Usage example
    let unreadManager = ChannelUnreadManager()
    unreadManager.observeChannelUnreadCount(channelId: "general-chat")
    ```
  </Tab>

  <Tab title="Android">
    ```kotlin
    import com.amity.socialcloud.sdk.AmityCoreClient
    import com.amity.socialcloud.sdk.chat.channel.AmityChannelRepository
    import io.reactivex.android.schedulers.AndroidSchedulers
    import io.reactivex.schedulers.Schedulers

    class ChannelUnreadManager {
        private val channelRepository = AmityCoreClient.newChannelRepository()
        
        fun observeChannelUnreadCount(channelId: String) {
            channelRepository.getChannel(channelId)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                    { channel ->
                        // Get unread count and mention status
                        val unreadCount = channel.unreadCount
                        val isMentioned = channel.isMentioned
                        val hasUnread = unreadCount > 0
                        
                        println("Channel ${channel.displayName}: $unreadCount unread messages")
                        if (isMentioned) {
                            println("You have unread mentions in this channel")
                        }
                        
                        // Update UI
                        updateChannelBadge(
                            channelId = channelId,
                            unreadCount = unreadCount,
                            isMentioned = isMentioned,
                            hasUnread = hasUnread
                        )
                    },
                    { error ->
                        println("Error observing channel: $error")
                    }
                )
        }
        
        fun getChannelUnreadCount(channel: AmityChannel): Pair<Int, Boolean> {
            return Pair(channel.unreadCount, channel.isMentioned)
        }
        
        private fun updateChannelBadge(
            channelId: String,
            unreadCount: Int,
            isMentioned: Boolean,
            hasUnread: Boolean
        ) {
            // Update your UI elements here
            val badgeText = if (unreadCount > 99) "99+" else unreadCount.toString()
            
            // Example: Update RecyclerView item
            getChatListItem(channelId)?.let { chatItem ->
                chatItem.unreadBadge.text = if (hasUnread) badgeText else ""
                chatItem.unreadBadge.visibility = if (hasUnread) View.VISIBLE else View.GONE
                chatItem.mentionIndicator.visibility = if (isMentioned) View.VISIBLE else View.GONE
                
                // Highlight mentioned channels
                chatItem.background = if (isMentioned) {
                    ContextCompat.getDrawable(context, R.drawable.mentioned_channel_background)
                } else {
                    ContextCompat.getDrawable(context, R.drawable.normal_channel_background)
                }
            }
        }
        
        private fun getChatListItem(channelId: String): ChatListItemView? {
            // Return your actual chat list item view
            return null
        }
    }

    // Usage example
    val unreadManager = ChannelUnreadManager()
    unreadManager.observeChannelUnreadCount("general-chat")
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    import { ChannelRepository } from '@amityco/ts-sdk';

    class ChannelUnreadManager {
        constructor() {
            this.channelRepository = ChannelRepository;
        }
        
        observeChannelUnreadCount(channelId) {
            const liveObject = this.channelRepository.getChannel(channelId);
            
            liveObject.on('dataUpdated', (channel) => {
                // Get unread count and mention status
                const unreadCount = channel.unreadCount || 0;
                const isMentioned = channel.isMentioned || false;
                const hasUnread = unreadCount > 0;
                
                console.log(`Channel ${channel.displayName}: ${unreadCount} unread messages`);
                if (isMentioned) {
                    console.log('You have unread mentions in this channel');
                }
                
                // Update UI
                this.updateChannelBadge({
                    channelId,
                    unreadCount,
                    isMentioned,
                    hasUnread
                });
            });
            
            liveObject.on('dataError', (error) => {
                console.error('Error observing channel:', error);
            });
        }
        
        getChannelUnreadCount(channel) {
            return {
                count: channel.unreadCount || 0,
                isMentioned: channel.isMentioned || false
            };
        }
        
        updateChannelBadge({ channelId, unreadCount, isMentioned, hasUnread }) {
            // Update your UI elements here
            const badgeText = unreadCount > 99 ? '99+' : unreadCount.toString();
            
            // Example: Update DOM elements
            const chatItem = document.querySelector(`[data-channel-id="${channelId}"]`);
            if (chatItem) {
                const unreadBadge = chatItem.querySelector('.unread-badge');
                const mentionIndicator = chatItem.querySelector('.mention-indicator');
                
                if (unreadBadge) {
                    unreadBadge.textContent = hasUnread ? badgeText : '';
                    unreadBadge.style.display = hasUnread ? 'block' : 'none';
                }
                
                if (mentionIndicator) {
                    mentionIndicator.style.display = isMentioned ? 'block' : 'none';
                }
                
                // Highlight mentioned channels
                chatItem.classList.toggle('mentioned', isMentioned);
            }
        }
    }

    // Usage example
    const unreadManager = new ChannelUnreadManager();
    unreadManager.observeChannelUnreadCount('general-chat');
    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    import { ChannelRepository, AmityChannel, AmityLiveObject } from '@amityco/ts-sdk';

    interface UnreadStatus {
        count: number;
        isMentioned: boolean;
    }

    class ChannelUnreadManager {
        private channelRepository = ChannelRepository;
        
        observeChannelUnreadCount(channelId: string): void {
            const liveObject: AmityLiveObject<AmityChannel> = this.channelRepository.getChannel(channelId);
            
            liveObject.on('dataUpdated', (channel: AmityChannel) => {
                // Get unread count and mention status
                const unreadCount = channel.unreadCount || 0;
                const isMentioned = channel.isMentioned || false;
                const hasUnread = unreadCount > 0;
                
                console.log(`Channel ${channel.displayName}: ${unreadCount} unread messages`);
                if (isMentioned) {
                    console.log('You have unread mentions in this channel');
                }
                
                // Update UI
                this.updateChannelBadge({
                    channelId,
                    unreadCount,
                    isMentioned,
                    hasUnread
                });
            });
            
            liveObject.on('dataError', (error: Error) => {
                console.error('Error observing channel:', error);
            });
        }
        
        getChannelUnreadCount(channel: AmityChannel): UnreadStatus {
            return {
                count: channel.unreadCount || 0,
                isMentioned: channel.isMentioned || false
            };
        }
        
        private updateChannelBadge(data: {
            channelId: string;
            unreadCount: number;
            isMentioned: boolean;
            hasUnread: boolean;
        }): void {
            // Update your UI elements here
            const badgeText = data.unreadCount > 99 ? '99+' : data.unreadCount.toString();
            
            // Example: Update DOM elements
            const chatItem = document.querySelector(`[data-channel-id="${data.channelId}"]`);
            if (chatItem) {
                const unreadBadge = chatItem.querySelector('.unread-badge') as HTMLElement;
                const mentionIndicator = chatItem.querySelector('.mention-indicator') as HTMLElement;
                
                if (unreadBadge) {
                    unreadBadge.textContent = data.hasUnread ? badgeText : '';
                    unreadBadge.style.display = data.hasUnread ? 'block' : 'none';
                }
                
                if (mentionIndicator) {
                    mentionIndicator.style.display = data.isMentioned ? 'block' : 'none';
                }
                
                // Highlight mentioned channels
                chatItem.classList.toggle('mentioned', data.isMentioned);
            }
            
            // Emit custom event for framework integration
            const event = new CustomEvent('channelUnreadUpdated', { 
                detail: data 
            });
            document.dispatchEvent(event);
        }
    }

    // Usage example
    const unreadManager = new ChannelUnreadManager();
    unreadManager.observeChannelUnreadCount('general-chat');
    ```
  </Tab>

  <Tab title="Flutter">
    ```dart
    import 'package:amity_sdk/amity_sdk.dart';

    class ChannelUnreadManager {
      void observeChannelUnreadCount(String channelId) {
        try {
          final liveObject = AmitySocialClient.newChannelRepository()
              .getChannel(channelId);
          
          liveObject.stream.listen(
            (channel) {
              // Get unread count and mention status
              final unreadCount = channel.unreadCount ?? 0;
              final isMentioned = channel.isMentioned ?? false;
              final hasUnread = unreadCount > 0;
              
              print('Channel ${channel.displayName}: $unreadCount unread messages');
              if (isMentioned) {
                print('You have unread mentions in this channel');
              }
              
              // Update UI
              _updateChannelBadge(
                channelId: channelId,
                unreadCount: unreadCount,
                isMentioned: isMentioned,
                hasUnread: hasUnread,
              );
            },
            onError: (error) {
              print('Error observing channel: $error');
            },
          );
        } catch (error) {
          print('Failed to observe channel unread count: $error');
        }
      }
      
      UnreadStatus getChannelUnreadCount(AmityChannel channel) {
        return UnreadStatus(
          count: channel.unreadCount ?? 0,
          isMentioned: channel.isMentioned ?? false,
        );
      }
      
      void _updateChannelBadge({
        required String channelId,
        required int unreadCount,
        required bool isMentioned,
        required bool hasUnread,
      }) {
        // Update your UI elements here
        final badgeText = unreadCount > 99 ? '99+' : unreadCount.toString();
        
        // Example: Update state management (Provider, BLoC, Riverpod, etc.)
        // This would trigger UI rebuilds in your chat list
        print('Updating badge for $channelId: $badgeText (mentioned: $isMentioned)');
        
        // Emit event or update state management
        _notifyUnreadCountChanged(UnreadUpdateEvent(
          channelId: channelId,
          unreadCount: unreadCount,
          isMentioned: isMentioned,
          hasUnread: hasUnread,
        ));
      }
      
      void _notifyUnreadCountChanged(UnreadUpdateEvent event) {
        // Implement your state management update here
        // This could be setState, Provider.notify, BLoC.add, etc.
      }
    }

    class UnreadStatus {
      final int count;
      final bool isMentioned;
      
      UnreadStatus({required this.count, required this.isMentioned});
    }

    class UnreadUpdateEvent {
      final String channelId;
      final int unreadCount;
      final bool isMentioned;
      final bool hasUnread;
      
      UnreadUpdateEvent({
        required this.channelId,
        required this.unreadCount,
        required this.isMentioned,
        required this.hasUnread,
      });
    }

    // Usage example
    final unreadManager = ChannelUnreadManager();
    unreadManager.observeChannelUnreadCount('general-chat');
    ```
  </Tab>
</Tabs>

## Total Unread Count

### Get Total Across All Channels

Get the aggregated unread count across all cached channels. This includes unread counts from default subchannels of channels that have been fetched from the server:

<Tabs>
  <Tab title="iOS">
    ```swift
    import Combine

    extension ChannelUnreadManager {
        private var disposeBag: Set<AnyCancellable> = []
        
        func observeTotalChannelsUnreadCount() {
            channelRepository.getTotalChannelsUnread()
                .sink(receiveValue: { [weak self] totalUnread in
                    let totalCount = totalUnread.unreadCount
                    let hasMentions = totalUnread.isMentioned
                    
                    print("Total channels unread count: \(totalCount)")
                    print("User has unread mentions: \(hasMentions)")
                    
                    // Update global unread indicator
                    DispatchQueue.main.async {
                        self?.updateGlobalUnreadBadge(
                            totalCount: totalCount,
                            hasMentions: hasMentions
                        )
                    }
                })
                .store(in: &disposeBag)
        }
        
        func getTotalUnreadCountSync() -> (count: Int, isMentioned: Bool) {
            // Get synchronous total if available
            let totalUnread = channelRepository.getTotalChannelsUnreadSync()
            return (count: totalUnread.unreadCount, isMentioned: totalUnread.isMentioned)
        }
        
        private func updateGlobalUnreadBadge(totalCount: Int, hasMentions: Bool) {
            // Update app badge or global indicator
            UIApplication.shared.applicationIconBadgeNumber = totalCount
            
            // Update tab bar badge
            if let tabBar = getMainTabBarController() {
                let badgeText = totalCount > 99 ? "99+" : (totalCount > 0 ? "\(totalCount)" : nil)
                tabBar.tabBar.items?[0].badgeValue = badgeText
                
                // Special styling for mentions
                if hasMentions {
                    tabBar.tabBar.items?[0].badgeColor = UIColor.red
                } else {
                    tabBar.tabBar.items?[0].badgeColor = UIColor.systemBlue
                }
            }
        }
        
        private func getMainTabBarController() -> UITabBarController? {
            // Return your main tab bar controller
            return nil
        }
    }
    ```
  </Tab>

  <Tab title="Android">
    ```kotlin
    import io.reactivex.disposables.CompositeDisposable

    class TotalUnreadManager {
        private val channelRepository = AmityCoreClient.newChannelRepository()
        private val disposables = CompositeDisposable()
        
        fun observeTotalChannelsUnreadCount() {
            val disposable = channelRepository.getTotalChannelsUnread()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                    { totalUnread ->
                        val totalCount = totalUnread.unreadCount
                        val hasMentions = totalUnread.isMentioned
                        
                        println("Total channels unread count: $totalCount")
                        println("User has unread mentions: $hasMentions")
                        
                        // Update global unread indicator
                        updateGlobalUnreadBadge(totalCount, hasMentions)
                    },
                    { error ->
                        println("Error observing total unread count: $error")
                    }
                )
                
            disposables.add(disposable)
        }
        
        fun getTotalUnreadCountSync(): Pair<Int, Boolean> {
            // Get synchronous total if available
            val totalUnread = channelRepository.getTotalChannelsUnreadSync()
            return Pair(totalUnread.unreadCount, totalUnread.isMentioned)
        }
        
        private fun updateGlobalUnreadBadge(totalCount: Int, hasMentions: Boolean) {
            // Update notification badge
            NotificationManagerCompat.from(context).apply {
                if (totalCount > 0) {
                    val badgeText = if (totalCount > 99) "99+" else totalCount.toString()
                    // Update app shortcut badge or notification
                    ShortcutBadger.applyCount(context, totalCount)
                } else {
                    ShortcutBadger.removeCount(context)
                }
            }
            
            // Update bottom navigation badge
            getMainBottomNavigation()?.let { bottomNav ->
                val badgeText = if (totalCount > 99) "99+" else totalCount.toString()
                val badge = bottomNav.getOrCreateBadge(R.id.nav_chat)
                
                if (totalCount > 0) {
                    badge.isVisible = true
                    badge.text = badgeText
                    badge.backgroundColor = if (hasMentions) {
                        ContextCompat.getColor(context, R.color.mention_red)
                    } else {
                        ContextCompat.getColor(context, R.color.unread_blue)
                    }
                } else {
                    badge.isVisible = false
                }
            }
        }
        
        private fun getMainBottomNavigation(): BottomNavigationView? {
            // Return your main bottom navigation view
            return null
        }
        
        fun dispose() {
            disposables.dispose()
        }
    }
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    class TotalUnreadManager {
        constructor() {
            this.channelRepository = ChannelRepository;
            this.liveObject = null;
        }
        
        observeTotalChannelsUnreadCount() {
            this.liveObject = this.channelRepository.getTotalChannelsUnread();
            
            this.liveObject.on('dataUpdated', (totalUnread) => {
                const totalCount = totalUnread.unreadCount || 0;
                const hasMentions = totalUnread.isMentioned || false;
                
                console.log(`Total channels unread count: ${totalCount}`);
                console.log(`User has unread mentions: ${hasMentions}`);
                
                // Update global unread indicator
                this.updateGlobalUnreadBadge(totalCount, hasMentions);
            });
            
            this.liveObject.on('dataError', (error) => {
                console.error('Error observing total unread count:', error);
            });
        }
        
        getTotalUnreadCountSync() {
            // Get synchronous total if available from cache
            const cached = this.liveObject?.data;
            return {
                count: cached?.unreadCount || 0,
                isMentioned: cached?.isMentioned || false
            };
        }
        
        updateGlobalUnreadBadge(totalCount, hasMentions) {
            // Update document title
            const baseTitle = 'Chat App';
            document.title = totalCount > 0 ? 
                `(${totalCount > 99 ? '99+' : totalCount}) ${baseTitle}` : 
                baseTitle;
            
            // Update favicon with badge
            this.updateFaviconBadge(totalCount);
            
            // Update navigation badge
            const navBadge = document.querySelector('.nav-chat-badge');
            if (navBadge) {
                const badgeText = totalCount > 99 ? '99+' : totalCount.toString();
                navBadge.textContent = totalCount > 0 ? badgeText : '';
                navBadge.style.display = totalCount > 0 ? 'block' : 'none';
                
                // Special styling for mentions
                navBadge.className = `nav-chat-badge ${hasMentions ? 'mention' : 'unread'}`;
            }
            
            // Send notification if supported
            if ('Notification' in window && Notification.permission === 'granted') {
                if (totalCount > 0) {
                    this.updateNotificationBadge(totalCount);
                }
            }
        }
        
        updateFaviconBadge(count) {
            // Update favicon with unread count
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            // Draw base favicon
            const favicon = document.querySelector('link[rel="icon"]');
            if (favicon) {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, 32, 32);
                    
                    if (count > 0) {
                        // Draw badge
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(24, 8, 8, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw count text
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(count > 99 ? '99+' : count.toString(), 24, 12);
                    }
                    
                    // Update favicon
                    favicon.href = canvas.toDataURL();
                };
                img.src = favicon.href;
            }
        }
        
        updateNotificationBadge(count) {
            // Update service worker badge if supported
            if ('serviceWorker' in navigator && 'setAppBadge' in navigator) {
                navigator.setAppBadge(count).catch(err => {
                    console.log('Badge API not supported:', err);
                });
            }
        }
        
        dispose() {
            if (this.liveObject) {
                this.liveObject.dispose();
            }
        }
    }
    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    interface TotalUnreadData {
        unreadCount: number;
        isMentioned: boolean;
    }

    class TotalUnreadManager {
        private channelRepository = ChannelRepository;
        private liveObject: AmityLiveObject<TotalUnreadData> | null = null;
        
        observeTotalChannelsUnreadCount(): void {
            this.liveObject = this.channelRepository.getTotalChannelsUnread();
            
            this.liveObject.on('dataUpdated', (totalUnread: TotalUnreadData) => {
                const totalCount = totalUnread.unreadCount || 0;
                const hasMentions = totalUnread.isMentioned || false;
                
                console.log(`Total channels unread count: ${totalCount}`);
                console.log(`User has unread mentions: ${hasMentions}`);
                
                // Update global unread indicator
                this.updateGlobalUnreadBadge(totalCount, hasMentions);
            });
            
            this.liveObject.on('dataError', (error: Error) => {
                console.error('Error observing total unread count:', error);
            });
        }
        
        getTotalUnreadCountSync(): { count: number; isMentioned: boolean } {
            // Get synchronous total if available from cache
            const cached = this.liveObject?.data;
            return {
                count: cached?.unreadCount || 0,
                isMentioned: cached?.isMentioned || false
            };
        }
        
        private updateGlobalUnreadBadge(totalCount: number, hasMentions: boolean): void {
            // Update document title
            const baseTitle = 'Chat App';
            document.title = totalCount > 0 ? 
                `(${totalCount > 99 ? '99+' : totalCount}) ${baseTitle}` : 
                baseTitle;
            
            // Update favicon with badge
            this.updateFaviconBadge(totalCount);
            
            // Update navigation badge
            const navBadge = document.querySelector('.nav-chat-badge') as HTMLElement;
            if (navBadge) {
                const badgeText = totalCount > 99 ? '99+' : totalCount.toString();
                navBadge.textContent = totalCount > 0 ? badgeText : '';
                navBadge.style.display = totalCount > 0 ? 'block' : 'none';
                
                // Special styling for mentions
                navBadge.className = `nav-chat-badge ${hasMentions ? 'mention' : 'unread'}`;
            }
            
            // Emit custom event for framework integration
            const event = new CustomEvent('totalUnreadUpdated', {
                detail: { totalCount, hasMentions }
            });
            document.dispatchEvent(event);
        }
        
        private updateFaviconBadge(count: number): void {
            // Update favicon with unread count
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            if (!ctx) return;
            
            // Draw base favicon
            const favicon = document.querySelector('link[rel="icon"]') as HTMLLinkElement;
            if (favicon) {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, 32, 32);
                    
                    if (count > 0) {
                        // Draw badge
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(24, 8, 8, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw count text
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(count > 99 ? '99+' : count.toString(), 24, 12);
                    }
                    
                    // Update favicon
                    favicon.href = canvas.toDataURL();
                };
                img.src = favicon.href;
            }
        }
        
        dispose(): void {
            if (this.liveObject) {
                this.liveObject.dispose();
            }
        }
    }
    ```
  </Tab>

  <Tab title="Flutter">
    ```dart
    class TotalUnreadManager {
      StreamSubscription? _subscription;
      
      void observeTotalChannelsUnreadCount() {
        try {
          final liveObject = AmitySocialClient.newChannelRepository()
              .getTotalChannelsUnread();
          
          _subscription = liveObject.stream.listen(
            (totalUnread) {
              final totalCount = totalUnread.unreadCount ?? 0;
              final hasMentions = totalUnread.isMentioned ?? false;
              
              print('Total channels unread count: $totalCount');
              print('User has unread mentions: $hasMentions');
              
              // Update global unread indicator
              _updateGlobalUnreadBadge(totalCount, hasMentions);
            },
            onError: (error) {
              print('Error observing total unread count: $error');
            },
          );
        } catch (error) {
          print('Failed to observe total unread count: $error');
        }
      }
      
      TotalUnreadData getTotalUnreadCountSync() {
        // Get synchronous total if available from cache
        // This would typically come from your state management
        return TotalUnreadData(count: 0, isMentioned: false);
      }
      
      void _updateGlobalUnreadBadge(int totalCount, bool hasMentions) {
        // Update app badge (iOS/Android)
        if (totalCount > 0) {
          FlutterAppBadger.updateBadgeCount(totalCount);
        } else {
          FlutterAppBadger.removeBadge();
        }
        
        // Update bottom navigation badge
        _updateBottomNavBadge(totalCount, hasMentions);
        
        // Emit event for state management
        _notifyTotalUnreadChanged(TotalUnreadUpdateEvent(
          totalCount: totalCount,
          hasMentions: hasMentions,
        ));
      }
      
      void _updateBottomNavBadge(int totalCount, bool hasMentions) {
        // Update your bottom navigation badge
        // This would typically update your state management
        print('Updating bottom nav badge: $totalCount (mentions: $hasMentions)');
      }
      
      void _notifyTotalUnreadChanged(TotalUnreadUpdateEvent event) {
        // Implement your state management update here
        // This could be setState, Provider.notify, BLoC.add, Riverpod.state, etc.
      }
      
      void dispose() {
        _subscription?.cancel();
      }
    }

    class TotalUnreadData {
      final int count;
      final bool isMentioned;
      
      TotalUnreadData({required this.count, required this.isMentioned});
    }

    class TotalUnreadUpdateEvent {
      final int totalCount;
      final bool hasMentions;
      
      TotalUnreadUpdateEvent({
        required this.totalCount,
        required this.hasMentions,
      });
    }
    ```
  </Tab>
</Tabs>

## Unread Count Support

### Check Channel Support

Verify if a channel supports the unread count feature:

<Tabs>
  <Tab title="iOS">
    ```swift
    extension ChannelUnreadManager {
        func checkUnreadCountSupport(channel: AmityChannel) -> Bool {
            // Check if channel supports unread count tracking
            return channel.isUnreadCountSupported
        }
        
        func validateChannelForUnreadTracking(channelId: String) {
            let liveObject = channelRepository.getChannel(channelId)
            
            liveObject.observe { channel, error in
                guard let channel = channel, error == nil else {
                    print("Error getting channel: \(error?.localizedDescription ?? "Unknown error")")
                    return
                }
                
                if self.checkUnreadCountSupport(channel: channel) {
                    print("Channel \(channel.displayName) supports unread count tracking")
                    // Proceed with unread count observation
                    self.observeChannelUnreadCount(channelId: channelId)
                } else {
                    print("Channel \(channel.displayName) doesn't support unread count tracking")
                    // Handle unsupported channel
                    self.handleUnsupportedChannel(channel: channel)
                }
            }
        }
        
        private func handleUnsupportedChannel(channel: AmityChannel) {
            // Handle channels that don't support unread count
            // Maybe show different UI or disable certain features
            print("Unread count not available for channel type: \(channel.type)")
        }
    }
    ```
  </Tab>

  <Tab title="Android">
    ```kotlin
    fun checkUnreadCountSupport(channel: AmityChannel): Boolean {
        // Check if channel supports unread count tracking
        return channel.isUnreadCountSupported()
    }
    
    fun validateChannelForUnreadTracking(channelId: String) {
        channelRepository.getChannel(channelId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                { channel ->
                    if (checkUnreadCountSupport(channel)) {
                        println("Channel ${channel.displayName} supports unread count tracking")
                        // Proceed with unread count observation
                        observeChannelUnreadCount(channelId)
                    } else {
                        println("Channel ${channel.displayName} doesn't support unread count tracking")
                        // Handle unsupported channel
                        handleUnsupportedChannel(channel)
                    }
                },
                { error ->
                    println("Error getting channel: $error")
                }
            )
    }
    
    private fun handleUnsupportedChannel(channel: AmityChannel) {
        // Handle channels that don't support unread count
        // Maybe show different UI or disable certain features
        println("Unread count not available for channel type: ${channel.type}")
    }
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    checkUnreadCountSupport(channel) {
        // Check if channel supports unread count tracking
        return channel.isUnreadCountSupported !== false;
    }
    
    validateChannelForUnreadTracking(channelId) {
        const liveObject = this.channelRepository.getChannel(channelId);
        
        liveObject.on('dataUpdated', (channel) => {
            if (this.checkUnreadCountSupport(channel)) {
                console.log(`Channel ${channel.displayName} supports unread count tracking`);
                // Proceed with unread count observation
                this.observeChannelUnreadCount(channelId);
            } else {
                console.log(`Channel ${channel.displayName} doesn't support unread count tracking`);
                // Handle unsupported channel
                this.handleUnsupportedChannel(channel);
            }
        });
        
        liveObject.on('dataError', (error) => {
            console.error('Error getting channel:', error);
        });
    }
    
    handleUnsupportedChannel(channel) {
        // Handle channels that don't support unread count
        // Maybe show different UI or disable certain features
        console.log(`Unread count not available for channel type: ${channel.type}`);
    }
    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    checkUnreadCountSupport(channel: AmityChannel): boolean {
        // Check if channel supports unread count tracking
        return channel.isUnreadCountSupported !== false;
    }
    
    validateChannelForUnreadTracking(channelId: string): void {
        const liveObject = this.channelRepository.getChannel(channelId);
        
        liveObject.on('dataUpdated', (channel: AmityChannel) => {
            if (this.checkUnreadCountSupport(channel)) {
                console.log(`Channel ${channel.displayName} supports unread count tracking`);
                // Proceed with unread count observation
                this.observeChannelUnreadCount(channelId);
            } else {
                console.log(`Channel ${channel.displayName} doesn't support unread count tracking`);
                // Handle unsupported channel
                this.handleUnsupportedChannel(channel);
            }
        });
        
        liveObject.on('dataError', (error: Error) => {
            console.error('Error getting channel:', error);
        });
    }
    
    private handleUnsupportedChannel(channel: AmityChannel): void {
        // Handle channels that don't support unread count
        // Maybe show different UI or disable certain features
        console.log(`Unread count not available for channel type: ${channel.type}`);
    }
    ```
  </Tab>

  <Tab title="Flutter">
    ```dart
    bool checkUnreadCountSupport(AmityChannel channel) {
        // Check if channel supports unread count tracking
        return channel.isUnreadCountSupported ?? true;
    }
    
    void validateChannelForUnreadTracking(String channelId) {
        try {
          final liveObject = AmitySocialClient.newChannelRepository()
              .getChannel(channelId);
          
          liveObject.stream.listen(
            (channel) {
              if (checkUnreadCountSupport(channel)) {
                print('Channel ${channel.displayName} supports unread count tracking');
                // Proceed with unread count observation
                observeChannelUnreadCount(channelId);
              } else {
                print('Channel ${channel.displayName} doesn\'t support unread count tracking');
                // Handle unsupported channel
                _handleUnsupportedChannel(channel);
              }
            },
            onError: (error) {
              print('Error getting channel: $error');
            },
          );
        } catch (error) {
          print('Failed to validate channel for unread tracking: $error');
        }
    }
    
    void _handleUnsupportedChannel(AmityChannel channel) {
        // Handle channels that don't support unread count
        // Maybe show different UI or disable certain features
        print('Unread count not available for channel type: ${channel.type}');
    }
    ```
  </Tab>
</Tabs>

## Advanced Features

### Unread Count Filtering

Filter and categorize unread counts based on different criteria:

```javascript
class UnreadCountFilter {
    constructor() {
        this.filters = {
            mentions: (channel) => channel.isMentioned,
            direct: (channel) => channel.type === 'direct',
            groups: (channel) => channel.type === 'community',
            priority: (channel) => channel.priority === 'high'
        };
    }
    
    getFilteredUnreadCounts(channels) {
        const results = {
            total: 0,
            mentions: 0,
            direct: 0,
            groups: 0,
            priority: 0
        };
        
        channels.forEach(channel => {
            const unreadCount = channel.unreadCount || 0;
            results.total += unreadCount;
            
            if (this.filters.mentions(channel)) results.mentions += unreadCount;
            if (this.filters.direct(channel)) results.direct += unreadCount;
            if (this.filters.groups(channel)) results.groups += unreadCount;
            if (this.filters.priority(channel)) results.priority += unreadCount;
        });
        
        return results;
    }
}
```

### Smart Badge Management

Implement intelligent badge management with different priorities:

```javascript
class SmartBadgeManager {
    constructor() {
        this.badgePriority = {
            mention: 3,
            direct: 2,
            group: 1,
            default: 0
        };
    }
    
    calculateBadgeDisplay(channels) {
        let highestPriority = -1;
        let totalCount = 0;
        let badgeType = 'default';
        
        channels.forEach(channel => {
            const unreadCount = channel.unreadCount || 0;
            totalCount += unreadCount;
            
            if (unreadCount > 0) {
                let priority = this.badgePriority.default;
                
                if (channel.isMentioned) {
                    priority = this.badgePriority.mention;
                    badgeType = 'mention';
                } else if (channel.type === 'direct') {
                    priority = this.badgePriority.direct;
                    if (badgeType !== 'mention') badgeType = 'direct';
                } else if (channel.type === 'community') {
                    priority = this.badgePriority.group;
                    if (!['mention', 'direct'].includes(badgeType)) badgeType = 'group';
                }
                
                if (priority > highestPriority) {
                    highestPriority = priority;
                }
            }
        });
        
        return {
            count: totalCount,
            type: badgeType,
            priority: highestPriority,
            display: this.formatBadgeDisplay(totalCount, badgeType)
        };
    }
    
    formatBadgeDisplay(count, type) {
        const displayCount = count > 99 ? '99+' : count.toString();
        
        return {
            text: count > 0 ? displayCount : '',
            className: `badge badge-${type}`,
            visible: count > 0
        };
    }
}
```

### Performance Optimization

Optimize unread count tracking for better performance:

```javascript
class UnreadCountOptimizer {
    constructor() {
        this.cache = new Map();
        this.batchUpdates = [];
        this.updateTimer = null;
        this.batchDelay = 100; // ms
    }
    
    batchUnreadUpdate(channelId, unreadData) {
        // Add to batch instead of immediate update
        this.batchUpdates.push({ channelId, unreadData, timestamp: Date.now() });
        
        // Clear existing timer
        if (this.updateTimer) {
            clearTimeout(this.updateTimer);
        }
        
        // Set new timer for batch processing
        this.updateTimer = setTimeout(() => {
            this.processBatchUpdates();
        }, this.batchDelay);
    }
    
    processBatchUpdates() {
        if (this.batchUpdates.length === 0) return;
        
        // Group updates by channel
        const groupedUpdates = new Map();
        
        this.batchUpdates.forEach(update => {
            if (!groupedUpdates.has(update.channelId)) {
                groupedUpdates.set(update.channelId, []);
            }
            groupedUpdates.get(update.channelId).push(update);
        });
        
        // Process only the latest update for each channel
        groupedUpdates.forEach((updates, channelId) => {
            const latestUpdate = updates.reduce((latest, current) =>
                current.timestamp > latest.timestamp ? current : latest
            );
            
            this.applyUnreadUpdate(channelId, latestUpdate.unreadData);
        });
        
        // Clear batch
        this.batchUpdates = [];
        this.updateTimer = null;
    }
    
    applyUnreadUpdate(channelId, unreadData) {
        // Apply the actual UI update
        this.cache.set(channelId, unreadData);
        
        // Update UI elements
        const chatItem = document.querySelector(`[data-channel-id="${channelId}"]`);
        if (chatItem) {
            this.updateChatItemBadge(chatItem, unreadData);
        }
    }
    
    updateChatItemBadge(chatItem, unreadData) {
        const badge = chatItem.querySelector('.unread-badge');
        if (badge) {
            badge.textContent = unreadData.count > 99 ? '99+' : unreadData.count.toString();
            badge.style.display = unreadData.count > 0 ? 'block' : 'none';
            badge.className = `unread-badge ${unreadData.isMentioned ? 'mention' : 'unread'}`;
        }
    }
}
```

## Use Cases

<AccordionGroup>
  <Accordion title="Chat List with Smart Badges">
    Display intelligent unread badges in chat lists with priority-based styling.
    
    ```javascript
    class ChatListManager {
        constructor() {
            this.unreadManager = new ChannelUnreadManager();
            this.badgeManager = new SmartBadgeManager();
            this.channels = [];
        }
        
        async loadChatListWithUnreadCounts() {
            // Get all channels
            this.channels = await this.getChannels();
            
            // Observe unread counts for each channel
            this.channels.forEach(channel => {
                this.unreadManager.observeChannelUnreadCount(channel.channelId);
            });
            
            // Calculate and display smart badges
            this.updateChatListBadges();
        }
        
        updateChatListBadges() {
            const badgeInfo = this.badgeManager.calculateBadgeDisplay(this.channels);
            
            // Update global app badge
            this.updateAppBadge(badgeInfo);
            
            // Update individual channel badges
            this.channels.forEach(channel => {
                this.updateChannelBadge(channel);
            });
        }
        
        updateAppBadge(badgeInfo) {
            // Update app icon badge
            document.title = badgeInfo.count > 0 ? 
                `(${badgeInfo.display.text}) Chat App` : 
                'Chat App';
            
            // Update navigation badge
            const navBadge = document.querySelector('.nav-badge');
            if (navBadge) {
                navBadge.textContent = badgeInfo.display.text;
                navBadge.className = badgeInfo.display.className;
                navBadge.style.display = badgeInfo.display.visible ? 'block' : 'none';
            }
        }
        
        updateChannelBadge(channel) {
            const chatItem = document.querySelector(`[data-channel-id="${channel.channelId}"]`);
            if (!chatItem) return;
            
            const unreadCount = channel.unreadCount || 0;
            const isMentioned = channel.isMentioned || false;
            
            const badge = chatItem.querySelector('.channel-badge');
            if (badge) {
                badge.textContent = unreadCount > 99 ? '99+' : unreadCount.toString();
                badge.style.display = unreadCount > 0 ? 'block' : 'none';
                badge.className = `channel-badge ${isMentioned ? 'mention' : 'unread'}`;
            }
            
            // Add special styling for mentioned channels
            chatItem.classList.toggle('has-mention', isMentioned);
            chatItem.classList.toggle('has-unread', unreadCount > 0);
        }
    }
    ```
  </Accordion>

  <Accordion title="Notification Badge Management">
    Manage notification badges across different platforms and contexts.
    
    ```javascript
    class NotificationBadgeManager {
        constructor() {
            this.totalUnreadManager = new TotalUnreadManager();
            this.platform = this.detectPlatform();
        }
        
        detectPlatform() {
            if (window.electron) return 'electron';
            if (window.ReactNativeWebView) return 'react-native';
            if ('serviceWorker' in navigator) return 'pwa';
            return 'web';
        }
        
        async initializeBadgeManagement() {
            // Start observing total unread count
            this.totalUnreadManager.observeTotalChannelsUnreadCount();
            
            // Listen for unread count changes
            document.addEventListener('totalUnreadUpdated', (event) => {
                this.updatePlatformBadge(event.detail);
            });
            
            // Request notification permissions if needed
            await this.requestNotificationPermissions();
        }
        
        async requestNotificationPermissions() {
            if ('Notification' in window && Notification.permission === 'default') {
                const permission = await Notification.requestPermission();
                console.log('Notification permission:', permission);
            }
        }
        
        updatePlatformBadge({ totalCount, hasMentions }) {
            switch (this.platform) {
                case 'electron':
                    this.updateElectronBadge(totalCount);
                    break;
                case 'react-native':
                    this.updateReactNativeBadge(totalCount);
                    break;
                case 'pwa':
                    this.updatePWABadge(totalCount);
                    break;
                default:
                    this.updateWebBadge(totalCount, hasMentions);
            }
        }
        
        updateElectronBadge(count) {
            if (window.electron) {
                window.electron.ipcRenderer.send('update-badge', count);
            }
        }
        
        updateReactNativeBadge(count) {
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    type: 'updateBadge',
                    count: count
                }));
            }
        }
        
        async updatePWABadge(count) {
            try {
                if ('setAppBadge' in navigator) {
                    if (count > 0) {
                        await navigator.setAppBadge(count);
                    } else {
                        await navigator.clearAppBadge();
                    }
                }
            } catch (error) {
                console.log('App Badge API not supported:', error);
            }
        }
        
        updateWebBadge(count, hasMentions) {
            // Update document title
            const baseTitle = 'Chat App';
            document.title = count > 0 ? 
                `(${count > 99 ? '99+' : count}) ${baseTitle}` : 
                baseTitle;
            
            // Update favicon
            this.updateFaviconBadge(count, hasMentions);
        }
        
        updateFaviconBadge(count, hasMentions) {
            // Create canvas for favicon with badge
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            // Draw base favicon
            const favicon = document.querySelector('link[rel="icon"]');
            if (favicon && ctx) {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, 32, 32);
                    
                    if (count > 0) {
                        // Draw badge background
                        ctx.fillStyle = hasMentions ? '#ff0000' : '#0066cc';
                        ctx.beginPath();
                        ctx.arc(24, 8, 8, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw count text
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 10px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const text = count > 99 ? '99+' : count.toString();
                        ctx.fillText(text, 24, 8);
                    }
                    
                    // Update favicon
                    favicon.href = canvas.toDataURL();
                };
                img.src = favicon.href;
            }
        }
    }
    ```
  </Accordion>

  <Accordion title="Unread Count Analytics">
    Track and analyze unread count patterns for insights and optimization.
    
    ```javascript
    class UnreadCountAnalytics {
        constructor() {
            this.metrics = {
                peakUnreadTimes: new Map(),
                channelEngagement: new Map(),
                mentionPatterns: new Map(),
                responseRates: new Map()
            };
        }
        
        trackUnreadEvent(channelId, eventType, unreadCount, isMentioned) {
            const timestamp = Date.now();
            const hour = new Date(timestamp).getHours();
            
            // Track peak unread times
            if (!this.metrics.peakUnreadTimes.has(hour)) {
                this.metrics.peakUnreadTimes.set(hour, []);
            }
            this.metrics.peakUnreadTimes.get(hour).push({
                channelId,
                unreadCount,
                timestamp
            });
            
            // Track channel engagement
            if (!this.metrics.channelEngagement.has(channelId)) {
                this.metrics.channelEngagement.set(channelId, {
                    totalUnread: 0,
                    peakUnread: 0,
                    mentions: 0,
                    lastActivity: timestamp
                });
            }
            
            const channelMetrics = this.metrics.channelEngagement.get(channelId);
            channelMetrics.totalUnread += unreadCount;
            channelMetrics.peakUnread = Math.max(channelMetrics.peakUnread, unreadCount);
            channelMetrics.lastActivity = timestamp;
            
            if (isMentioned) {
                channelMetrics.mentions++;
            }
        }
        
        generateUnreadInsights() {
            return {
                peakHours: this.calculatePeakUnreadHours(),
                mostActiveChannels: this.getMostActiveChannels(),
                mentionFrequency: this.calculateMentionFrequency(),
                engagementTrends: this.analyzeEngagementTrends()
            };
        }
        
        calculatePeakUnreadHours() {
            const hourlyAverages = new Map();
            
            this.metrics.peakUnreadTimes.forEach((events, hour) => {
                const totalUnread = events.reduce((sum, event) => sum + event.unreadCount, 0);
                hourlyAverages.set(hour, totalUnread / events.length);
            });
            
            return Array.from(hourlyAverages.entries())
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5);
        }
        
        getMostActiveChannels() {
            return Array.from(this.metrics.channelEngagement.entries())
                .sort(([,a], [,b]) => b.totalUnread - a.totalUnread)
                .slice(0, 10)
                .map(([channelId, metrics]) => ({
                    channelId,
                    totalUnread: metrics.totalUnread,
                    peakUnread: metrics.peakUnread,
                    mentions: metrics.mentions
                }));
        }
        
        calculateMentionFrequency() {
            let totalMentions = 0;
            let totalChannels = 0;
            
            this.metrics.channelEngagement.forEach((metrics) => {
                totalMentions += metrics.mentions;
                totalChannels++;
            });
            
            return totalChannels > 0 ? totalMentions / totalChannels : 0;
        }
        
        analyzeEngagementTrends() {
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;
            
            const recentlyActive = Array.from(this.metrics.channelEngagement.entries())
                .filter(([, metrics]) => now - metrics.lastActivity < dayMs)
                .length;
            
            const totalChannels = this.metrics.channelEngagement.size;
            
            return {
                activeChannelsToday: recentlyActive,
                totalChannels: totalChannels,
                activityRate: totalChannels > 0 ? recentlyActive / totalChannels : 0
            };
        }
    }
    ```
  </Accordion>
</AccordionGroup>

## Best Practices

### Performance Optimization

1. **Batch Updates**: Group multiple unread count updates to reduce UI thrashing
2. **Smart Caching**: Cache unread counts locally to reduce server requests
3. **Efficient Observers**: Dispose of observers when components unmount
4. **Priority-Based Updates**: Prioritize visible channels for real-time updates

### User Experience

1. **Clear Visual Hierarchy**: Use different styles for mentions vs regular unread counts
2. **Consistent Badging**: Apply consistent badge styles across all UI elements
3. **Smart Notifications**: Show appropriate notifications based on unread count changes
4. **Accessibility**: Ensure badges are accessible with proper ARIA labels

### Error Handling

1. **Graceful Degradation**: Handle cases where unread count is unavailable
2. **Network Resilience**: Cache counts locally for offline scenarios
3. **Validation**: Validate unread count data before displaying
4. **Fallback UI**: Provide fallback indicators when count tracking fails

<Note>
Unread counts are automatically updated in real-time as new messages arrive. Implement proper cleanup and disposal patterns to prevent memory leaks when observing multiple channels simultaneously.
</Note>