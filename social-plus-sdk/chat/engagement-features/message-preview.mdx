---
title: "Message Previews"
description: "Enhance user experience with quick message glimpses for better chat navigation and engagement"
---

# Message Previews

Improve user experience by providing quick message glimpses through channel and subchannel objects, allowing users to assess message content without opening full conversations.

<CardGroup cols={2}>
  <Card title="Quick Assessment" icon="eye">
    Preview message content without opening full conversations
  </Card>
  <Card title="Enhanced Navigation" icon="compass">
    Improve chat list navigation with latest message previews
  </Card>
  <Card title="Data Efficiency" icon="gauge">
    Reduce bandwidth usage by showing previews before full loading
  </Card>
  <Card title="Better UX" icon="sparkles">
    Streamline communication workflows and response times
  </Card>
</CardGroup>

## Overview

Message previews provide partial message data that offers brief summaries of incoming messages through channel and subchannel objects. This feature significantly enhances user experience by enabling quick content assessment and improved navigation.

### Key Benefits
- **Smart Notifications**: Show preview content in push notifications
- **Efficient Chat Lists**: Display latest messages in conversation lists
- **Bandwidth Optimization**: Load previews before full message content
- **Priority Assessment**: Help users decide which conversations need immediate attention
- **Enhanced Engagement**: Streamline communication workflows

## Configuration

<Warning>
Message Preview must be enabled at the network level before use. This feature will only work for new messages created after enablement.
</Warning>

### Enable Message Preview

To enable message previews for your network, use the following API configuration:

<Tabs>
  <Tab title="cURL">
    ```bash
    curl --location --request PUT 'https://apix.sg.amity.co/api/v3/network-settings/chat' \
    --header 'accept: application/json' \
    --header 'Content-Type: application/json' \
    --header 'Authorization: Bearer YOUR_ACCESS_TOKEN' \
    --data '{
      "isAllowMentionedChannelEnabled": false,
      "messagePreviewSetting": {
        "enabled": true,
        "isIncludeDeleted": false
      },
      "isAllowAdminViewConversationMessage": true,
      "isAllowAdminManageConversationMessage": true
    }'
    ```
  </Tab>
  
  <Tab title="JavaScript">
    ```javascript
    const enableMessagePreviews = async () => {
      const response = await fetch('https://apix.sg.amity.co/api/v3/network-settings/chat', {
        method: 'PUT',
        headers: {
          'accept': 'application/json',
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${YOUR_ACCESS_TOKEN}`
        },
        body: JSON.stringify({
          messagePreviewSetting: {
            enabled: true,
            isIncludeDeleted: false
          }
        })
      });
      
      if (response.ok) {
        console.log('Message previews enabled successfully');
      } else {
        throw new Error('Failed to enable message previews');
      }
    };
    ```
  </Tab>
</Tabs>

## Message Preview Structure

### Data Properties

<ParamField path="messageId" type="string">
  Unique identifier of the message
</ParamField>

<ParamField path="channelId" type="string">
  ID of the channel containing the message
</ParamField>

<ParamField path="userId" type="string">
  ID of the user who created the message
</ParamField>

<ParamField path="type" type="string">
  Message type: `text`, `image`, `video`, `audio`, `file`, or `custom`
</ParamField>

<ParamField path="data" type="object">
  Message content data (text content stored in `text` key)
</ParamField>

<ParamField path="isDeleted" type="boolean">
  Whether the message has been marked as deleted
</ParamField>

<ParamField path="createdAt" type="date">
  Timestamp when the message was created
</ParamField>

<ParamField path="updatedAt" type="date">
  Timestamp when the message was last updated
</ParamField>

## Implementation

### Channel Message Preview

Access message previews directly through channel objects:

<Tabs>
  <Tab title="iOS">
    ```swift
    import AmitySDK

    class MessagePreviewManager {
        private let channelRepository = AmityChannelRepository(client: AmityUIKitManager.client)
        
        func getChannelWithPreview(channelId: String) {
            let liveObject = channelRepository.getChannel(channelId)
            
            liveObject.observe { [weak self] channel, error in
                if let error = error {
                    print("Error getting channel: \(error)")
                    return
                }
                
                guard let channel = channel else { return }
                
                // Access message preview
                if let messagePreview = channel.messagePreview {
                    self?.displayPreview(
                        messageId: messagePreview.messageId,
                        type: messagePreview.messageType,
                        content: messagePreview.data?["text"] as? String ?? "",
                        createdAt: messagePreview.createdAt,
                        userId: messagePreview.userId
                    )
                } else {
                    print("No message preview available")
                }
            }
        }
        
        private func displayPreview(
            messageId: String,
            type: AmityMessageType,
            content: String,
            createdAt: Date,
            userId: String
        ) {
            let previewText = formatPreviewContent(type: type, content: content)
            let timeString = formatRelativeTime(createdAt)
            
            print("Latest: \(previewText) â€¢ \(timeString)")
            
            // Update UI with preview information
            DispatchQueue.main.async {
                // Update your UI components here
                self.updateChatListItem(
                    messageId: messageId,
                    preview: previewText,
                    timestamp: timeString,
                    senderId: userId
                )
            }
        }
        
        private func formatPreviewContent(type: AmityMessageType, content: String) -> String {
            switch type {
            case .text:
                return content.isEmpty ? "Message" : String(content.prefix(50))
            case .image:
                return "ðŸ“· Photo"
            case .video:
                return "ðŸŽ¥ Video"
            case .audio:
                return "ðŸŽµ Audio"
            case .file:
                return "ðŸ“„ File"
            case .custom:
                return "ðŸ“‹ Custom message"
            default:
                return "Message"
            }
        }
        
        private func formatRelativeTime(_ date: Date) -> String {
            let formatter = RelativeDateTimeFormatter()
            formatter.unitsStyle = .abbreviated
            return formatter.localizedString(for: date, relativeTo: Date())
        }
        
        private func updateChatListItem(
            messageId: String,
            preview: String,
            timestamp: String,
            senderId: String
        ) {
            // Implement your UI update logic here
            // This could update a table view cell, collection view, etc.
        }
    }

    // Usage example
    let previewManager = MessagePreviewManager()
    previewManager.getChannelWithPreview(channelId: "general-chat")
    ```
  </Tab>

  <Tab title="Android">
    ```kotlin
    import com.amity.socialcloud.sdk.AmityCoreClient
    import com.amity.socialcloud.sdk.chat.channel.AmityChannelRepository
    import io.reactivex.android.schedulers.AndroidSchedulers
    import io.reactivex.schedulers.Schedulers
    import java.text.SimpleDateFormat
    import java.util.*

    class MessagePreviewManager {
        private val channelRepository = AmityCoreClient.newChannelRepository()
        
        fun getChannelWithPreview(channelId: String) {
            channelRepository.getChannel(channelId)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                    { channel ->
                        // Access message preview
                        channel.messagePreview?.let { preview ->
                            displayPreview(
                                messageId = preview.messageId,
                                type = preview.type,
                                content = preview.data?.get("text") as? String ?: "",
                                createdAt = preview.createdAt,
                                userId = preview.userId
                            )
                        } ?: run {
                            println("No message preview available")
                        }
                    },
                    { error ->
                        println("Error getting channel: $error")
                    }
                )
        }
        
        private fun displayPreview(
            messageId: String,
            type: String,
            content: String,
            createdAt: Date,
            userId: String
        ) {
            val previewText = formatPreviewContent(type, content)
            val timeString = formatRelativeTime(createdAt)
            
            println("Latest: $previewText â€¢ $timeString")
            
            // Update UI with preview information
            updateChatListItem(
                messageId = messageId,
                preview = previewText,
                timestamp = timeString,
                senderId = userId
            )
        }
        
        private fun formatPreviewContent(type: String, content: String): String {
            return when (type) {
                "text" -> if (content.isEmpty()) "Message" else content.take(50)
                "image" -> "ðŸ“· Photo"
                "video" -> "ðŸŽ¥ Video"
                "audio" -> "ðŸŽµ Audio"
                "file" -> "ðŸ“„ File"
                "custom" -> "ðŸ“‹ Custom message"
                else -> "Message"
            }
        }
        
        private fun formatRelativeTime(date: Date): String {
            val now = Date()
            val diffInMillis = now.time - date.time
            val diffInMinutes = diffInMillis / (1000 * 60)
            
            return when {
                diffInMinutes < 1 -> "Just now"
                diffInMinutes < 60 -> "${diffInMinutes}m ago"
                diffInMinutes < 1440 -> "${diffInMinutes / 60}h ago"
                else -> SimpleDateFormat("MMM dd", Locale.getDefault()).format(date)
            }
        }
        
        private fun updateChatListItem(
            messageId: String,
            preview: String,
            timestamp: String,
            senderId: String
        ) {
            // Implement your UI update logic here
            // Update RecyclerView adapter, notify item changed, etc.
        }
    }

    // Usage example
    val previewManager = MessagePreviewManager()
    previewManager.getChannelWithPreview("general-chat")
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    import { ChannelRepository } from '@amityco/ts-sdk';

    class MessagePreviewManager {
        constructor() {
            this.channelRepository = ChannelRepository;
        }
        
        async getChannelWithPreview(channelId) {
            try {
                const liveObject = this.channelRepository.getChannel(channelId);
                
                liveObject.on('dataUpdated', (channel) => {
                    if (channel.messagePreview) {
                        this.displayPreview({
                            messageId: channel.messagePreview.messageId,
                            type: channel.messagePreview.type,
                            content: channel.messagePreview.data?.text || '',
                            createdAt: channel.messagePreview.createdAt,
                            userId: channel.messagePreview.userId
                        });
                    } else {
                        console.log('No message preview available');
                    }
                });
                
                liveObject.on('dataError', (error) => {
                    console.error('Error getting channel:', error);
                });
                
            } catch (error) {
                console.error('Failed to get channel with preview:', error);
            }
        }
        
        displayPreview({ messageId, type, content, createdAt, userId }) {
            const previewText = this.formatPreviewContent(type, content);
            const timeString = this.formatRelativeTime(new Date(createdAt));
            
            console.log(`Latest: ${previewText} â€¢ ${timeString}`);
            
            // Update UI with preview information
            this.updateChatListItem({
                messageId,
                preview: previewText,
                timestamp: timeString,
                senderId: userId
            });
        }
        
        formatPreviewContent(type, content) {
            switch (type) {
                case 'text':
                    return content || 'Message';
                case 'image':
                    return 'ðŸ“· Photo';
                case 'video':
                    return 'ðŸŽ¥ Video';
                case 'audio':
                    return 'ðŸŽµ Audio';
                case 'file':
                    return 'ðŸ“„ File';
                case 'custom':
                    return 'ðŸ“‹ Custom message';
                default:
                    return 'Message';
            }
        }
        
        formatRelativeTime(date) {
            const now = new Date();
            const diffInMinutes = Math.floor((now - date) / (1000 * 60));
            
            if (diffInMinutes < 1) return 'Just now';
            if (diffInMinutes < 60) return `${diffInMinutes}m ago`;
            if (diffInMinutes < 1440) return `${Math.floor(diffInMinutes / 60)}h ago`;
            
            return date.toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric' 
            });
        }
        
        updateChatListItem({ messageId, preview, timestamp, senderId }) {
            // Implement your UI update logic here
            // Update DOM elements, React state, Vue data, etc.
            const chatItem = document.querySelector(`[data-message-id="${messageId}"]`);
            if (chatItem) {
                chatItem.querySelector('.preview-text').textContent = preview;
                chatItem.querySelector('.timestamp').textContent = timestamp;
            }
        }
    }

    // Usage example
    const previewManager = new MessagePreviewManager();
    previewManager.getChannelWithPreview('general-chat');
    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    import { ChannelRepository, AmityChannel, AmityMessagePreview } from '@amityco/ts-sdk';

    interface PreviewData {
        messageId: string;
        type: string;
        content: string;
        createdAt: string;
        userId: string;
    }

    class MessagePreviewManager {
        private channelRepository = ChannelRepository;
        
        async getChannelWithPreview(channelId: string): Promise<void> {
            try {
                const liveObject = this.channelRepository.getChannel(channelId);
                
                liveObject.on('dataUpdated', (channel: AmityChannel) => {
                    if (channel.messagePreview) {
                        this.displayPreview({
                            messageId: channel.messagePreview.messageId,
                            type: channel.messagePreview.type,
                            content: channel.messagePreview.data?.text || '',
                            createdAt: channel.messagePreview.createdAt,
                            userId: channel.messagePreview.userId
                        });
                    } else {
                        console.log('No message preview available');
                    }
                });
                
                liveObject.on('dataError', (error: Error) => {
                    console.error('Error getting channel:', error);
                });
                
            } catch (error) {
                console.error('Failed to get channel with preview:', error);
            }
        }
        
        private displayPreview(data: PreviewData): void {
            const previewText = this.formatPreviewContent(data.type, data.content);
            const timeString = this.formatRelativeTime(new Date(data.createdAt));
            
            console.log(`Latest: ${previewText} â€¢ ${timeString}`);
            
            // Update UI with preview information
            this.updateChatListItem({
                messageId: data.messageId,
                preview: previewText,
                timestamp: timeString,
                senderId: data.userId
            });
        }
        
        private formatPreviewContent(type: string, content: string): string {
            switch (type) {
                case 'text':
                    return content || 'Message';
                case 'image':
                    return 'ðŸ“· Photo';
                case 'video':
                    return 'ðŸŽ¥ Video';
                case 'audio':
                    return 'ðŸŽµ Audio';
                case 'file':
                    return 'ðŸ“„ File';
                case 'custom':
                    return 'ðŸ“‹ Custom message';
                default:
                    return 'Message';
            }
        }
        
        private formatRelativeTime(date: Date): string {
            const now = new Date();
            const diffInMinutes = Math.floor((now.getTime() - date.getTime()) / (1000 * 60));
            
            if (diffInMinutes < 1) return 'Just now';
            if (diffInMinutes < 60) return `${diffInMinutes}m ago`;
            if (diffInMinutes < 1440) return `${Math.floor(diffInMinutes / 60)}h ago`;
            
            return date.toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric' 
            });
        }
        
        private updateChatListItem(data: {
            messageId: string;
            preview: string;
            timestamp: string;
            senderId: string;
        }): void {
            // Implement your UI update logic here
            // This could be updating React state, Vue reactive data, etc.
            const event = new CustomEvent('chatPreviewUpdated', { detail: data });
            document.dispatchEvent(event);
        }
    }

    // Usage example
    const previewManager = new MessagePreviewManager();
    previewManager.getChannelWithPreview('general-chat');
    ```
  </Tab>

  <Tab title="Flutter">
    ```dart
    import 'package:amity_sdk/amity_sdk.dart';

    class MessagePreviewManager {
      Future<void> getChannelWithPreview(String channelId) async {
        try {
          final liveObject = AmitySocialClient.newChannelRepository()
              .getChannel(channelId);
          
          liveObject.stream.listen(
            (channel) {
              if (channel.messagePreview != null) {
                _displayPreview(
                  messageId: channel.messagePreview!.messageId!,
                  type: channel.messagePreview!.type!,
                  content: channel.messagePreview!.data?['text'] ?? '',
                  createdAt: channel.messagePreview!.createdAt!,
                  userId: channel.messagePreview!.userId!,
                );
              } else {
                print('No message preview available');
              }
            },
            onError: (error) {
              print('Error getting channel: $error');
            },
          );
        } catch (error) {
          print('Failed to get channel with preview: $error');
        }
      }
      
      void _displayPreview({
        required String messageId,
        required String type,
        required String content,
        required DateTime createdAt,
        required String userId,
      }) {
        final previewText = _formatPreviewContent(type, content);
        final timeString = _formatRelativeTime(createdAt);
        
        print('Latest: $previewText â€¢ $timeString');
        
        // Update UI with preview information
        _updateChatListItem(
          messageId: messageId,
          preview: previewText,
          timestamp: timeString,
          senderId: userId,
        );
      }
      
      String _formatPreviewContent(String type, String content) {
        switch (type) {
          case 'text':
            return content.isEmpty ? 'Message' : content;
          case 'image':
            return 'ðŸ“· Photo';
          case 'video':
            return 'ðŸŽ¥ Video';
          case 'audio':
            return 'ðŸŽµ Audio';
          case 'file':
            return 'ðŸ“„ File';
          case 'custom':
            return 'ðŸ“‹ Custom message';
          default:
            return 'Message';
        }
      }
      
      String _formatRelativeTime(DateTime date) {
        final now = DateTime.now();
        final difference = now.difference(date);
        
        if (difference.inMinutes < 1) return 'Just now';
        if (difference.inMinutes < 60) return '${difference.inMinutes}m ago';
        if (difference.inHours < 24) return '${difference.inHours}h ago';
        
        return '${date.month}/${date.day}';
      }
      
      void _updateChatListItem({
        required String messageId,
        required String preview,
        required String timestamp,
        required String senderId,
      }) {
        // Implement your UI update logic here
        // This could update a ListView, setState, Provider, BLoC, etc.
      }
    }

    // Usage example
    final previewManager = MessagePreviewManager();
    previewManager.getChannelWithPreview('general-chat');
    ```
  </Tab>
</Tabs>

### Subchannel Message Preview

Access message previews for subchannels (threads) using dedicated subchannel object attributes:

<Tabs>
  <Tab title="iOS">
    ```swift
    extension MessagePreviewManager {
        func getSubchannelWithPreview(
            channelId: String,
            subchannelId: String
        ) {
            let liveObject = channelRepository.getSubchannel(
                channelId: channelId,
                subchannelId: subchannelId
            )
            
            liveObject.observe { [weak self] subchannel, error in
                if let error = error {
                    print("Error getting subchannel: \(error)")
                    return
                }
                
                guard let subchannel = subchannel else { return }
                
                // Access subchannel message preview
                if let messagePreview = subchannel.messagePreview {
                    self?.displaySubchannelPreview(
                        subchannelId: subchannelId,
                        messageId: messagePreview.messageId,
                        type: messagePreview.messageType,
                        content: messagePreview.data?["text"] as? String ?? "",
                        createdAt: messagePreview.createdAt,
                        userId: messagePreview.userId
                    )
                } else {
                    print("No subchannel message preview available")
                }
            }
        }
        
        private func displaySubchannelPreview(
            subchannelId: String,
            messageId: String,
            type: AmityMessageType,
            content: String,
            createdAt: Date,
            userId: String
        ) {
            let previewText = formatPreviewContent(type: type, content: content)
            let timeString = formatRelativeTime(createdAt)
            
            print("Thread: \(previewText) â€¢ \(timeString)")
            
            // Update UI with subchannel preview
            DispatchQueue.main.async {
                self.updateThreadPreview(
                    subchannelId: subchannelId,
                    messageId: messageId,
                    preview: previewText,
                    timestamp: timeString,
                    senderId: userId
                )
            }
        }
        
        private func updateThreadPreview(
            subchannelId: String,
            messageId: String,
            preview: String,
            timestamp: String,
            senderId: String
        ) {
            // Update subchannel UI elements
            // This could update thread indicators, preview bubbles, etc.
        }
    }
    ```
  </Tab>

  <Tab title="Android">
    ```kotlin
    fun getSubchannelWithPreview(channelId: String, subchannelId: String) {
        channelRepository.getSubchannel(channelId, subchannelId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                { subchannel ->
                    // Access subchannel message preview
                    subchannel.messagePreview?.let { preview ->
                        displaySubchannelPreview(
                            subchannelId = subchannelId,
                            messageId = preview.messageId,
                            type = preview.type,
                            content = preview.data?.get("text") as? String ?: "",
                            createdAt = preview.createdAt,
                            userId = preview.userId
                        )
                    } ?: run {
                        println("No subchannel message preview available")
                    }
                },
                { error ->
                    println("Error getting subchannel: $error")
                }
            )
    }
    
    private fun displaySubchannelPreview(
        subchannelId: String,
        messageId: String,
        type: String,
        content: String,
        createdAt: Date,
        userId: String
    ) {
        val previewText = formatPreviewContent(type, content)
        val timeString = formatRelativeTime(createdAt)
        
        println("Thread: $previewText â€¢ $timeString")
        
        // Update UI with subchannel preview
        updateThreadPreview(
            subchannelId = subchannelId,
            messageId = messageId,
            preview = previewText,
            timestamp = timeString,
            senderId = userId
        )
    }
    
    private fun updateThreadPreview(
        subchannelId: String,
        messageId: String,
        preview: String,
        timestamp: String,
        senderId: String
    ) {
        // Update subchannel UI elements
        // This could update thread indicators, preview bubbles, etc.
    }
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    async getSubchannelWithPreview(channelId, subchannelId) {
        try {
            const liveObject = this.channelRepository.getSubchannel(
                channelId, 
                subchannelId
            );
            
            liveObject.on('dataUpdated', (subchannel) => {
                if (subchannel.messagePreview) {
                    this.displaySubchannelPreview({
                        subchannelId,
                        messageId: subchannel.messagePreview.messageId,
                        type: subchannel.messagePreview.type,
                        content: subchannel.messagePreview.data?.text || '',
                        createdAt: subchannel.messagePreview.createdAt,
                        userId: subchannel.messagePreview.userId
                    });
                } else {
                    console.log('No subchannel message preview available');
                }
            });
            
            liveObject.on('dataError', (error) => {
                console.error('Error getting subchannel:', error);
            });
            
        } catch (error) {
            console.error('Failed to get subchannel with preview:', error);
        }
    }
    
    displaySubchannelPreview({
        subchannelId,
        messageId,
        type,
        content,
        createdAt,
        userId
    }) {
        const previewText = this.formatPreviewContent(type, content);
        const timeString = this.formatRelativeTime(new Date(createdAt));
        
        console.log(`Thread: ${previewText} â€¢ ${timeString}`);
        
        // Update UI with subchannel preview
        this.updateThreadPreview({
            subchannelId,
            messageId,
            preview: previewText,
            timestamp: timeString,
            senderId: userId
        });
    }
    
    updateThreadPreview({
        subchannelId,
        messageId,
        preview,
        timestamp,
        senderId
    }) {
        // Update subchannel UI elements
        const threadElement = document.querySelector(`[data-thread-id="${subchannelId}"]`);
        if (threadElement) {
            threadElement.querySelector('.thread-preview').textContent = preview;
            threadElement.querySelector('.thread-timestamp').textContent = timestamp;
        }
    }
    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    async getSubchannelWithPreview(
        channelId: string, 
        subchannelId: string
    ): Promise<void> {
        try {
            const liveObject = this.channelRepository.getSubchannel(
                channelId, 
                subchannelId
            );
            
            liveObject.on('dataUpdated', (subchannel: AmitySubchannel) => {
                if (subchannel.messagePreview) {
                    this.displaySubchannelPreview({
                        subchannelId,
                        messageId: subchannel.messagePreview.messageId,
                        type: subchannel.messagePreview.type,
                        content: subchannel.messagePreview.data?.text || '',
                        createdAt: subchannel.messagePreview.createdAt,
                        userId: subchannel.messagePreview.userId
                    });
                } else {
                    console.log('No subchannel message preview available');
                }
            });
            
            liveObject.on('dataError', (error: Error) => {
                console.error('Error getting subchannel:', error);
            });
            
        } catch (error) {
            console.error('Failed to get subchannel with preview:', error);
        }
    }
    
    private displaySubchannelPreview(data: {
        subchannelId: string;
        messageId: string;
        type: string;
        content: string;
        createdAt: string;
        userId: string;
    }): void {
        const previewText = this.formatPreviewContent(data.type, data.content);
        const timeString = this.formatRelativeTime(new Date(data.createdAt));
        
        console.log(`Thread: ${previewText} â€¢ ${timeString}`);
        
        // Update UI with subchannel preview
        this.updateThreadPreview({
            subchannelId: data.subchannelId,
            messageId: data.messageId,
            preview: previewText,
            timestamp: timeString,
            senderId: data.userId
        });
    }
    
    private updateThreadPreview(data: {
        subchannelId: string;
        messageId: string;
        preview: string;
        timestamp: string;
        senderId: string;
    }): void {
        // Update subchannel UI elements
        const event = new CustomEvent('threadPreviewUpdated', { detail: data });
        document.dispatchEvent(event);
    }
    ```
  </Tab>

  <Tab title="Flutter">
    ```dart
    Future<void> getSubchannelWithPreview(
      String channelId, 
      String subchannelId
    ) async {
      try {
        final liveObject = AmitySocialClient.newChannelRepository()
            .getSubchannel(channelId, subchannelId);
        
        liveObject.stream.listen(
          (subchannel) {
            if (subchannel.messagePreview != null) {
              _displaySubchannelPreview(
                subchannelId: subchannelId,
                messageId: subchannel.messagePreview!.messageId!,
                type: subchannel.messagePreview!.type!,
                content: subchannel.messagePreview!.data?['text'] ?? '',
                createdAt: subchannel.messagePreview!.createdAt!,
                userId: subchannel.messagePreview!.userId!,
              );
            } else {
              print('No subchannel message preview available');
            }
          },
          onError: (error) {
            print('Error getting subchannel: $error');
          },
        );
      } catch (error) {
        print('Failed to get subchannel with preview: $error');
      }
    }
    
    void _displaySubchannelPreview({
      required String subchannelId,
      required String messageId,
      required String type,
      required String content,
      required DateTime createdAt,
      required String userId,
    }) {
      final previewText = _formatPreviewContent(type, content);
      final timeString = _formatRelativeTime(createdAt);
      
      print('Thread: $previewText â€¢ $timeString');
      
      // Update UI with subchannel preview
      _updateThreadPreview(
        subchannelId: subchannelId,
        messageId: messageId,
        preview: previewText,
        timestamp: timeString,
        senderId: userId,
      );
    }
    
    void _updateThreadPreview({
      required String subchannelId,
      required String messageId,
      required String preview,
      required String timestamp,
      required String senderId,
    }) {
      // Update subchannel UI elements
      // This could update thread indicators, preview bubbles, etc.
    }
    ```
  </Tab>
</Tabs>

## Advanced Features

### Smart Preview Caching

Implement intelligent caching for message previews to improve performance:

```javascript
class MessagePreviewCache {
    constructor() {
        this.cache = new Map();
        this.maxSize = 100;
        this.ttl = 5 * 60 * 1000; // 5 minutes
    }
    
    set(key, preview) {
        // Implement LRU cache with TTL
        if (this.cache.size >= this.maxSize) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        
        this.cache.set(key, {
            preview,
            timestamp: Date.now()
        });
    }
    
    get(key) {
        const cached = this.cache.get(key);
        if (!cached) return null;
        
        // Check TTL
        if (Date.now() - cached.timestamp > this.ttl) {
            this.cache.delete(key);
            return null;
        }
        
        return cached.preview;
    }
}
```

### Preview Customization

Customize preview display based on message type and content:

```javascript
class PreviewCustomizer {
    customizePreview(messagePreview, userPreferences) {
        const { type, data } = messagePreview;
        
        switch (type) {
            case 'text':
                return this.customizeTextPreview(data.text, userPreferences);
            case 'image':
                return this.customizeImagePreview(data, userPreferences);
            case 'custom':
                return this.customizeCustomPreview(data, userPreferences);
            default:
                return this.getDefaultPreview(type);
        }
    }
    
    customizeTextPreview(text, preferences) {
        const maxLength = preferences.previewLength || 50;
        
        if (text.length <= maxLength) return text;
        
        return text.substring(0, maxLength) + '...';
    }
    
    customizeImagePreview(data, preferences) {
        const showImagePreview = preferences.showImagePreviews !== false;
        
        if (showImagePreview && data.thumbnailUrl) {
            return {
                type: 'image',
                text: 'ðŸ“· Photo',
                thumbnailUrl: data.thumbnailUrl
            };
        }
        
        return 'ðŸ“· Photo';
    }
}
```

## Use Cases

<AccordionGroup>
  <Accordion title="Chat List with Previews">
    Display the latest message preview in chat lists for better navigation.
    
    ```javascript
    class ChatListWithPreviews {
        constructor() {
            this.previewManager = new MessagePreviewManager();
            this.chatItems = [];
        }
        
        async loadChatList() {
            const channels = await this.getChannels();
            
            for (const channel of channels) {
                await this.previewManager.getChannelWithPreview(channel.channelId);
                
                this.chatItems.push({
                    channelId: channel.channelId,
                    channelName: channel.displayName,
                    preview: channel.messagePreview?.data?.text || 'No messages',
                    timestamp: channel.messagePreview?.createdAt || channel.createdAt,
                    unreadCount: channel.unreadCount || 0
                });
            }
            
            this.renderChatList();
        }
        
        renderChatList() {
            const chatList = document.getElementById('chat-list');
            
            this.chatItems.forEach(item => {
                const chatItem = document.createElement('div');
                chatItem.className = 'chat-item';
                chatItem.innerHTML = `
                    <div class="channel-name">${item.channelName}</div>
                    <div class="preview-text">${item.preview}</div>
                    <div class="timestamp">${this.formatTime(item.timestamp)}</div>
                    ${item.unreadCount > 0 ? `<div class="unread-badge">${item.unreadCount}</div>` : ''}
                `;
                
                chatList.appendChild(chatItem);
            });
        }
    }
    ```
  </Accordion>

  <Accordion title="Push Notification Previews">
    Include message previews in push notifications for better user engagement.
    
    ```javascript
    class NotificationPreviewManager {
        async sendNotificationWithPreview(messageData) {
            const preview = this.formatPreviewForNotification(messageData);
            
            const notification = {
                title: messageData.channelName,
                body: preview.text,
                data: {
                    channelId: messageData.channelId,
                    messageId: messageData.messageId,
                    previewType: preview.type
                }
            };
            
            if (preview.thumbnailUrl) {
                notification.image = preview.thumbnailUrl;
            }
            
            await this.sendPushNotification(notification);
        }
        
        formatPreviewForNotification(messageData) {
            const { type, data, userId } = messageData;
            const senderName = this.getUserName(userId);
            
            switch (type) {
                case 'text':
                    return {
                        text: `${senderName}: ${data.text}`,
                        type: 'text'
                    };
                case 'image':
                    return {
                        text: `${senderName} sent a photo`,
                        type: 'image',
                        thumbnailUrl: data.thumbnailUrl
                    };
                case 'video':
                    return {
                        text: `${senderName} sent a video`,
                        type: 'video'
                    };
                default:
                    return {
                        text: `${senderName} sent a message`,
                        type: 'default'
                    };
            }
        }
    }
    ```
  </Accordion>

  <Accordion title="Thread Preview Indicators">
    Show preview indicators for threaded conversations to improve navigation.
    
    ```javascript
    class ThreadPreviewIndicators {
        constructor() {
            this.threadPreviews = new Map();
        }
        
        updateThreadIndicator(channelId, messageId, threadCount, latestReply) {
            const threadKey = `${channelId}-${messageId}`;
            
            this.threadPreviews.set(threadKey, {
                threadCount,
                latestReply,
                lastUpdated: Date.now()
            });
            
            this.renderThreadIndicator(channelId, messageId);
        }
        
        renderThreadIndicator(channelId, messageId) {
            const messageElement = document.querySelector(
                `[data-message-id="${messageId}"]`
            );
            
            if (!messageElement) return;
            
            const threadData = this.threadPreviews.get(`${channelId}-${messageId}`);
            if (!threadData) return;
            
            const indicator = document.createElement('div');
            indicator.className = 'thread-indicator';
            indicator.innerHTML = `
                <div class="thread-count">${threadData.threadCount} replies</div>
                <div class="thread-preview">${threadData.latestReply.preview}</div>
                <div class="thread-time">${this.formatTime(threadData.latestReply.createdAt)}</div>
            `;
            
            messageElement.appendChild(indicator);
        }
    }
    ```
  </Accordion>
</AccordionGroup>

## Best Practices

### Performance Optimization

1. **Efficient Caching**: Implement smart caching with TTL to reduce API calls
2. **Lazy Loading**: Load previews only when needed for visible items
3. **Batch Updates**: Group multiple preview updates to reduce UI thrashing
4. **Memory Management**: Clean up unused preview data to prevent memory leaks

### User Experience

1. **Consistent Formatting**: Use consistent preview formatting across all message types
2. **Visual Hierarchy**: Implement clear visual hierarchy for preview information
3. **Loading States**: Show loading indicators while previews are being fetched
4. **Error Handling**: Gracefully handle preview loading failures

### Security Considerations

1. **Content Filtering**: Apply content filtering to preview text
2. **Privacy Settings**: Respect user privacy settings for preview visibility
3. **Data Validation**: Validate preview data before displaying
4. **Access Control**: Ensure proper permissions for preview access

<Note>
Message previews are automatically updated when new messages arrive. Implement proper error handling and fallback mechanisms to ensure a smooth user experience even when previews are unavailable.
</Note>