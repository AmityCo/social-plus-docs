---
title: "Get Channels"
description: "Retrieve and monitor multiple channels with real-time updates and efficient batch operations"
---

# Get Channels

Efficiently retrieve multiple channels by their IDs with real-time synchronization. Perfect for channel listings, user dashboards, and managing multiple conversations simultaneously.

<CardGroup cols={2}>
  <Card title="Batch Retrieval" icon="list">
    Get up to 100 channels in a single efficient operation
  </Card>
  <Card title="Real-time Updates" icon="sync">
    Automatic updates when channel information changes
  </Card>
  <Card title="Live Collections" icon="database">
    Reactive data that stays synchronized across your app
  </Card>
  <Card title="Smart Filtering" icon="filter">
    Automatic filtering of invalid or inaccessible channels
  </Card>
</CardGroup>

## Overview

The `getChannels` method provides efficient batch retrieval of multiple channels with built-in real-time synchronization. This is essential for creating channel lists, user dashboards, and managing multiple active conversations.

### Key Features
- **Batch Operations**: Retrieve up to 100 channels in a single request
- **Live Collections**: Real-time updates without manual refresh
- **Smart Filtering**: Automatically excludes invalid or inaccessible channels
- **Permission Aware**: Respects user permissions and channel access
- **Performance Optimized**: Efficient data loading and caching

<Warning>
Maximum of 100 channels can be queried in a single request. For larger datasets, implement pagination or chunking strategies.
</Warning>

## Parameters

<ParamField path="channelIds" type="string[]" required>
  Array of channel IDs to retrieve (maximum 100 channels)
</ParamField>

<ParamField path="options" type="object">
  Additional options for channel retrieval
  
  <Expandable title="options properties">
    <ParamField path="includeDeleted" type="boolean" default="false">
      Include archived or deleted channels in results
    </ParamField>
    
    <ParamField path="sortBy" type="string" default="lastActivity">
      Sort channels by: 'lastActivity', 'createdAt', 'memberCount', 'displayName'
    </ParamField>
    
    <ParamField path="sortDirection" type="string" default="desc">
      Sort direction: 'asc' or 'desc'
    </ParamField>
  </Expandable>
</ParamField>

## Implementation

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    import { ChannelRepository } from '@amityco/ts-sdk';

    // Basic channel retrieval
    const getMultipleChannels = async (channelIds: string[]) => {
      try {
        const liveCollection = ChannelRepository.getChannels(channelIds);
        
        // Subscribe to real-time updates
        liveCollection.on('dataUpdated', (channels) => {
          console.log(`Retrieved ${channels.length} channels`);
          console.log('Channels:', channels.map(c => ({
            id: c.channelId,
            name: c.displayName,
            memberCount: c.memberCount,
            isJoined: c.isJoined
          })));
        });

        liveCollection.on('dataError', (error) => {
          console.error('Failed to load channels:', error);
        });

        return liveCollection;
      } catch (error) {
        console.error('Channel retrieval failed:', error);
        throw error;
      }
    };

    // Advanced channel retrieval with options
    const getChannelsWithOptions = async (channelIds: string[]) => {
      try {
        const liveCollection = ChannelRepository.getChannels(channelIds, {
          includeDeleted: false,
          sortBy: 'lastActivity',
          sortDirection: 'desc'
        });

        // Handle data updates
        liveCollection.on('dataUpdated', (channels) => {
          // Filter and process channels
          const activeChannels = channels.filter(channel => 
            channel.isJoined && !channel.isDeleted
          );
          
          console.log(`Active channels: ${activeChannels.length}/${channels.length}`);
          updateChannelList(activeChannels);
        });

        // Handle errors gracefully
        liveCollection.on('dataError', (error) => {
          if (error.code === 'INVALID_CHANNEL_IDS') {
            console.warn('Some channel IDs are invalid');
            // Handle invalid channels
            handleInvalidChannels(error.invalidIds);
          } else {
            console.error('Channel loading error:', error);
            showErrorMessage('Failed to load channels');
          }
        });

        return liveCollection;
      } catch (error) {
        console.error('Advanced channel retrieval failed:', error);
        throw error;
      }
    };

    // Chunked retrieval for large channel sets
    const getChannelsInChunks = async (channelIds: string[], chunkSize = 100) => {
      const chunks = [];
      for (let i = 0; i < channelIds.length; i += chunkSize) {
        chunks.push(channelIds.slice(i, i + chunkSize));
      }

      const liveCollections = chunks.map(chunk => 
        ChannelRepository.getChannels(chunk)
      );

      // Combine results from all chunks
      const allChannels: any[] = [];
      
      liveCollections.forEach((collection, index) => {
        collection.on('dataUpdated', (channels) => {
          // Update the specific chunk
          allChannels[index] = channels;
          
          // Combine all loaded chunks
          const combinedChannels = allChannels.flat().filter(Boolean);
          console.log(`Loaded ${combinedChannels.length} total channels`);
          
          updateCompleteChannelList(combinedChannels);
        });
      });

      return liveCollections;
    };

    // Helper functions
    const updateChannelList = (channels: any[]) => {
      // Update UI with channel data
    };

    const handleInvalidChannels = (invalidIds: string[]) => {
      // Handle invalid channel IDs
      console.warn('Invalid channel IDs:', invalidIds);
    };

    const showErrorMessage = (message: string) => {
      // Show error to user
    };

    const updateCompleteChannelList = (channels: any[]) => {
      // Update UI with complete channel list
    };
    ```
  </Tab>
  <Tab title="React Native">
    ```tsx
    import { ChannelRepository } from '@amityco/react-native-sdk';
    import { useState, useEffect, useCallback } from 'react';

    const ChannelListComponent = ({ channelIds }: { channelIds: string[] }) => {
      const [channels, setChannels] = useState<any[]>([]);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState<string | null>(null);
      const [liveCollection, setLiveCollection] = useState<any>(null);

      useEffect(() => {
        if (!channelIds.length) return;

        const loadChannels = () => {
          try {
            setLoading(true);
            setError(null);

            const collection = ChannelRepository.getChannels(channelIds);

            collection.on('dataUpdated', (updatedChannels: any[]) => {
              setChannels(updatedChannels);
              setLoading(false);
              
              // Sort by last activity
              const sortedChannels = updatedChannels.sort((a, b) => 
                new Date(b.lastActivity).getTime() - new Date(a.lastActivity).getTime()
              );
              
              setChannels(sortedChannels);
            });

            collection.on('dataError', (err: any) => {
              console.error('Channel loading error:', err);
              setError('Failed to load channels');
              setLoading(false);
            });

            setLiveCollection(collection);
          } catch (err) {
            console.error('Failed to initialize channel loading:', err);
            setError('Failed to initialize channels');
            setLoading(false);
          }
        };

        loadChannels();

        // Cleanup on unmount
        return () => {
          if (liveCollection) {
            liveCollection.dispose();
          }
        };
      }, [channelIds]);

      const handleRefresh = useCallback(() => {
        if (liveCollection) {
          liveCollection.refresh();
        }
      }, [liveCollection]);

      const renderChannelItem = (channel: any) => (
        <TouchableOpacity
          key={channel.channelId}
          style={styles.channelItem}
          onPress={() => navigateToChannel(channel.channelId)}
        >
          <View style={styles.channelInfo}>
            <View style={styles.channelHeader}>
              <Text style={styles.channelName}>{channel.displayName}</Text>
              {channel.isJoined && (
                <View style={styles.joinedBadge}>
                  <Text style={styles.joinedText}>Joined</Text>
                </View>
              )}
            </View>
            
            <Text style={styles.memberCount}>
              {channel.memberCount} members
            </Text>
            
            {channel.lastActivity && (
              <Text style={styles.lastActivity}>
                Last activity: {formatDate(channel.lastActivity)}
              </Text>
            )}
          </View>
          
          <View style={styles.channelMeta}>
            {channel.isPublic ? (
              <Icon name="globe" size={16} color="#666" />
            ) : (
              <Icon name="lock" size={16} color="#666" />
            )}
          </View>
        </TouchableOpacity>
      );

      if (loading) {
        return (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#007AFF" />
            <Text style={styles.loadingText}>Loading channels...</Text>
          </View>
        );
      }

      if (error) {
        return (
          <View style={styles.errorContainer}>
            <Text style={styles.errorText}>{error}</Text>
            <Button title="Retry" onPress={handleRefresh} />
          </View>
        );
      }

      return (
        <FlatList
          data={channels}
          renderItem={({ item }) => renderChannelItem(item)}
          keyExtractor={(item) => item.channelId}
          refreshing={loading}
          onRefresh={handleRefresh}
          style={styles.channelList}
          showsVerticalScrollIndicator={false}
        />
      );
    };

    const styles = StyleSheet.create({
      channelList: {
        flex: 1,
        backgroundColor: '#fff',
      },
      channelItem: {
        flexDirection: 'row',
        padding: 16,
        borderBottomWidth: 1,
        borderBottomColor: '#f0f0f0',
      },
      channelInfo: {
        flex: 1,
      },
      channelHeader: {
        flexDirection: 'row',
        alignItems: 'center',
        marginBottom: 4,
      },
      channelName: {
        fontSize: 16,
        fontWeight: '600',
        color: '#333',
        flex: 1,
      },
      joinedBadge: {
        backgroundColor: '#4CAF50',
        paddingHorizontal: 8,
        paddingVertical: 2,
        borderRadius: 12,
      },
      joinedText: {
        color: 'white',
        fontSize: 12,
        fontWeight: '500',
      },
      memberCount: {
        fontSize: 14,
        color: '#666',
        marginBottom: 2,
      },
      lastActivity: {
        fontSize: 12,
        color: '#999',
      },
      channelMeta: {
        justifyContent: 'center',
        alignItems: 'center',
        marginLeft: 12,
      },
      loadingContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
      },
      loadingText: {
        marginTop: 16,
        fontSize: 16,
        color: '#666',
      },
      errorContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        padding: 20,
      },
      errorText: {
        fontSize: 16,
        color: '#FF3B30',
        textAlign: 'center',
        marginBottom: 20,
      },
    });
    ```
  </Tab>
  <Tab title="iOS">
    ```swift
    import AmitySDK

    class ChannelListManager: ObservableObject {
        @Published var channels: [AmityChannel] = []
        @Published var isLoading = false
        @Published var errorMessage: String?
        
        private var channelCollection: AmityCollection<AmityChannel>?
        private let channelRepository: AmityChannelRepository
        
        init(client: AmityClient) {
            self.channelRepository = AmityChannelRepository(client: client)
        }
        
        func loadChannels(channelIds: [String]) {
            guard !channelIds.isEmpty else { return }
            guard channelIds.count <= 100 else {
                errorMessage = "Maximum 100 channels allowed per request"
                return
            }
            
            isLoading = true
            errorMessage = nil
            
            channelCollection = channelRepository.getChannels(channelIds: channelIds)
            
            channelCollection?.observe { [weak self] (collection, change, error) in
                DispatchQueue.main.async {
                    if let error = error {
                        self?.handleError(error)
                        return
                    }
                    
                    switch change {
                    case .initial:
                        self?.channels = collection.object()
                        self?.isLoading = false
                        
                    case .update(let deletions, let insertions, let modifications):
                        self?.updateChannels(
                            collection: collection,
                            deletions: deletions,
                            insertions: insertions,
                            modifications: modifications
                        )
                        
                    case .error(let error):
                        self?.handleError(error)
                    }
                }
            }
        }
        
        private func updateChannels(
            collection: AmityCollection<AmityChannel>,
            deletions: [IndexPath],
            insertions: [IndexPath],
            modifications: [IndexPath]
        ) {
            let newChannels = collection.object()
            
            // Sort by last activity
            let sortedChannels = newChannels.sorted { channel1, channel2 in
                let date1 = channel1.lastActivity ?? channel1.createdAt
                let date2 = channel2.lastActivity ?? channel2.createdAt
                return date1.compare(date2) == .orderedDescending
            }
            
            channels = sortedChannels
            
            print("Channels updated - Total: \(channels.count)")
            print("Deletions: \(deletions.count), Insertions: \(insertions.count), Modifications: \(modifications.count)")
        }
        
        private func handleError(_ error: Error) {
            isLoading = false
            
            if let amityError = error as? AmityError {
                switch amityError.code {
                case .invalidChannelIds:
                    errorMessage = "Some channel IDs are invalid"
                case .permissionDenied:
                    errorMessage = "Permission denied to access channels"
                default:
                    errorMessage = "Failed to load channels: \(amityError.localizedDescription)"
                }
            } else {
                errorMessage = "Failed to load channels: \(error.localizedDescription)"
            }
            
            print("Channel loading error: \(error)")
        }
        
        func refreshChannels() {
            channelCollection?.refresh()
        }
        
        func loadChannelsInChunks(channelIds: [String], chunkSize: Int = 100) {
            let chunks = channelIds.chunked(into: chunkSize)
            var allChannels: [AmityChannel] = []
            let group = DispatchGroup()
            
            for chunk in chunks {
                group.enter()
                
                let collection = channelRepository.getChannels(channelIds: chunk)
                collection.observe { (collection, change, error) in
                    defer { group.leave() }
                    
                    if let error = error {
                        print("Error loading chunk: \(error)")
                        return
                    }
                    
                    if case .initial = change {
                        allChannels.append(contentsOf: collection.object())
                    }
                }
            }
            
            group.notify(queue: .main) {
                self.channels = allChannels.sorted { channel1, channel2 in
                    let date1 = channel1.lastActivity ?? channel1.createdAt
                    let date2 = channel2.lastActivity ?? channel2.createdAt
                    return date1.compare(date2) == .orderedDescending
                }
                self.isLoading = false
            }
        }
        
        deinit {
            channelCollection = nil
        }
    }

    // SwiftUI View
    struct ChannelListView: View {
        @StateObject private var channelManager: ChannelListManager
        let channelIds: [String]
        
        init(client: AmityClient, channelIds: [String]) {
            self._channelManager = StateObject(wrappedValue: ChannelListManager(client: client))
            self.channelIds = channelIds
        }
        
        var body: some View {
            NavigationView {
                Group {
                    if channelManager.isLoading {
                        ProgressView("Loading channels...")
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                    } else if let errorMessage = channelManager.errorMessage {
                        VStack {
                            Text(errorMessage)
                                .foregroundColor(.red)
                                .multilineTextAlignment(.center)
                            
                            Button("Retry") {
                                channelManager.loadChannels(channelIds: channelIds)
                            }
                            .padding()
                        }
                    } else {
                        List(channelManager.channels, id: \.channelId) { channel in
                            ChannelRowView(channel: channel)
                        }
                        .refreshable {
                            channelManager.refreshChannels()
                        }
                    }
                }
                .navigationTitle("Channels")
                .onAppear {
                    channelManager.loadChannels(channelIds: channelIds)
                }
            }
        }
    }

    struct ChannelRowView: View {
        let channel: AmityChannel
        
        var body: some View {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    HStack {
                        Text(channel.displayName ?? "Unknown Channel")
                            .font(.headline)
                        
                        if channel.isJoined {
                            Text("Joined")
                                .font(.caption)
                                .padding(.horizontal, 8)
                                .padding(.vertical, 2)
                                .background(Color.green)
                                .foregroundColor(.white)
                                .cornerRadius(8)
                        }
                    }
                    
                    Text("\(channel.memberCount) members")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    if let lastActivity = channel.lastActivity {
                        Text("Last activity: \(lastActivity, formatter: dateFormatter)")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                
                Spacer()
                
                Image(systemName: channel.isPublic ? "globe" : "lock")
                    .foregroundColor(.secondary)
            }
            .padding(.vertical, 4)
        }
        
        private var dateFormatter: DateFormatter {
            let formatter = DateFormatter()
            formatter.dateStyle = .short
            formatter.timeStyle = .short
            return formatter
        }
    }

    extension Array {
        func chunked(into size: Int) -> [[Element]] {
            return stride(from: 0, to: count, by: size).map {
                Array(self[$0..<Swift.min($0 + size, count)])
            }
        }
    }
    ```
  </Tab>
  <Tab title="Android">
    ```kotlin
    import com.amity.socialcloud.sdk.chat.channel.AmityChannelRepository
    import com.amity.socialcloud.sdk.core.AmityClient
    import io.reactivex.android.schedulers.AndroidSchedulers
    import io.reactivex.disposables.CompositeDisposable
    import io.reactivex.schedulers.Schedulers

    class ChannelListManager(private val client: AmityClient) {
        private val channelRepository = AmityChannelRepository(client)
        private val disposables = CompositeDisposable()
        
        fun getChannels(
            channelIds: List<String>,
            callback: ChannelListCallback
        ) {
            if (channelIds.isEmpty()) {
                callback.onError("Channel IDs list is empty")
                return
            }
            
            if (channelIds.size > 100) {
                callback.onError("Maximum 100 channels allowed per request")
                return
            }
            
            callback.onLoading(true)
            
            val liveCollection = channelRepository.getChannels(channelIds)
            
            val disposable = liveCollection.observe()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe({ channelList ->
                    callback.onLoading(false)
                    
                    // Sort channels by last activity
                    val sortedChannels = channelList.sortedByDescending { channel ->
                        channel.getLastActivity()?.time ?: channel.getCreatedAt()?.time ?: 0L
                    }
                    
                    callback.onChannelsLoaded(sortedChannels)
                    
                    Log.d("ChannelList", "Loaded ${sortedChannels.size} channels")
                    
                }, { error ->
                    callback.onLoading(false)
                    
                    val errorMessage = when {
                        error.message?.contains("invalid") == true -> 
                            "Some channel IDs are invalid"
                        error.message?.contains("permission") == true -> 
                            "Permission denied to access channels"
                        else -> "Failed to load channels: ${error.message}"
                    }
                    
                    callback.onError(errorMessage)
                    Log.e("ChannelList", "Error loading channels", error)
                })
            
            disposables.add(disposable)
        }
        
        fun getChannelsInChunks(
            channelIds: List<String>,
            chunkSize: Int = 100,
            callback: ChannelListCallback
        ) {
            val chunks = channelIds.chunked(chunkSize)
            val allChannels = mutableListOf<AmityChannel>()
            var completedChunks = 0
            
            callback.onLoading(true)
            
            chunks.forEach { chunk ->
                val chunkDisposable = channelRepository.getChannels(chunk)
                    .observe()
                    .subscribeOn(Schedulers.io())
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe({ channels ->
                        allChannels.addAll(channels)
                        completedChunks++
                        
                        if (completedChunks == chunks.size) {
                            // All chunks loaded
                            val sortedChannels = allChannels.sortedByDescending { channel ->
                                channel.getLastActivity()?.time ?: channel.getCreatedAt()?.time ?: 0L
                            }
                            
                            callback.onLoading(false)
                            callback.onChannelsLoaded(sortedChannels)
                        }
                        
                    }, { error ->
                        callback.onLoading(false)
                        callback.onError("Failed to load channel chunk: ${error.message}")
                    })
                
                disposables.add(chunkDisposable)
            }
        }
        
        fun refreshChannels(channelIds: List<String>, callback: ChannelListCallback) {
            // Clear existing subscriptions and reload
            disposables.clear()
            getChannels(channelIds, callback)
        }
        
        fun dispose() {
            disposables.dispose()
        }
    }

    interface ChannelListCallback {
        fun onChannelsLoaded(channels: List<AmityChannel>)
        fun onError(error: String)
        fun onLoading(isLoading: Boolean)
    }

    // RecyclerView Adapter
    class ChannelListAdapter(
        private val onChannelClick: (AmityChannel) -> Unit
    ) : RecyclerView.Adapter<ChannelListAdapter.ChannelViewHolder>() {
        
        private var channels = mutableListOf<AmityChannel>()
        
        fun updateChannels(newChannels: List<AmityChannel>) {
            channels.clear()
            channels.addAll(newChannels)
            notifyDataSetChanged()
        }
        
        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ChannelViewHolder {
            val view = LayoutInflater.from(parent.context)
                .inflate(R.layout.item_channel, parent, false)
            return ChannelViewHolder(view)
        }
        
        override fun onBindViewHolder(holder: ChannelViewHolder, position: Int) {
            holder.bind(channels[position])
        }
        
        override fun getItemCount() = channels.size
        
        inner class ChannelViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
            private val channelName: TextView = itemView.findViewById(R.id.channelName)
            private val memberCount: TextView = itemView.findViewById(R.id.memberCount)
            private val lastActivity: TextView = itemView.findViewById(R.id.lastActivity)
            private val joinedBadge: View = itemView.findViewById(R.id.joinedBadge)
            private val visibilityIcon: ImageView = itemView.findViewById(R.id.visibilityIcon)
            
            fun bind(channel: AmityChannel) {
                channelName.text = channel.getDisplayName() ?: "Unknown Channel"
                memberCount.text = "${channel.getMemberCount()} members"
                
                // Show joined status
                joinedBadge.visibility = if (channel.isJoined()) View.VISIBLE else View.GONE
                
                // Show visibility icon
                visibilityIcon.setImageResource(
                    if (channel.isPublic()) R.drawable.ic_globe else R.drawable.ic_lock
                )
                
                // Format last activity
                channel.getLastActivity()?.let { date ->
                    val formatter = SimpleDateFormat("MMM dd, HH:mm", Locale.getDefault())
                    lastActivity.text = "Last activity: ${formatter.format(date)}"
                    lastActivity.visibility = View.VISIBLE
                } ?: run {
                    lastActivity.visibility = View.GONE
                }
                
                itemView.setOnClickListener {
                    onChannelClick(channel)
                }
            }
        }
    }

    // Activity/Fragment usage
    class ChannelListActivity : AppCompatActivity(), ChannelListCallback {
        private lateinit var recyclerView: RecyclerView
        private lateinit var progressBar: ProgressBar
        private lateinit var errorText: TextView
        private lateinit var retryButton: Button
        
        private lateinit var channelManager: ChannelListManager
        private lateinit var adapter: ChannelListAdapter
        
        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContentView(R.layout.activity_channel_list)
            
            initViews()
            setupRecyclerView()
            
            channelManager = ChannelListManager(AmityClient.getInstance())
            
            // Example channel IDs
            val channelIds = intent.getStringArrayListExtra("channel_ids") ?: emptyList()
            channelManager.getChannels(channelIds, this)
        }
        
        private fun initViews() {
            recyclerView = findViewById(R.id.recyclerView)
            progressBar = findViewById(R.id.progressBar)
            errorText = findViewById(R.id.errorText)
            retryButton = findViewById(R.id.retryButton)
            
            retryButton.setOnClickListener {
                val channelIds = intent.getStringArrayListExtra("channel_ids") ?: emptyList()
                channelManager.refreshChannels(channelIds, this)
            }
        }
        
        private fun setupRecyclerView() {
            adapter = ChannelListAdapter { channel ->
                // Navigate to channel detail
                val intent = Intent(this, ChannelDetailActivity::class.java)
                intent.putExtra("channel_id", channel.getChannelId())
                startActivity(intent)
            }
            
            recyclerView.adapter = adapter
            recyclerView.layoutManager = LinearLayoutManager(this)
        }
        
        override fun onChannelsLoaded(channels: List<AmityChannel>) {
            recyclerView.visibility = View.VISIBLE
            progressBar.visibility = View.GONE
            errorText.visibility = View.GONE
            retryButton.visibility = View.GONE
            
            adapter.updateChannels(channels)
        }
        
        override fun onError(error: String) {
            recyclerView.visibility = View.GONE
            progressBar.visibility = View.GONE
            errorText.visibility = View.VISIBLE
            retryButton.visibility = View.VISIBLE
            
            errorText.text = error
        }
        
        override fun onLoading(isLoading: Boolean) {
            progressBar.visibility = if (isLoading) View.VISIBLE else View.GONE
            
            if (isLoading) {
                errorText.visibility = View.GONE
                retryButton.visibility = View.GONE
            }
        }
        
        override fun onDestroy() {
            super.onDestroy()
            channelManager.dispose()
        }
    }
    ```
  </Tab>
  <Tab title="Flutter">
    ```dart
    import 'package:amity_sdk/amity_sdk.dart';

    class ChannelListService {
      
      Future<List<AmityChannel>> getChannels(List<String> channelIds) async {
        if (channelIds.isEmpty) {
          throw Exception('Channel IDs list is empty');
        }
        
        if (channelIds.length > 100) {
          throw Exception('Maximum 100 channels allowed per request');
        }
        
        try {
          final channels = await AmityChatClient.newChannelRepository()
              .getChannels(channelIds);
              
          // Sort by last activity
          channels.sort((a, b) {
            final aTime = a.lastActivity?.millisecondsSinceEpoch ?? 
                         a.createdAt?.millisecondsSinceEpoch ?? 0;
            final bTime = b.lastActivity?.millisecondsSinceEpoch ?? 
                         b.createdAt?.millisecondsSinceEpoch ?? 0;
            return bTime.compareTo(aTime);
          });
          
          return channels;
        } catch (error) {
          print('Failed to get channels: $error');
          rethrow;
        }
      }

      Future<List<AmityChannel>> getChannelsInChunks(
        List<String> channelIds, {
        int chunkSize = 100,
      }) async {
        final chunks = <List<String>>[];
        
        for (int i = 0; i < channelIds.length; i += chunkSize) {
          final end = (i + chunkSize < channelIds.length) 
              ? i + chunkSize 
              : channelIds.length;
          chunks.add(channelIds.sublist(i, end));
        }
        
        final List<AmityChannel> allChannels = [];
        
        for (final chunk in chunks) {
          try {
            final chunkChannels = await getChannels(chunk);
            allChannels.addAll(chunkChannels);
          } catch (error) {
            print('Failed to load chunk: $error');
            // Continue with other chunks
          }
        }
        
        // Sort all channels by last activity
        allChannels.sort((a, b) {
          final aTime = a.lastActivity?.millisecondsSinceEpoch ?? 
                       a.createdAt?.millisecondsSinceEpoch ?? 0;
          final bTime = b.lastActivity?.millisecondsSinceEpoch ?? 
                       b.createdAt?.millisecondsSinceEpoch ?? 0;
          return bTime.compareTo(aTime);
        });
        
        return allChannels;
      }

      Stream<List<AmityChannel>> observeChannels(List<String> channelIds) {
        try {
          return AmityChatClient.newChannelRepository()
              .getChannelsStream(channelIds)
              .map((channels) {
            // Sort by last activity
            channels.sort((a, b) {
              final aTime = a.lastActivity?.millisecondsSinceEpoch ?? 
                           a.createdAt?.millisecondsSinceEpoch ?? 0;
              final bTime = b.lastActivity?.millisecondsSinceEpoch ?? 
                           b.createdAt?.millisecondsSinceEpoch ?? 0;
              return bTime.compareTo(aTime);
            });
            return channels;
          });
        } catch (error) {
          print('Failed to observe channels: $error');
          return Stream.error(error);
        }
      }
    }

    // Widget for displaying channel list
    class ChannelListWidget extends StatefulWidget {
      final List<String> channelIds;
      final Function(AmityChannel)? onChannelTap;
      
      const ChannelListWidget({
        Key? key,
        required this.channelIds,
        this.onChannelTap,
      }) : super(key: key);
      
      @override
      _ChannelListWidgetState createState() => _ChannelListWidgetState();
    }

    class _ChannelListWidgetState extends State<ChannelListWidget> {
      final ChannelListService _channelService = ChannelListService();
      late Stream<List<AmityChannel>> _channelStream;
      
      @override
      void initState() {
        super.initState();
        _channelStream = _channelService.observeChannels(widget.channelIds);
      }

      @override
      Widget build(BuildContext context) {
        return StreamBuilder<List<AmityChannel>>(
          stream: _channelStream,
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    CircularProgressIndicator(),
                    SizedBox(height: 16),
                    Text('Loading channels...'),
                  ],
                ),
              );
            }
            
            if (snapshot.hasError) {
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.error,
                      size: 48,
                      color: Colors.red,
                    ),
                    SizedBox(height: 16),
                    Text(
                      'Failed to load channels',
                      style: TextStyle(
                        fontSize: 16,
                        color: Colors.red,
                      ),
                    ),
                    SizedBox(height: 8),
                    Text(
                      snapshot.error.toString(),
                      style: TextStyle(fontSize: 12, color: Colors.grey),
                      textAlign: TextAlign.center,
                    ),
                    SizedBox(height: 16),
                    ElevatedButton(
                      onPressed: () {
                        setState(() {
                          _channelStream = _channelService.observeChannels(widget.channelIds);
                        });
                      },
                      child: Text('Retry'),
                    ),
                  ],
                ),
              );
            }
            
            final channels = snapshot.data ?? [];
            
            if (channels.isEmpty) {
              return const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.chat_bubble_outline,
                      size: 48,
                      color: Colors.grey,
                    ),
                    SizedBox(height: 16),
                    Text(
                      'No channels found',
                      style: TextStyle(
                        fontSize: 16,
                        color: Colors.grey,
                      ),
                    ),
                  ],
                ),
              );
            }
            
            return RefreshIndicator(
              onRefresh: () async {
                setState(() {
                  _channelStream = _channelService.observeChannels(widget.channelIds);
                });
              },
              child: ListView.builder(
                itemCount: channels.length,
                itemBuilder: (context, index) {
                  final channel = channels[index];
                  return ChannelListItem(
                    channel: channel,
                    onTap: () => widget.onChannelTap?.call(channel),
                  );
                },
              ),
            );
          },
        );
      }
    }

    class ChannelListItem extends StatelessWidget {
      final AmityChannel channel;
      final VoidCallback? onTap;
      
      const ChannelListItem({
        Key? key,
        required this.channel,
        this.onTap,
      }) : super(key: key);

      @override
      Widget build(BuildContext context) {
        return ListTile(
          onTap: onTap,
          leading: CircleAvatar(
            backgroundColor: channel.isPublic ?? true ? Colors.blue : Colors.orange,
            child: Icon(
              channel.isPublic ?? true ? Icons.public : Icons.lock,
              color: Colors.white,
            ),
          ),
          title: Row(
            children: [
              Expanded(
                child: Text(
                  channel.displayName ?? 'Unknown Channel',
                  style: const TextStyle(
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
              if (channel.isJoined ?? false)
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                  decoration: BoxDecoration(
                    color: Colors.green,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: const Text(
                    'Joined',
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 12,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
            ],
          ),
          subtitle: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('${channel.memberCount ?? 0} members'),
              if (channel.lastActivity != null)
                Text(
                  'Last activity: ${_formatDate(channel.lastActivity!)}',
                  style: const TextStyle(
                    fontSize: 12,
                    color: Colors.grey,
                  ),
                ),
            ],
          ),
          trailing: Icon(
            channel.isPublic ?? true ? Icons.public : Icons.lock,
            color: Colors.grey,
            size: 16,
          ),
        );
      }

      String _formatDate(DateTime date) {
        final now = DateTime.now();
        final difference = now.difference(date);
        
        if (difference.inDays > 0) {
          return '${difference.inDays}d ago';
        } else if (difference.inHours > 0) {
          return '${difference.inHours}h ago';
        } else if (difference.inMinutes > 0) {
          return '${difference.inMinutes}m ago';
        } else {
          return 'Just now';
        }
      }
    }

    // Usage Example
    class ChannelListScreen extends StatelessWidget {
      final List<String> channelIds;
      
      const ChannelListScreen({
        Key? key,
        required this.channelIds,
      }) : super(key: key);

      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(
            title: const Text('Channels'),
            backgroundColor: Colors.blue,
            foregroundColor: Colors.white,
          ),
          body: ChannelListWidget(
            channelIds: channelIds,
            onChannelTap: (channel) {
              Navigator.of(context).pushNamed(
                '/channel-detail',
                arguments: channel.channelId,
              );
            },
          ),
        );
      }
    }
    ```
  </Tab>
</Tabs>

## Behavior & Limitations

<AccordionGroup>
  <Accordion title="Live Collection Behavior">
    **Real-time Updates**: The live collection automatically updates when:
    - Channel information changes (name, description, avatar)
    - Member count updates
    - Channel permissions or visibility changes
    - User join/leave status changes
    
    **Automatic Filtering**: Invalid channels are automatically excluded:
    - Deleted or archived channels (unless explicitly included)
    - Channels the user was banned from
    - Channels that no longer exist
  </Accordion>
  
  <Accordion title="Performance Considerations">
    **Pagination**: This method does not support pagination. For large channel lists:
    - Use chunking strategy for >100 channels
    - Implement virtual scrolling for UI performance
    - Consider caching frequently accessed channels
    
    **Memory Management**: 
    - Live collections maintain active subscriptions
    - Always dispose of collections when no longer needed
    - Use weak references in UI components
  </Accordion>
  
  <Accordion title="Known Limitations">
    **Private Channel Persistence**: If a user leaves a private channel, it may remain in the live collection until:
    - The collection is refreshed manually
    - The application is restarted
    - A new collection is created
    
    **Error Handling**: Invalid channel IDs will cause the entire collection to error:
    - Validate channel IDs before making requests
    - Implement proper error handling for edge cases
    - Consider using chunking to isolate invalid IDs
  </Accordion>
</AccordionGroup>

## Best Practices

<CardGroup cols={2}>
  <Card title="Performance" icon="zap">
    - **Batch Requests**: Always use batch retrieval instead of individual calls
    - **Chunk Large Sets**: Break >100 channels into multiple requests
    - **Cache Results**: Implement local caching for frequently accessed channels
    - **Dispose Properly**: Clean up live collections to prevent memory leaks
  </Card>
  <Card title="User Experience" icon="user">
    - **Loading States**: Show progress indicators during data loading
    - **Error Recovery**: Provide retry mechanisms for failed requests
    - **Real-time Feedback**: Update UI immediately when data changes
    - **Offline Handling**: Cache channel data for offline viewing
  </Card>
  <Card title="Data Management" icon="database">
    - **Validate IDs**: Check channel ID validity before requests
    - **Handle Permissions**: Gracefully handle permission-denied scenarios
    - **Sort Intelligently**: Sort by relevance (last activity, user participation)
    - **Filter Appropriately**: Remove irrelevant or inaccessible channels
  </Card>
  <Card title="Architecture" icon="building">
    - **Separation of Concerns**: Keep data fetching separate from UI logic
    - **State Management**: Use proper state management for complex apps
    - **Error Boundaries**: Implement error boundaries for robust error handling
    - **Type Safety**: Use strong typing for better development experience
  </Card>
</CardGroup>

## Common Use Cases

<Steps>
  <Step title="User Dashboard">
    Display all channels a user has joined or has access to for quick navigation
  </Step>
  <Step title="Channel Search Results">
    Show search results with real-time updates as users type
  </Step>
  <Step title="Recommendation Engine">
    Display recommended channels based on user interests and activity
  </Step>
  <Step title="Admin Panel">
    Manage multiple channels with real-time status monitoring
  </Step>
</Steps>

<Tip>
For optimal performance with large channel lists, implement virtual scrolling in your UI and use the chunking strategy to load channels in batches of 100.
</Tip>