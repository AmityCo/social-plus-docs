---
description: "Advanced image handling with Social+ SDK including upload, processing, optimization, and accessibility features"
---

# Image Processing & Management

Social+ provides comprehensive image handling capabilities with automatic optimization, multiple format support, and accessibility features. This guide covers everything from basic uploads to advanced image processing workflows.

<Note>
**Image Limits**: Maximum file size is 1GB per image. Supported formats: JPEG, PNG, GIF, WebP with automatic optimization and multi-resolution generation.
</Note>

## Overview

Social+ image system offers:
- **Automatic optimization** with multi-resolution generation
- **Smart compression** maintaining visual quality
- **Accessibility support** with alt text and metadata
- **Real-time processing** with instant thumbnails
- **CDN delivery** for global performance
- **Format conversion** and modern format support

## Quick Start

<CodeGroup>

```typescript React/Next.js
import { FileRepository } from '@amityco/js-sdk';

// Upload an image
const uploadImage = async (imageFile: File, altText?: string) => {
  const { data: image } = await FileRepository.createImage({
    file: imageFile,
    altText: altText || ''
  });
  return image;
};

// Get optimized image URL
const getOptimizedImage = (imageUrl: string, size: 'small' | 'medium' | 'large') => {
  return `${imageUrl}?size=${size}`;
};
```

```swift iOS
import AmitySDK

// Upload image with compression
func uploadImage(_ image: UIImage, altText: String? = nil) {
    guard let imageData = image.jpegData(compressionQuality: 0.8) else { return }
    
    var attributes: [String: Any] = [
        "type": "image",
        "mimeType": "image/jpeg"
    ]
    
    if let altText = altText {
        attributes["altText"] = altText
    }
    
    let file = AmityFile(fileData: imageData, attributes: attributes)
    
    AmityFileRepository().uploadImage(file) { progress, imageFile, error in
        if let imageFile = imageFile {
            print("Image uploaded: \(imageFile.fileId)")
        }
    }
}
```

```kotlin Android
import com.amity.socialcloud.sdk.core.file.AmityFileRepository

// Upload image with metadata
val imageRepository = AmityFileRepository(amityClient)

fun uploadImage(imageFile: File, altText: String? = null) {
    val attributes = mutableMapOf<String, Any>(
        "type" to "image",
        "mimeType" to "image/jpeg"
    )
    
    altText?.let { attributes["altText"] = it }
    
    imageRepository.uploadImage(imageFile, attributes)
        .subscribe { uploadedImage ->
            println("Image uploaded: ${uploadedImage.getFileId()}")
        }
}
```

```dart Flutter
import 'package:amity_sdk/amity_sdk.dart';
import 'dart:io';

// Upload image with compression
Future<AmityImage?> uploadImage(File imageFile, {String? altText}) async {
  try {
    final attributes = <String, dynamic>{
      'type': 'image',
      'altText': altText ?? '',
    };
    
    final result = await AmitySocialClient.newFileRepository()
        .uploadImage(imageFile, attributes: attributes);
    
    return result;
  } catch (error) {
    print('Image upload failed: $error');
    return null;
  }
}
```

</CodeGroup>

## Image Properties

Each uploaded image contains comprehensive metadata and multiple optimized versions:

| Property | Type | Description |
|----------|------|-------------|
| `fileId` | `string` | Unique identifier for the image |
| `fileUrl` | `string` | Original high-resolution image URL |
| `filename` | `string` | Original filename with extension |
| `altText` | `string` | Accessibility description text |
| `attributes` | `object` | File metadata including size, type, and dimensions |
| `metadata` | `object` | Image-specific data like width, height, and format |
| `sizes` | `object` | URLs for different optimized versions |
| `isFullImage` | `boolean` | Indicates if original resolution is available |

### Image Metadata Structure

```json
{
  "fileId": "img_12345",
  "fileUrl": "https://cdn.socialplus.com/images/original/img_12345.jpg",
  "attributes": {
    "name": "sunset.jpg",
    "extension": "jpg",
    "size": 2048576,
    "mimeType": "image/jpeg"
  },
  "metadata": {
    "width": 3840,
    "height": 2160, 
    "isFullImage": true,
    "orientation": "landscape"
  },
  "sizes": {
    "small": "https://cdn.socialplus.com/images/160/img_12345.jpg",
    "medium": "https://cdn.socialplus.com/images/600/img_12345.jpg", 
    "large": "https://cdn.socialplus.com/images/1500/img_12345.jpg"
  },
  "altText": "Beautiful sunset over mountain landscape"
}
```

### Available Image Sizes

Social+ automatically generates optimized versions:

- **Small (160px)**: Thumbnails and grid previews
- **Medium (600px)**: Standard content display
- **Large (1500px)**: Full-screen viewing
- **Original**: Unprocessed high-resolution version

## Image Upload

Upload images with automatic optimization, compression, and accessibility features. The SDK handles format conversion and generates multiple resolutions automatically.

### Basic Image Upload

<Tabs>
<Tab title="TypeScript">
```typescript
import { FileRepository } from '@amityco/js-sdk';

// Simple image upload
const uploadImage = async (imageFile: File, altText?: string) => {
  try {
    const { data: image } = await FileRepository.createImage({
      file: imageFile,
      altText: altText || `Image: ${imageFile.name}`
    });
    
    console.log('Image uploaded:', image);
    return image;
  } catch (error) {
    console.error('Image upload failed:', error);
    throw error;
  }
};

// Upload with progress tracking
const uploadImageWithProgress = (imageFile: File, altText?: string) => {
  const liveObject = FileRepository.createImage({
    file: imageFile,
    altText,
    onProgress: ({ currentFile, currentPercent }) => {
      console.log(`Upload progress: ${currentPercent}%`);
      // Update UI progress bar
      updateProgressBar(currentPercent);
    }
  });

  liveObject.on('loadingStatusChanged', ({ newValue, model }) => {
    if (newValue === 'loaded') {
      console.log('Image upload completed:', model);
      onUploadSuccess(model);
    }
  });

  liveObject.on('dataError', (error) => {
    console.error('Upload error:', error);
    onUploadError(error);
  });

  return liveObject;
};

// Batch upload multiple images
const uploadMultipleImages = async (imageFiles: File[], altTexts?: string[]) => {
  const uploadPromises = imageFiles.map((file, index) => 
    FileRepository.createImage({
      file,
      altText: altTexts?.[index] || `Image ${index + 1}`
    })
  );

  const results = await Promise.allSettled(uploadPromises);
  
  return results.map((result, index) => ({
    file: imageFiles[index],
    success: result.status === 'fulfilled',
    data: result.status === 'fulfilled' ? result.value.data : null,
    error: result.status === 'rejected' ? result.reason : null
  }));
};
```
</Tab>

<Tab title="iOS">
```swift
import AmitySDK
import UIKit

class ImageUploadManager {
    private let fileRepository = AmityFileRepository()
    
    func uploadImage(_ image: UIImage, altText: String? = nil, completion: @escaping (AmityFile?, Error?) -> Void) {
        // Optimize image before upload
        guard let optimizedData = optimizeImage(image) else {
            completion(nil, NSError(domain: "ImageOptimization", code: 0, userInfo: [NSLocalizedDescriptionKey: "Failed to optimize image"]))
            return
        }
        
        var attributes: [String: Any] = [
            "type": "image",
            "mimeType": "image/jpeg",
            "originalSize": image.size.debugDescription
        ]
        
        if let altText = altText {
            attributes["altText"] = altText
        }
        
        let file = AmityFile(fileData: optimizedData, attributes: attributes)
        
        fileRepository.uploadImage(file) { [weak self] progress, uploadedFile, error in
            DispatchQueue.main.async {
                if let error = error {
                    completion(nil, error)
                    return
                }
                
                completion(uploadedFile, nil)
            }
        }
    }
    
    private func optimizeImage(_ image: UIImage, maxWidth: CGFloat = 1920, quality: CGFloat = 0.8) -> Data? {
        // Resize if needed
        let resizedImage = resizeImage(image, maxWidth: maxWidth)
        
        // Compress to JPEG
        return resizedImage.jpegData(compressionQuality: quality)
    }
    
    private func resizeImage(_ image: UIImage, maxWidth: CGFloat) -> UIImage {
        let size = image.size
        guard size.width > maxWidth else { return image }
        
        let ratio = maxWidth / size.width
        let newSize = CGSize(width: maxWidth, height: size.height * ratio)
        
        UIGraphicsBeginImageContextWithOptions(newSize, false, 0)
        image.draw(in: CGRect(origin: .zero, size: newSize))
        let resizedImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        return resizedImage ?? image
    }
    
    func uploadMultipleImages(_ images: [UIImage], altTexts: [String]? = nil, completion: @escaping ([AmityFile], [Error]) -> Void) {
        let dispatchGroup = DispatchGroup()
        var uploadedFiles: [AmityFile] = []
        var errors: [Error] = []
        
        for (index, image) in images.enumerated() {
            dispatchGroup.enter()
            
            let altText = altTexts?[safe: index]
            uploadImage(image, altText: altText) { file, error in
                defer { dispatchGroup.leave() }
                
                if let file = file {
                    uploadedFiles.append(file)
                } else if let error = error {
                    errors.append(error)
                }
            }
        }
        
        dispatchGroup.notify(queue: .main) {
            completion(uploadedFiles, errors)
        }
    }
}

extension Array {
    subscript(safe index: Index) -> Element? {
        return indices.contains(index) ? self[index] : nil
    }
}
```
</Tab>

<Tab title="Android">
```kotlin
import com.amity.socialcloud.sdk.core.file.AmityFileRepository
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import java.io.ByteArrayOutputStream
import java.io.File

class ImageUploadManager(private val client: AmityClient) {
    private val fileRepository = AmityFileRepository(client)
    
    fun uploadImage(
        imageFile: File, 
        altText: String? = null,
        quality: Int = 80,
        callback: (AmityFile?, Throwable?) -> Unit
    ) {
        // Optimize image before upload
        val optimizedFile = optimizeImage(imageFile, quality)
        
        val attributes = mutableMapOf<String, Any>(
            "type" to "image",
            "mimeType" to "image/jpeg"
        )
        
        altText?.let { attributes["altText"] = it }
        
        fileRepository.uploadImage(optimizedFile, attributes)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ uploadedImage ->
                callback(uploadedImage, null)
            }, { error ->
                callback(null, error)
            })
    }
    
    private fun optimizeImage(imageFile: File, quality: Int): File {
        val bitmap = BitmapFactory.decodeFile(imageFile.absolutePath)
        
        // Resize if too large
        val resizedBitmap = if (bitmap.width > 1920 || bitmap.height > 1920) {
            val ratio = minOf(1920f / bitmap.width, 1920f / bitmap.height)
            val newWidth = (bitmap.width * ratio).toInt()
            val newHeight = (bitmap.height * ratio).toInt()
            Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true)
        } else {
            bitmap
        }
        
        // Compress to JPEG
        val outputStream = ByteArrayOutputStream()
        resizedBitmap.compress(Bitmap.CompressFormat.JPEG, quality, outputStream)
        
        // Save optimized version
        val optimizedFile = File(imageFile.parent, "optimized_${imageFile.name}")
        optimizedFile.writeBytes(outputStream.toByteArray())
        
        return optimizedFile
    }
    
    fun uploadMultipleImages(
        imageFiles: List<File>,
        altTexts: List<String>? = null,
        callback: (List<AmityFile>, List<Throwable>) -> Unit
    ) {
        val uploadedFiles = mutableListOf<AmityFile>()
        val errors = mutableListOf<Throwable>()
        val completedCount = AtomicInteger(0)
        
        imageFiles.forEachIndexed { index, file ->
            val altText = altTexts?.getOrNull(index)
            
            uploadImage(file, altText) { uploadedFile, error ->
                synchronized(this) {
                    uploadedFile?.let { uploadedFiles.add(it) }
                    error?.let { errors.add(it) }
                    
                    if (completedCount.incrementAndGet() == imageFiles.size) {
                        callback(uploadedFiles, errors)
                    }
                }
            }
        }
    }
}
```
</Tab>

<Tab title="Flutter">
```dart
import 'package:amity_sdk/amity_sdk.dart';
import 'package:image/image.dart' as img;
import 'dart:io';
import 'dart:typed_data';

class ImageUploadManager {
  final AmityFileRepository _fileRepository = AmitySocialClient.newFileRepository();
  
  Future<AmityImage?> uploadImage(File imageFile, {String? altText, int quality = 80}) async {
    try {
      // Optimize image before upload
      final optimizedFile = await optimizeImage(imageFile, quality: quality);
      
      final attributes = <String, dynamic>{
        'type': 'image',
        'altText': altText ?? '',
      };
      
      final result = await _fileRepository.uploadImage(optimizedFile, attributes: attributes);
      print('Image uploaded successfully: ${result.fileId}');
      return result;
    } catch (error) {
      print('Image upload failed: $error');
      return null;
    }
  }
  
  Future<File> optimizeImage(File imageFile, {int quality = 80, int maxWidth = 1920}) async {
    // Read image bytes
    final bytes = await imageFile.readAsBytes();
    final image = img.decodeImage(bytes);
    
    if (image == null) return imageFile;
    
    // Resize if needed
    final resizedImage = image.width > maxWidth 
        ? img.copyResize(image, width: maxWidth)
        : image;
    
    // Compress to JPEG
    final compressedBytes = img.encodeJpg(resizedImage, quality: quality);
    
    // Save optimized version
    final optimizedFile = File('${imageFile.path}_optimized.jpg');
    await optimizedFile.writeAsBytes(compressedBytes);
    
    return optimizedFile;
  }
  
  Future<List<AmityImage>> uploadMultipleImages(
    List<File> imageFiles, {
    List<String>? altTexts,
    int quality = 80
  }) async {
    final uploadedImages = <AmityImage>[];
    
    for (int i = 0; i < imageFiles.length; i++) {
      final file = imageFiles[i];
      final altText = altTexts != null && i < altTexts.length ? altTexts[i] : null;
      
      try {
        final image = await uploadImage(file, altText: altText, quality: quality);
        if (image != null) {
          uploadedImages.add(image);
        }
      } catch (error) {
        print('Failed to upload image ${file.path}: $error');
      }
    }
    
    return uploadedImages;
  }
  
  Stream<double> uploadImageWithProgress(File imageFile, {String? altText}) async* {
    // Note: Actual progress tracking depends on SDK implementation
    yield 0.0;
    
    try {
      await uploadImage(imageFile, altText: altText);
      yield 1.0;
    } catch (error) {
      print('Upload failed: $error');
      yield 0.0;
    }
  }
}
```
</Tab>
</Tabs>

### Advanced Upload Options

<Tabs>
<Tab title="TypeScript">
```typescript
// Upload with custom compression
const uploadCompressedImage = async (file: File, compressionQuality: number = 0.8) => {
  const compressedFile = await compressImage(file, compressionQuality);
  return await FileRepository.createImage({
    file: compressedFile,
    altText: `Compressed image: ${file.name}`
  });
};

const compressImage = (file: File, quality: number): Promise<File> => {
  return new Promise((resolve) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;
    const img = new Image();
    
    img.onload = () => {
      // Set canvas dimensions
      canvas.width = img.width;
      canvas.height = img.height;
      
      // Draw and compress
      ctx.drawImage(img, 0, 0);
      canvas.toBlob((blob) => {
        const compressedFile = new File([blob!], file.name, {
          type: 'image/jpeg',
          lastModified: Date.now()
        });
        resolve(compressedFile);
      }, 'image/jpeg', quality);
    };
    
    img.src = URL.createObjectURL(file);
  });
};

// Upload with watermark
const uploadWithWatermark = async (imageFile: File, watermarkText: string) => {
  const watermarkedFile = await addWatermark(imageFile, watermarkText);
  return await FileRepository.createImage({
    file: watermarkedFile,
    altText: `Watermarked image: ${imageFile.name}`
  });
};

const addWatermark = (file: File, text: string): Promise<File> => {
  return new Promise((resolve) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;
    const img = new Image();
    
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      
      // Draw original image
      ctx.drawImage(img, 0, 0);
      
      // Add watermark
      ctx.font = '30px Arial';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.textAlign = 'right';
      ctx.fillText(text, canvas.width - 20, canvas.height - 20);
      
      canvas.toBlob((blob) => {
        const watermarkedFile = new File([blob!], file.name, {
          type: file.type,
          lastModified: Date.now()
        });
        resolve(watermarkedFile);
      });
    };
    
    img.src = URL.createObjectURL(file);
  });
};
```
</Tab>
</Tabs>

## Image Retrieval & Optimization

Retrieve images in the optimal size for your use case. Social+ automatically generates multiple resolutions for efficient loading and bandwidth optimization.

### Getting Optimized Images

<Tabs>
<Tab title="TypeScript">
```typescript
import { FileRepository } from '@amityco/js-sdk';

// Get image with specific size
const getOptimizedImage = async (imageId: string, size: 'small' | 'medium' | 'large' = 'medium') => {
  try {
    const { data: image } = await FileRepository.getImage(imageId);
    
    // Return appropriate size URL
    return {
      url: image.sizes?.[size] || image.fileUrl,
      metadata: image.metadata,
      altText: image.altText
    };
  } catch (error) {
    console.error('Failed to retrieve image:', error);
    throw error;
  }
};

// Progressive image loading
const loadImageProgressively = async (imageId: string, onProgress: (url: string, size: string) => void) => {
  const { data: image } = await FileRepository.getImage(imageId);
  
  // Load small version first
  if (image.sizes?.small) {
    onProgress(image.sizes.small, 'small');
  }
  
  // Then medium
  if (image.sizes?.medium) {
    onProgress(image.sizes.medium, 'medium');
  }
  
  // Finally large/original
  const finalUrl = image.sizes?.large || image.fileUrl;
  onProgress(finalUrl, 'large');
};

// Responsive image selection
const getResponsiveImage = (image: any, containerWidth: number) => {
  if (containerWidth <= 160) return image.sizes?.small || image.fileUrl;
  if (containerWidth <= 600) return image.sizes?.medium || image.fileUrl;
  if (containerWidth <= 1500) return image.sizes?.large || image.fileUrl;
  return image.fileUrl; // Original for very large containers
};

// Lazy loading with intersection observer
class LazyImageLoader {
  private observer: IntersectionObserver;
  
  constructor() {
    this.observer = new IntersectionObserver(this.handleIntersection.bind(this));
  }
  
  observe(element: HTMLImageElement, imageId: string, size: string = 'medium') {
    element.dataset.imageId = imageId;
    element.dataset.size = size;
    this.observer.observe(element);
  }
  
  private async handleIntersection(entries: IntersectionObserverEntry[]) {
    for (const entry of entries) {
      if (entry.isIntersecting) {
        const img = entry.target as HTMLImageElement;
        const imageId = img.dataset.imageId!;
        const size = img.dataset.size!;
        
        try {
          const imageData = await getOptimizedImage(imageId, size as any);
          img.src = imageData.url;
          img.alt = imageData.altText || '';
          
          this.observer.unobserve(img);
        } catch (error) {
          console.error('Failed to load lazy image:', error);
        }
      }
    }
  }
}
```
</Tab>

<Tab title="iOS">
```swift
import AmitySDK
import UIKit

class ImageRetrievalManager {
    private let fileRepository = AmityFileRepository()
    private let imageCache = NSCache<NSString, UIImage>()
    
    enum ImageSize: String {
        case small = "small"
        case medium = "medium" 
        case large = "large"
        case original = "original"
    }
    
    func getOptimizedImage(
        imageId: String, 
        size: ImageSize = .medium,
        completion: @escaping (UIImage?, Error?) -> Void
    ) {
        // Check cache first
        let cacheKey = "\(imageId)_\(size.rawValue)" as NSString
        if let cachedImage = imageCache.object(forKey: cacheKey) {
            completion(cachedImage, nil)
            return
        }
        
        fileRepository.getImage(withImageId: imageId) { [weak self] imageFile, error in
            guard let self = self, let imageFile = imageFile, error == nil else {
                completion(nil, error)
                return
            }
            
            let imageUrl = self.getImageUrl(for: imageFile, size: size)
            self.downloadImage(from: imageUrl) { image, downloadError in
                if let image = image {
                    self.imageCache.setObject(image, forKey: cacheKey)
                }
                completion(image, downloadError)
            }
        }
    }
    
    private func getImageUrl(for imageFile: AmityFile, size: ImageSize) -> String {
        guard let sizes = imageFile.metadata?["sizes"] as? [String: String] else {
            return imageFile.fileUrl
        }
        
        return sizes[size.rawValue] ?? imageFile.fileUrl
    }
    
    private func downloadImage(from url: String, completion: @escaping (UIImage?, Error?) -> Void) {
        guard let imageUrl = URL(string: url) else {
            completion(nil, NSError(domain: "InvalidURL", code: 0, userInfo: nil))
            return
        }
        
        URLSession.shared.dataTask(with: imageUrl) { data, response, error in
            DispatchQueue.main.async {
                if let error = error {
                    completion(nil, error)
                    return
                }
                
                guard let data = data, let image = UIImage(data: data) else {
                    completion(nil, NSError(domain: "ImageDecoding", code: 0, userInfo: nil))
                    return
                }
                
                completion(image, nil)
            }
        }.resume()
    }
    
    // Progressive loading for better UX
    func loadImageProgressively(
        imageId: String,
        into imageView: UIImageView,
        completion: @escaping (UIImage?) -> Void
    ) {
        // Load small version first
        getOptimizedImage(imageId: imageId, size: .small) { [weak self] smallImage, _ in
            if let smallImage = smallImage {
                imageView.image = smallImage
                
                // Then load medium version
                self?.getOptimizedImage(imageId: imageId, size: .medium) { mediumImage, _ in
                    if let mediumImage = mediumImage {
                        UIView.transition(with: imageView, duration: 0.3, options: .transitionCrossDissolve) {
                            imageView.image = mediumImage
                        }
                        completion(mediumImage)
                    }
                }
            }
        }
    }
}

// Custom image view with progressive loading
class ProgressiveImageView: UIImageView {
    private let imageManager = ImageRetrievalManager()
    
    func loadImage(imageId: String, size: ImageRetrievalManager.ImageSize = .medium) {
        imageManager.getOptimizedImage(imageId: imageId, size: size) { [weak self] image, error in
            if let image = image {
                self?.image = image
            } else if let error = error {
                print("Failed to load image: \(error)")
                // Show placeholder or error image
                self?.image = UIImage(named: "placeholder")
            }
        }
    }
    
    func loadImageProgressively(imageId: String) {
        imageManager.loadImageProgressively(imageId: imageId, into: self) { _ in
            // Image loading completed
        }
    }
}
```
</Tab>

<Tab title="Android">
```kotlin
import com.amity.socialcloud.sdk.core.file.AmityFileRepository
import android.widget.ImageView
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.launch
import com.bumptech.glide.Glide
import com.bumptech.glide.load.engine.DiskCacheStrategy

class ImageRetrievalManager(private val client: AmityClient) {
    private val fileRepository = AmityFileRepository(client)
    
    enum class ImageSize(val value: String) {
        SMALL("small"),
        MEDIUM("medium"),
        LARGE("large"),
        ORIGINAL("original")
    }
    
    fun getOptimizedImage(
        imageId: String,
        size: ImageSize = ImageSize.MEDIUM,
        callback: (String?, Throwable?) -> Unit
    ) {
        fileRepository.getImage(imageId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ imageFile ->
                val imageUrl = getImageUrl(imageFile, size)
                callback(imageUrl, null)
            }, { error ->
                callback(null, error)
            })
    }
    
    private fun getImageUrl(imageFile: AmityFile, size: ImageSize): String {
        val sizes = imageFile.getMetadata()?.get("sizes") as? Map<String, String>
        return sizes?.get(size.value) ?: imageFile.getFileUrl()
    }
    
    // Load image into ImageView with Glide
    fun loadImageIntoView(
        imageId: String,
        imageView: ImageView,
        size: ImageSize = ImageSize.MEDIUM,
        placeholder: Int? = null
    ) {
        getOptimizedImage(imageId, size) { imageUrl, error ->
            if (imageUrl != null) {
                Glide.with(imageView.context)
                    .load(imageUrl)
                    .apply {
                        placeholder?.let { placeholder(it) }
                    }
                    .diskCacheStrategy(DiskCacheStrategy.ALL)
                    .into(imageView)
            } else {
                error?.let { 
                    println("Failed to load image: ${it.message}")
                    placeholder?.let { imageView.setImageResource(it) }
                }
            }
        }
    }
    
    // Progressive loading
    fun loadImageProgressively(
        imageId: String,
        imageView: ImageView,
        onComplete: () -> Unit = {}
    ) {
        // Load small version first
        getOptimizedImage(imageId, ImageSize.SMALL) { smallUrl, _ ->
            smallUrl?.let { url ->
                Glide.with(imageView.context)
                    .load(url)
                    .into(imageView)
                
                // Then load medium version
                getOptimizedImage(imageId, ImageSize.MEDIUM) { mediumUrl, _ ->
                    mediumUrl?.let { mediumUrl ->
                        Glide.with(imageView.context)
                            .load(mediumUrl)
                            .transition(DrawableTransitionOptions.withCrossFade())
                            .into(imageView)
                        onComplete()
                    }
                }
            }
        }
    }
    
    // Responsive image selection
    fun getResponsiveImageUrl(imageFile: AmityFile, containerWidth: Int): String {
        val sizes = imageFile.getMetadata()?.get("sizes") as? Map<String, String>
        
        return when {
            containerWidth <= 160 -> sizes?.get("small") ?: imageFile.getFileUrl()
            containerWidth <= 600 -> sizes?.get("medium") ?: imageFile.getFileUrl()
            containerWidth <= 1500 -> sizes?.get("large") ?: imageFile.getFileUrl()
            else -> imageFile.getFileUrl()
        }
    }
}

// Custom ImageView with progressive loading
class ProgressiveImageView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : ImageView(context, attrs, defStyleAttr) {
    
    private val imageManager = ImageRetrievalManager(AmityClient.getInstance())
    
    fun loadImage(imageId: String, size: ImageRetrievalManager.ImageSize = ImageRetrievalManager.ImageSize.MEDIUM) {
        imageManager.loadImageIntoView(imageId, this, size)
    }
    
    fun loadImageProgressively(imageId: String) {
        imageManager.loadImageProgressively(imageId, this)
    }
}
```
</Tab>

<Tab title="Flutter">
```dart
import 'package:amity_sdk/amity_sdk.dart';
import 'package:flutter/material.dart';
import 'package:cached_network_image/cached_network_image.dart';

class ImageRetrievalManager {
  final AmityFileRepository _fileRepository = AmitySocialClient.newFileRepository();
  
  enum ImageSize {
    small,
    medium,
    large,
    original,
  }
  
  Future<String?> getOptimizedImageUrl(String imageId, [ImageSize size = ImageSize.medium]) async {
    try {
      final imageFile = await _fileRepository.getImage(imageId);
      return _getImageUrl(imageFile, size);
    } catch (error) {
      print('Failed to get optimized image: $error');
      return null;
    }
  }
  
  String _getImageUrl(AmityImage imageFile, ImageSize size) {
    final sizes = imageFile.metadata?['sizes'] as Map<String, String>?;
    
    switch (size) {
      case ImageSize.small:
        return sizes?['small'] ?? imageFile.fileUrl;
      case ImageSize.medium:
        return sizes?['medium'] ?? imageFile.fileUrl;
      case ImageSize.large:
        return sizes?['large'] ?? imageFile.fileUrl;
      case ImageSize.original:
        return imageFile.fileUrl;
    }
  }
  
  String getResponsiveImageUrl(AmityImage imageFile, double containerWidth) {
    if (containerWidth <= 160) return _getImageUrl(imageFile, ImageSize.small);
    if (containerWidth <= 600) return _getImageUrl(imageFile, ImageSize.medium);
    if (containerWidth <= 1500) return _getImageUrl(imageFile, ImageSize.large);
    return imageFile.fileUrl;
  }
}

// Progressive image widget
class ProgressiveImage extends StatefulWidget {
  final String imageId;
  final double? width;
  final double? height;
  final BoxFit fit;
  final String? placeholder;
  final Widget? errorWidget;
  
  const ProgressiveImage({
    Key? key,
    required this.imageId,
    this.width,
    this.height,
    this.fit = BoxFit.cover,
    this.placeholder,
    this.errorWidget,
  }) : super(key: key);
  
  @override
  _ProgressiveImageState createState() => _ProgressiveImageState();
}

class _ProgressiveImageState extends State<ProgressiveImage> {
  final ImageRetrievalManager _imageManager = ImageRetrievalManager();
  String? _imageUrl;
  bool _isLoading = true;
  
  @override
  void initState() {
    super.initState();
    _loadImage();
  }
  
  Future<void> _loadImage() async {
    try {
      // Load small version first
      final smallUrl = await _imageManager.getOptimizedImageUrl(
        widget.imageId, 
        ImageRetrievalManager.ImageSize.small
      );
      
      if (smallUrl != null && mounted) {
        setState(() {
          _imageUrl = smallUrl;
        });
        
        // Then load medium version
        final mediumUrl = await _imageManager.getOptimizedImageUrl(
          widget.imageId,
          ImageRetrievalManager.ImageSize.medium
        );
        
        if (mediumUrl != null && mounted) {
          setState(() {
            _imageUrl = mediumUrl;
            _isLoading = false;
          });
        }
      }
    } catch (error) {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }
  
  @override
  Widget build(BuildContext context) {
    if (_imageUrl == null) {
      return Container(
        width: widget.width,
        height: widget.height,
        child: widget.errorWidget ?? const Icon(Icons.error),
      );
    }
    
    return CachedNetworkImage(
      imageUrl: _imageUrl!,
      width: widget.width,
      height: widget.height,
      fit: widget.fit,
      placeholder: (context, url) => Container(
        width: widget.width,
        height: widget.height,
        child: const Center(child: CircularProgressIndicator()),
      ),
      errorWidget: (context, url, error) => widget.errorWidget ?? const Icon(Icons.error),
    );
  }
}

// Responsive image widget
class ResponsiveImage extends StatelessWidget {
  final String imageId;
  final BoxFit fit;
  final Widget? errorWidget;
  
  const ResponsiveImage({
    Key? key,
    required this.imageId,
    this.fit = BoxFit.cover,
    this.errorWidget,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final imageManager = ImageRetrievalManager();
        
        return FutureBuilder<AmityImage?>(
          future: imageManager._fileRepository.getImage(imageId),
          builder: (context, snapshot) {
            if (snapshot.hasData) {
              final imageFile = snapshot.data!;
              final imageUrl = imageManager.getResponsiveImageUrl(
                imageFile, 
                constraints.maxWidth
              );
              
              return CachedNetworkImage(
                imageUrl: imageUrl,
                fit: fit,
                placeholder: (context, url) => const CircularProgressIndicator(),
                errorWidget: (context, url, error) => errorWidget ?? const Icon(Icons.error),
              );
            } else if (snapshot.hasError) {
              return errorWidget ?? const Icon(Icons.error);
            }
            
            return const CircularProgressIndicator();
          },
        );
      },
    );
  }
}
```
</Tab>
</Tabs>

## Advanced Image Processing

### Image Optimization and Compression

<Tabs>
<Tab title="TypeScript">
```typescript
class ImageProcessor {
  // Smart compression based on image content
  static async compressImage(file: File, options: {
    quality?: number;
    maxWidth?: number;
    maxHeight?: number;
    format?: 'jpeg' | 'webp' | 'png';
    preserveAspectRatio?: boolean;
  } = {}): Promise<File> {
    const {
      quality = 0.8,
      maxWidth = 1920,
      maxHeight = 1080,
      format = 'jpeg',
      preserveAspectRatio = true
    } = options;

    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d')!;
      const img = new Image();

      img.onload = () => {
        // Calculate optimal dimensions
        let { width, height } = img;
        
        if (width > maxWidth || height > maxHeight) {
          if (preserveAspectRatio) {
            const ratio = Math.min(maxWidth / width, maxHeight / height);
            width = width * ratio;
            height = height * ratio;
          } else {
            width = Math.min(width, maxWidth);
            height = Math.min(height, maxHeight);
          }
        }

        canvas.width = width;
        canvas.height = height;

        // Apply image enhancement
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, 0, 0, width, height);

        // Convert to desired format
        const mimeType = `image/${format}`;
        canvas.toBlob((blob) => {
          const compressedFile = new File([blob!], file.name, {
            type: mimeType,
            lastModified: Date.now()
          });
          resolve(compressedFile);
        }, mimeType, quality);
      };

      img.src = URL.createObjectURL(file);
    });
  }

  // Automatic format selection
  static async optimizeForWeb(file: File): Promise<File> {
    // Use WebP for photos, PNG for graphics with transparency
    const supportsWebP = await this.supportsWebP();
    const hasTransparency = await this.hasTransparency(file);
    
    let format: 'jpeg' | 'webp' | 'png' = 'jpeg';
    let quality = 0.85;

    if (hasTransparency) {
      format = 'png';
      quality = 0.9;
    } else if (supportsWebP) {
      format = 'webp';
      quality = 0.8;
    }

    return this.compressImage(file, { format, quality });
  }

  private static async supportsWebP(): Promise<boolean> {
    return new Promise((resolve) => {
      const webP = new Image();
      webP.onload = webP.onerror = () => {
        resolve(webP.height === 2);
      };
      webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';
    });
  }

  private static async hasTransparency(file: File): Promise<boolean> {
    if (file.type === 'image/png' || file.type === 'image/gif') {
      return true;
    }
    
    // More sophisticated transparency detection could be implemented here
    return false;
  }
}

// Usage example
const optimizedUpload = async (imageFile: File, altText: string) => {
  const optimizedFile = await ImageProcessor.optimizeForWeb(imageFile);
  return await FileRepository.createImage({
    file: optimizedFile,
    altText
  });
};
```
</Tab>

<Tab title="iOS">
```swift
import UIKit
import CoreImage

class ImageProcessor {
    static func compressImage(
        _ image: UIImage,
        quality: CGFloat = 0.8,
        maxWidth: CGFloat = 1920,
        maxHeight: CGFloat = 1080
    ) -> Data? {
        // Resize if needed
        let resizedImage = resizeImage(image, maxWidth: maxWidth, maxHeight: maxHeight)
        
        // Apply image enhancement
        let enhancedImage = enhanceImage(resizedImage)
        
        // Compress to JPEG
        return enhancedImage.jpegData(compressionQuality: quality)
    }
    
    private static func resizeImage(
        _ image: UIImage,
        maxWidth: CGFloat,
        maxHeight: CGFloat
    ) -> UIImage {
        let size = image.size
        guard size.width > maxWidth || size.height > maxHeight else {
            return image
        }
        
        let ratio = min(maxWidth / size.width, maxHeight / size.height)
        let newSize = CGSize(width: size.width * ratio, height: size.height * ratio)
        
        UIGraphicsBeginImageContextWithOptions(newSize, false, 0.0)
        image.draw(in: CGRect(origin: .zero, size: newSize))
        let resizedImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        return resizedImage ?? image
    }
    
    private static func enhanceImage(_ image: UIImage) -> UIImage {
        guard let ciImage = CIImage(image: image) else { return image }
        
        let context = CIContext()
        
        // Apply subtle enhancement
        let filter = CIFilter(name: "CIColorControls")
        filter?.setValue(ciImage, forKey: kCIInputImageKey)
        filter?.setValue(1.1, forKey: kCIInputSaturationKey) // Slight saturation boost
        filter?.setValue(1.05, forKey: kCIInputBrightnessKey) // Slight brightness boost
        
        guard let outputImage = filter?.outputImage,
              let cgImage = context.createCGImage(outputImage, from: outputImage.extent) else {
            return image
        }
        
        return UIImage(cgImage: cgImage)
    }
    
    // Smart compression based on image content
    static func smartCompress(_ image: UIImage) -> Data? {
        let hasTransparency = image.cgImage?.alphaInfo != .none
        
        if hasTransparency {
            // Use PNG for images with transparency
            return image.pngData()
        } else {
            // Use JPEG with adaptive quality
            let quality = determineOptimalQuality(image)
            return compressImage(image, quality: quality)
        }
    }
    
    private static func determineOptimalQuality(_ image: UIImage) -> CGFloat {
        let size = image.size
        let pixelCount = size.width * size.height
        
        // Adjust quality based on image size and complexity
        if pixelCount > 2000000 { // Large images
            return 0.7
        } else if pixelCount > 500000 { // Medium images
            return 0.8
        } else { // Small images
            return 0.9
        }
    }
}
```
</Tab>
</Tabs>

### Batch Processing

<Tabs>
<Tab title="TypeScript">
```typescript
class BatchImageProcessor {
  private readonly concurrency: number;
  private readonly queue: Array<() => Promise<any>> = [];
  private running: number = 0;

  constructor(concurrency: number = 3) {
    this.concurrency = concurrency;
  }

  async processBatch(
    files: File[],
    options: {
      altTexts?: string[];
      onProgress?: (completed: number, total: number) => void;
      onError?: (file: File, error: Error) => void;
    } = {}
  ): Promise<Array<{ file: File; result?: any; error?: Error }>> {
    const results: Array<{ file: File; result?: any; error?: Error }> = [];
    let completed = 0;

    const processFile = async (file: File, index: number) => {
      try {
        const optimizedFile = await ImageProcessor.optimizeForWeb(file);
        const altText = options.altTexts?.[index] || `Image ${index + 1}`;
        
        const result = await FileRepository.createImage({
          file: optimizedFile,
          altText
        });

        results[index] = { file, result };
      } catch (error) {
        const err = error as Error;
        results[index] = { file, error: err };
        options.onError?.(file, err);
      } finally {
        completed++;
        options.onProgress?.(completed, files.length);
      }
    };

    // Process files with concurrency limit
    const promises = files.map((file, index) => 
      this.addToQueue(() => processFile(file, index))
    );

    await Promise.all(promises);
    return results;
  }

  private async addToQueue<T>(task: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.queue.push(async () => {
        try {
          const result = await task();
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });

      this.processQueue();
    });
  }

  private async processQueue(): Promise<void> {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }

    this.running++;
    const task = this.queue.shift()!;
    
    try {
      await task();
    } finally {
      this.running--;
      this.processQueue();
    }
  }
}

// Usage
const batchProcessor = new BatchImageProcessor(3);

const uploadMultipleImages = async (files: File[], altTexts: string[]) => {
  const results = await batchProcessor.processBatch(files, {
    altTexts,
    onProgress: (completed, total) => {
      console.log(`Progress: ${completed}/${total} images processed`);
    },
    onError: (file, error) => {
      console.error(`Failed to process ${file.name}:`, error);
    }
  });

  return results;
};
```
</Tab>
</Tabs>

## Performance Optimization

### Lazy Loading and Caching

<Tabs>
<Tab title="TypeScript">
```typescript
class ImageCache {
  private cache = new Map<string, { data: Blob; timestamp: number; size: string }>();
  private readonly maxSize = 50 * 1024 * 1024; // 50MB
  private readonly maxAge = 60 * 60 * 1000; // 1 hour
  private currentSize = 0;

  async getImage(imageId: string, size: string): Promise<Blob | null> {
    const key = `${imageId}_${size}`;
    const cached = this.cache.get(key);
    
    if (cached && Date.now() - cached.timestamp < this.maxAge) {
      return cached.data;
    }

    // Remove expired entry
    if (cached) {
      this.cache.delete(key);
      this.currentSize -= cached.data.size;
    }

    return null;
  }

  async setImage(imageId: string, size: string, data: Blob): Promise<void> {
    const key = `${imageId}_${size}`;
    
    // Check if we need to evict old entries
    while (this.currentSize + data.size > this.maxSize && this.cache.size > 0) {
      this.evictOldest();
    }

    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      size
    });
    
    this.currentSize += data.size;
  }

  private evictOldest(): void {
    let oldestKey: string | null = null;
    let oldestTime = Date.now();

    for (const [key, value] of this.cache.entries()) {
      if (value.timestamp < oldestTime) {
        oldestTime = value.timestamp;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      const cached = this.cache.get(oldestKey)!;
      this.cache.delete(oldestKey);
      this.currentSize -= cached.data.size;
    }
  }
}

// Intersection Observer for lazy loading
class LazyImageLoader {
  private observer: IntersectionObserver;
  private cache = new ImageCache();

  constructor() {
    this.observer = new IntersectionObserver(
      this.handleIntersection.bind(this),
      {
        rootMargin: '50px',
        threshold: 0.1
      }
    );
  }

  observe(element: HTMLImageElement, imageId: string, size: string = 'medium') {
    element.dataset.imageId = imageId;
    element.dataset.size = size;
    element.classList.add('lazy-image');
    this.observer.observe(element);
  }

  private async handleIntersection(entries: IntersectionObserverEntry[]) {
    for (const entry of entries) {
      if (entry.isIntersecting) {
        const img = entry.target as HTMLImageElement;
        const imageId = img.dataset.imageId!;
        const size = img.dataset.size!;

        try {
          await this.loadImage(img, imageId, size);
          this.observer.unobserve(img);
        } catch (error) {
          console.error('Failed to load lazy image:', error);
        }
      }
    }
  }

  private async loadImage(img: HTMLImageElement, imageId: string, size: string) {
    // Check cache first
    let blob = await this.cache.getImage(imageId, size);
    
    if (!blob) {
      // Fetch from server
      const imageData = await getOptimizedImage(imageId, size as any);
      const response = await fetch(imageData.url);
      blob = await response.blob();
      
      // Cache the blob
      await this.cache.setImage(imageId, size, blob);
    }

    // Create object URL and load image
    const objectUrl = URL.createObjectURL(blob);
    
    return new Promise((resolve, reject) => {
      const tempImg = new Image();
      tempImg.onload = () => {
        img.src = objectUrl;
        img.classList.remove('lazy-image');
        img.classList.add('loaded');
        URL.revokeObjectURL(objectUrl);
        resolve(void 0);
      };
      tempImg.onerror = reject;
      tempImg.src = objectUrl;
    });
  }
}
```
</Tab>
</Tabs>

### WebP and Modern Format Support

<Tabs>
<Tab title="TypeScript">
```typescript
class ModernImageSupport {
  private static supportCache = new Map<string, boolean>();

  static async supportsFormat(format: 'webp' | 'avif' | 'heic'): Promise<boolean> {
    if (this.supportCache.has(format)) {
      return this.supportCache.get(format)!;
    }

    let supported = false;

    switch (format) {
      case 'webp':
        supported = await this.testWebPSupport();
        break;
      case 'avif':
        supported = await this.testAVIFSupport();
        break;
      case 'heic':
        supported = await this.testHEICSupport();
        break;
    }

    this.supportCache.set(format, supported);
    return supported;
  }

  private static testWebPSupport(): Promise<boolean> {
    return new Promise((resolve) => {
      const webP = new Image();
      webP.onload = webP.onerror = () => {
        resolve(webP.height === 2);
      };
      webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';
    });
  }

  private static testAVIFSupport(): Promise<boolean> {
    return new Promise((resolve) => {
      const avif = new Image();
      avif.onload = avif.onerror = () => {
        resolve(avif.height === 2);
      };
      avif.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgABogQEAwgMg8f8D///8WfhwB8+ErK42A=';
    });
  }

  private static testHEICSupport(): Promise<boolean> {
    return new Promise((resolve) => {
      // HEIC support is limited, mainly Safari on iOS/macOS
      const isApple = /iPad|iPhone|iPod|Mac/.test(navigator.userAgent);
      resolve(isApple);
    });
  }

  static async getBestImageUrl(imageUrls: {
    webp?: string;
    avif?: string;
    jpeg: string;
    png?: string;
  }): Promise<string> {
    // Check support for modern formats
    if (imageUrls.avif && await this.supportsFormat('avif')) {
      return imageUrls.avif;
    }
    
    if (imageUrls.webp && await this.supportsFormat('webp')) {
      return imageUrls.webp;
    }
    
    // Fallback to standard formats
    return imageUrls.png || imageUrls.jpeg;
  }
}

// Progressive enhancement for images
const createPictureElement = async (
  imageId: string,
  altText: string,
  sizes: { small: string; medium: string; large: string }
) => {
  const picture = document.createElement('picture');
  
  // Add WebP sources if supported
  if (await ModernImageSupport.supportsFormat('webp')) {
    const webpSource = document.createElement('source');
    webpSource.type = 'image/webp';
    webpSource.srcset = `
      ${sizes.small.replace('.jpg', '.webp')} 160w,
      ${sizes.medium.replace('.jpg', '.webp')} 600w,
      ${sizes.large.replace('.jpg', '.webp')} 1500w
    `;
    webpSource.sizes = '(max-width: 160px) 160px, (max-width: 600px) 600px, 1500px';
    picture.appendChild(webpSource);
  }
  
  // Fallback JPEG source
  const jpegSource = document.createElement('source');
  jpegSource.type = 'image/jpeg';
  jpegSource.srcset = `
    ${sizes.small} 160w,
    ${sizes.medium} 600w,
    ${sizes.large} 1500w
  `;
  jpegSource.sizes = '(max-width: 160px) 160px, (max-width: 600px) 600px, 1500px';
  picture.appendChild(jpegSource);
  
  // Fallback img element
  const img = document.createElement('img');
  img.src = sizes.medium;
  img.alt = altText;
  img.loading = 'lazy';
  picture.appendChild(img);
  
  return picture;
};
```
</Tab>
</Tabs>

## Troubleshooting

### Common Image Issues

| Issue | Cause | Solution |
|-------|-------|----------|
| Images appear pixelated | Wrong size selected for display | Use appropriate size (small/medium/large) for container |
| Slow loading times | Large image files | Implement progressive loading and compression |
| Alt text not working | Missing or incorrect alt text | Validate and update alt text using accessibility tools |
| Images not displaying | Broken URLs or network issues | Implement error handling and fallback images |
| Memory issues | Too many high-res images | Use image caching and lazy loading |

### Debug Tools

<Tabs>
<Tab title="TypeScript">
```typescript
class ImageDebugger {
  static analyzeImage(imageElement: HTMLImageElement) {
    const analysis = {
      src: imageElement.src,
      naturalWidth: imageElement.naturalWidth,
      naturalHeight: imageElement.naturalHeight,
      displayWidth: imageElement.width,
      displayHeight: imageElement.height,
      altText: imageElement.alt,
      loading: imageElement.loading,
      aspectRatio: imageElement.naturalWidth / imageElement.naturalHeight,
      isOptimized: this.checkOptimization(imageElement),
      recommendations: this.getRecommendations(imageElement)
    };
    
    console.table(analysis);
    return analysis;
  }
  
  private static checkOptimization(img: HTMLImageElement): boolean {
    const naturalSize = img.naturalWidth * img.naturalHeight;
    const displaySize = img.width * img.height;
    const oversized = naturalSize > displaySize * 2;
    
    return !oversized;
  }
  
  private static getRecommendations(img: HTMLImageElement): string[] {
    const recommendations: string[] = [];
    
    if (!img.alt) {
      recommendations.push('Add alt text for accessibility');
    }
    
    if (img.loading !== 'lazy') {
      recommendations.push('Consider using lazy loading');
    }
    
    if (!this.checkOptimization(img)) {
      recommendations.push('Image is oversized for display - use smaller version');
    }
    
    return recommendations;
  }
}

// Usage
document.querySelectorAll('img').forEach(img => {
  ImageDebugger.analyzeImage(img);
});
```
</Tab>
</Tabs>

## Next Steps

<CardGroup cols={2}>
<Card title="Video Handling" href="./video-handling">
Explore video upload, processing, and streaming capabilities
</Card>
<Card title="File Management" href="./file">
Learn comprehensive file handling and management
</Card>
<Card title="UI Kit Images" href="../../uikit">
Use pre-built image components for faster development
</Card>
<Card title="Posts with Images" href="../social/posts">
Discover how to create rich posts with image attachments
</Card>
</CardGroup>