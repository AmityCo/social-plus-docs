---
title: "Files, Images & Videos"
description: "Comprehensive media handling with upload, processing, and streaming capabilities across all platforms"
---

# Files, Images & Videos

Build rich media experiences with comprehensive file upload, processing, and streaming capabilities. The Social+ SDK provides robust file handling that scales from simple document sharing to advanced video streaming with adaptive quality.

## Overview

The Social+ SDK offers enterprise-grade file management with real-time progress tracking, automatic optimization, and seamless delivery across all platforms.

### Core Capabilities

- **Universal File Support** - Documents, images, videos, audio, and archives
- **Intelligent Processing** - Automatic transcoding, compression, and optimization
- **Adaptive Streaming** - Quality-based video delivery with HLS/DASH support
- **Real-time Progress** - Upload/download tracking with cancellation support
- **Advanced Security** - Content validation, access controls, and malware scanning

<Info>
**File Size Limits**: Documents and images up to 1GB, videos up to 2GB per upload. Enterprise customers can request higher limits.
</Info>

## Architecture

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Client App    │    │   Social+ CDN   │    │  Media Pipeline │
│                 │    │                 │    │                 │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │Upload Queue │ │───▶│ │Intelligent  │ │───▶│ │Transcoding  │ │
│ │& Progress   │ │    │ │Caching      │ │    │ │& Processing │ │
│ └─────────────┘ │    │ └─────────────┘ │    │ └─────────────┘ │
│                 │    │                 │    │                 │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │Media Player │ │◀───│ │Adaptive     │ │◀───│ │Quality      │ │
│ │& Viewer     │ │    │ │Delivery     │ │    │ │Optimization │ │
│ └─────────────┘ │    │ └─────────────┘ │    │ └─────────────┘ │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## Supported Formats

### Images
- **Raster**: JPEG, PNG, WebP, GIF, BMP, TIFF
- **Vector**: SVG (with security validation)
- **Features**: Auto-thumbnails, format conversion, progressive loading

### Videos  
- **Input**: MP4, MOV, AVI, MKV, WebM, M4V
- **Output**: MP4 (H.264/H.265), WebM (VP9)
- **Streaming**: HLS, DASH with adaptive bitrates

### Documents
- **Office**: PDF, DOC, DOCX, PPT, PPTX, XLS, XLSX
- **Text**: TXT, RTF, MD, CSV
- **Features**: Preview generation, text extraction

### Audio
- **Formats**: MP3, WAV, AAC, OGG, FLAC, M4A
- **Features**: Waveform visualization, compression

### Archives
- **Formats**: ZIP, RAR, 7Z, TAR, GZ
- **Security**: Content scanning, extraction limits

## Platform Guides

<CardGroup cols={2}>
  <Card
    title="General File Handling"
    icon="file"
    href="./file"
  >
    Universal file upload, download, and management for all file types
  </Card>
  
  <Card
    title="Image Processing"
    icon="image"
    href="./image-handling"
  >
    Advanced image handling with thumbnails, optimization, and alt-text
  </Card>
  
  <Card
    title="Video Streaming"
    icon="video"
    href="./video-handling"
  >
    Video transcoding, adaptive streaming, and playback optimization
  </Card>
</CardGroup>

## Quick Start Examples

### Basic File Upload

```typescript
import { FileRepository } from '@social-plus/sdk';

// Simple file upload with progress
const uploadFile = async (file: File) => {
  const fileRepo = new FileRepository();
  
  try {
    const result = await fileRepo.upload(file, {
      onProgress: (progress) => {
        console.log(`Upload progress: ${progress}%`);
      },
      onComplete: (fileData) => {
        console.log('Upload complete:', fileData.fileUrl);
      }
    });
    
    return result;
  } catch (error) {
    console.error('Upload failed:', error);
    throw error;
  }
};
```

### Image with Auto-Thumbnails

```typescript
import { ImageRepository, ImageSize } from '@social-plus/sdk';

// Upload image with automatic thumbnail generation
const uploadImage = async (imageFile: File) => {
  const imageRepo = new ImageRepository();
  
  const result = await imageRepo.upload(imageFile, {
    generateThumbnails: true,
    altText: 'User uploaded image',
    sizes: [ImageSize.Small, ImageSize.Medium, ImageSize.Large]
  });
  
  return {
    original: result.fileUrl,
    thumbnail: result.thumbnails.small,
    preview: result.thumbnails.medium,
    fullSize: result.thumbnails.large
  };
};
```

### Video with Adaptive Streaming

```typescript
import { VideoRepository, VideoQuality } from '@social-plus/sdk';

// Upload video with automatic transcoding
const uploadVideo = async (videoFile: File) => {
  const videoRepo = new VideoRepository();
  
  const result = await videoRepo.upload(videoFile, {
    enableTranscoding: true,
    qualities: [VideoQuality.HD, VideoQuality.SD, VideoQuality.Mobile],
    onTranscodingProgress: (progress) => {
      console.log(`Transcoding: ${progress}%`);
    }
  });
  
  return result;
};
```

## Integration Patterns

### React Hook Pattern

```typescript
import { useState, useCallback } from 'react';
import { FileRepository } from '@social-plus/sdk';

export const useFileUpload = () => {
  const [isUploading, setIsUploading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);

  const uploadFile = useCallback(async (file: File) => {
    setIsUploading(true);
    setError(null);
    setProgress(0);

    try {
      const fileRepo = new FileRepository();
      const result = await fileRepo.upload(file, {
        onProgress: setProgress
      });
      
      setIsUploading(false);
      return result;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Upload failed');
      setIsUploading(false);
      throw err;
    }
  }, []);

  return { uploadFile, isUploading, progress, error };
};
```

### SwiftUI Integration

```swift
import SwiftUI
import SocialPlusSDK

struct FileUploadView: View {
    @State private var uploadProgress: Double = 0
    @State private var isUploading = false
    @State private var selectedFile: URL?
    
    var body: some View {
        VStack {
            if isUploading {
                ProgressView("Uploading...", value: uploadProgress, total: 100)
                    .progressViewStyle(LinearProgressViewStyle())
            } else {
                Button("Select File") {
                    presentFilePicker()
                }
            }
        }
    }
    
    private func uploadFile(_ fileURL: URL) {
        isUploading = true
        
        let fileRepo = AmityFileRepository()
        fileRepo.uploadFile(from: fileURL) { progress, file, error in
            DispatchQueue.main.async {
                if let progress = progress {
                    self.uploadProgress = Double(progress.fractionCompleted * 100)
                }
                
                if let file = file {
                    self.isUploading = false
                    print("Upload complete: \(file.fileUrl)")
                }
                
                if let error = error {
                    self.isUploading = false
                    print("Upload error: \(error)")
                }
            }
        }
    }
}
```

### Android Compose Integration

```kotlin
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers
import io.reactivex.rxjava3.schedulers.Schedulers

@Composable
fun FileUploadScreen() {
    var uploadProgress by remember { mutableStateOf(0f) }
    var isUploading by remember { mutableStateOf(false) }
    var uploadedFile by remember { mutableStateOf<AmityFile?>(null) }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        if (isUploading) {
            LinearProgressIndicator(
                progress = uploadProgress,
                modifier = Modifier.fillMaxWidth()
            )
            Text("Uploading: ${(uploadProgress * 100).toInt()}%")
        } else {
            Button(
                onClick = { 
                    // Trigger file picker
                    selectAndUploadFile { progress ->
                        uploadProgress = progress
                    }
                }
            ) {
                Text("Upload File")
            }
        }
        
        uploadedFile?.let { file ->
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 16.dp)
            ) {
                Column(modifier = Modifier.padding(16.dp)) {
                    Text("Upload Complete!")
                    Text("File URL: ${file.fileUrl}")
                }
            }
        }
    }
}

private fun selectAndUploadFile(onProgress: (Float) -> Unit) {
    val fileRepository = AmityFileRepository(client)
    // Implementation for file selection and upload
}
```

## Best Practices

<AccordionGroup>
  <Accordion title="Performance Optimization">
    **Implement Smart Caching**: Use platform-specific caching libraries for optimal performance.
    
    ```typescript
    // React/Web caching strategy
    const fileCache = new Map<string, Blob>();
    
    const getCachedFile = async (url: string): Promise<Blob> => {
      if (fileCache.has(url)) {
        return fileCache.get(url)!;
      }
      
      const response = await fetch(url);
      const blob = await response.blob();
      fileCache.set(url, blob);
      
      return blob;
    };
    ```
    
    **Platform-Specific Recommendations**:
    - **iOS**: Use `SDWebImage` for images, `URLCache` for files
    - **Android**: Use `Glide` for images, `OkHttp` cache for files  
    - **React**: Use `react-query` with custom cache adapters
    - **Flutter**: Use `flutter_cache_manager` for comprehensive caching
  </Accordion>
  
  <Accordion title="User Experience">
    **Progressive Loading**: Always show loading states and provide cancellation options.
    
    ```typescript
    // React component with upload cancellation
    const FileUploader = () => {
      const [controller, setController] = useState<AbortController | null>(null);
      
      const handleUpload = async (file: File) => {
        const abortController = new AbortController();
        setController(abortController);
        
        try {
          await uploadFile(file, {
            signal: abortController.signal,
            onProgress: setProgress
          });
        } catch (error) {
          if (error.name === 'AbortError') {
            console.log('Upload cancelled');
          }
        }
      };
      
      const cancelUpload = () => {
        controller?.abort();
        setController(null);
      };
      
      return (
        <div>
          <input type="file" onChange={(e) => handleUpload(e.target.files[0])} />
          {controller && <button onClick={cancelUpload}>Cancel</button>}
        </div>
      );
    };
    ```
  </Accordion>
  
  <Accordion title="Error Handling & Retry Logic">
    **Implement Robust Error Recovery**: Handle network failures, size limits, and format restrictions.
    
    ```typescript
    class FileUploadService {
      private maxRetries = 3;
      private retryDelays = [1000, 2000, 4000]; // Exponential backoff
      
      async uploadWithRetry(file: File, attempt = 0): Promise<FileData> {
        try {
          return await this.uploadFile(file);
        } catch (error) {
          if (attempt < this.maxRetries && this.isRetryableError(error)) {
            await this.delay(this.retryDelays[attempt]);
            return this.uploadWithRetry(file, attempt + 1);
          }
          
          throw this.enhanceError(error, file);
        }
      }
      
      private isRetryableError(error: any): boolean {
        return error.code === 'NETWORK_ERROR' || 
               error.code === 'TIMEOUT' ||
               error.status >= 500;
      }
      
      private enhanceError(error: any, file: File): Error {
        switch (error.code) {
          case 'FILE_TOO_LARGE':
            return new Error(`File "${file.name}" exceeds maximum size limit`);
          case 'UNSUPPORTED_FORMAT':
            return new Error(`File format "${file.type}" is not supported`);
          case 'STORAGE_QUOTA_EXCEEDED':
            return new Error('Storage quota exceeded. Please delete some files.');
          default:
            return error;
        }
      }
      
      private delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
      }
    }
    ```
  </Accordion>
  
  <Accordion title="Security & Validation">
    **Multi-Layer Validation**: Always validate files on both client and server sides.
    
    ```typescript
    class FileValidator {
      private allowedTypes = new Set([
        'image/jpeg', 'image/png', 'image/webp', 'image/gif',
        'video/mp4', 'video/quicktime', 'video/webm',
        'application/pdf', 'text/plain'
      ]);
      
      private maxSizes = new Map([
        ['image', 10 * 1024 * 1024], // 10MB for images
        ['video', 100 * 1024 * 1024], // 100MB for videos
        ['document', 50 * 1024 * 1024] // 50MB for documents
      ]);
      
      validate(file: File): ValidationResult {
        const errors: string[] = [];
        
        // Type validation
        if (!this.allowedTypes.has(file.type)) {
          errors.push(`File type "${file.type}" is not allowed`);
        }
        
        // Size validation
        const category = this.getFileCategory(file.type);
        const maxSize = this.maxSizes.get(category);
        if (maxSize && file.size > maxSize) {
          errors.push(`File size exceeds limit for ${category} files`);
        }
        
        // Name validation (prevent path traversal)
        if (file.name.includes('..') || file.name.includes('/')) {
          errors.push('Invalid file name');
        }
        
        return {
          isValid: errors.length === 0,
          errors
        };
      }
      
      private getFileCategory(mimeType: string): string {
        if (mimeType.startsWith('image/')) return 'image';
        if (mimeType.startsWith('video/')) return 'video';
        return 'document';
      }
    }
    ```
  </Accordion>
  
  <Accordion title="Bandwidth & Quality Optimization">
    **Adaptive Quality Selection**: Choose appropriate quality based on connection and usage context.
    
    ```typescript
    class MediaQualityManager {
      private connectionSpeed: number = 0;
      
      constructor() {
        this.detectConnectionSpeed();
      }
      
      getOptimalImageSize(context: 'thumbnail' | 'preview' | 'fullscreen'): ImageSize {
        const speedMbps = this.connectionSpeed / (1024 * 1024);
        
        if (context === 'thumbnail') return ImageSize.Small;
        
        if (speedMbps < 1) {
          return context === 'preview' ? ImageSize.Small : ImageSize.Medium;
        } else if (speedMbps < 5) {
          return context === 'preview' ? ImageSize.Medium : ImageSize.Large;
        } else {
          return context === 'preview' ? ImageSize.Large : ImageSize.Original;
        }
      }
      
      getOptimalVideoQuality(): VideoQuality {
        const speedMbps = this.connectionSpeed / (1024 * 1024);
        
        if (speedMbps < 2) return VideoQuality.SD;
        if (speedMbps < 8) return VideoQuality.HD;
        return VideoQuality.FHD;
      }
      
      private async detectConnectionSpeed() {
        try {
          const startTime = Date.now();
          const response = await fetch('/api/speed-test?size=1mb');
          const endTime = Date.now();
          
          const duration = (endTime - startTime) / 1000;
          this.connectionSpeed = (1024 * 1024) / duration; // bytes per second
        } catch {
          this.connectionSpeed = 1024 * 1024; // Default to 1 Mbps
        }
      }
    }
    ```
  </Accordion>
</AccordionGroup>

## Common Use Cases

### Social Media Sharing
Enable users to share photos, videos, and documents in their social feeds with automatic optimization and delivery.

### Chat Attachments
Allow file sharing in conversations with support for various formats and real-time progress tracking.

### Community Resources
Let community members share documents, images, and other resources with appropriate access controls.

### User-Generated Content
Support rich content creation with media uploads, processing, and delivery across your platform.

## Common Use Cases

### Social Media Content
Build engaging social feeds with rich media support and automatic optimization.

```typescript
// Social post with mixed media
const createPost = async (content: string, mediaFiles: File[]) => {
  const mediaUploads = await Promise.all(
    mediaFiles.map(async (file) => {
      if (file.type.startsWith('image/')) {
        return await uploadImage(file, { generateThumbnails: true });
      } else if (file.type.startsWith('video/')) {
        return await uploadVideo(file, { enableTranscoding: true });
      } else {
        return await uploadFile(file);
      }
    })
  );

  return await createSocialPost({
    content,
    media: mediaUploads.map(upload => ({
      id: upload.fileId,
      url: upload.fileUrl,
      type: upload.type,
      thumbnails: upload.thumbnails || null
    }))
  });
};
```

### Chat & Messaging
Enable rich communication with file sharing and real-time progress updates.

```typescript
// Chat message with file attachment
const sendFileMessage = async (chatId: string, file: File) => {
  const messageId = generateTempId();
  
  // Show optimistic UI
  addTempMessage(chatId, {
    id: messageId,
    type: 'file',
    file: { name: file.name, size: file.size },
    status: 'uploading'
  });

  try {
    const uploadResult = await uploadFile(file, {
      onProgress: (progress) => {
        updateMessageProgress(messageId, progress);
      }
    });

    await sendMessage(chatId, {
      type: 'file',
      fileId: uploadResult.fileId,
      fileName: file.name,
      fileSize: file.size,
      fileUrl: uploadResult.fileUrl
    });

    updateMessageStatus(messageId, 'sent');
  } catch (error) {
    updateMessageStatus(messageId, 'failed');
    throw error;
  }
};
```

### Document Management
Create collaborative workspaces with document sharing and version control.

```typescript
// Document collaboration system
class DocumentManager {
  async uploadDocument(file: File, folderId: string) {
    const result = await uploadFile(file, {
      metadata: {
        folderId,
        version: 1,
        uploadedBy: getCurrentUserId(),
        documentType: this.detectDocumentType(file)
      }
    });

    // Generate preview if supported
    if (this.isPreviewSupported(file.type)) {
      await this.generatePreview(result.fileId);
    }

    return result;
  }

  private detectDocumentType(file: File): string {
    const extension = file.name.split('.').pop()?.toLowerCase();
    
    switch (extension) {
      case 'pdf': return 'pdf';
      case 'doc':
      case 'docx': return 'word';
      case 'xls':
      case 'xlsx': return 'excel';
      case 'ppt':
      case 'pptx': return 'powerpoint';
      default: return 'document';
    }
  }
}
```

### E-Learning Platform
Support educational content with video lectures and document resources.

```typescript
// Educational content upload
const uploadLearningMaterial = async (
  courseId: string, 
  file: File, 
  materialType: 'lecture' | 'assignment' | 'resource'
) => {
  const metadata = {
    courseId,
    materialType,
    uploadedBy: getCurrentUserId(),
    category: detectContentCategory(file)
  };

  if (file.type.startsWith('video/')) {
    // Upload with chapter detection and automatic subtitles
    return await uploadVideo(file, {
      enableTranscoding: true,
      generateSubtitles: true,
      detectChapters: true,
      metadata
    });
  } else if (file.type === 'application/pdf') {
    // Upload with text extraction for search
    return await uploadFile(file, {
      extractText: true,
      generateThumbnails: true,
      metadata
    });
  } else {
    return await uploadFile(file, { metadata });
  }
};
```

## Advanced Features

### CDN Integration & Global Delivery

```typescript
// Configure CDN for optimal global delivery
const configureCDN = {
  regions: ['us-east-1', 'eu-west-1', 'ap-southeast-1'],
  caching: {
    images: '7d',
    videos: '30d',
    documents: '1d'
  },
  compression: {
    images: { quality: 85, progressive: true },
    videos: { codec: 'h264', preset: 'faster' }
  }
};
```

### AI-Powered Content Analysis

```typescript
// Content moderation and analysis
const analyzeContent = async (file: File) => {
  const analysisResult = await uploadFile(file, {
    enableModeration: true,
    extractMetadata: true,
    detectObjects: file.type.startsWith('image/'),
    generateTranscript: file.type.startsWith('video/')
  });

  return {
    safetyScore: analysisResult.moderation.safetyScore,
    detectedObjects: analysisResult.analysis.objects,
    transcript: analysisResult.analysis.transcript,
    sentiment: analysisResult.analysis.sentiment
  };
};
```

### Offline Support & Synchronization

```typescript
// Offline-first file handling
class OfflineFileManager {
  private pendingUploads: Map<string, PendingUpload> = new Map();

  async uploadFile(file: File, options: UploadOptions) {
    const uploadId = generateId();
    
    if (!navigator.onLine) {
      // Queue for later upload
      this.pendingUploads.set(uploadId, {
        file,
        options,
        timestamp: Date.now()
      });
      
      return { uploadId, status: 'queued' };
    }

    return await this.performUpload(file, options);
  }

  private async syncPendingUploads() {
    if (!navigator.onLine) return;

    for (const [id, upload] of this.pendingUploads) {
      try {
        await this.performUpload(upload.file, upload.options);
        this.pendingUploads.delete(id);
      } catch (error) {
        console.error('Failed to sync upload:', error);
      }
    }
  }
}
```

## Performance Monitoring

### Upload Analytics

```typescript
// Track upload performance and user behavior
class UploadAnalytics {
  trackUpload(file: File, startTime: number, endTime: number, success: boolean) {
    const metrics = {
      fileSize: file.size,
      fileType: file.type,
      duration: endTime - startTime,
      speed: file.size / (endTime - startTime) * 1000, // bytes per second
      success,
      userAgent: navigator.userAgent,
      connectionType: (navigator as any).connection?.effectiveType
    };

    this.sendMetrics('file_upload', metrics);
  }

  trackError(error: Error, context: UploadContext) {
    this.sendMetrics('upload_error', {
      errorCode: error.code,
      errorMessage: error.message,
      fileSize: context.fileSize,
      fileType: context.fileType,
      retryAttempt: context.retryAttempt
    });
  }
}
```

## Platform-Specific Implementation

<Tabs>
  <Tab title="iOS & macOS">
    **Native Integration**
    ```swift
    // PHPickerViewController for media selection
    import PhotosUI
    
    struct MediaPicker: UIViewControllerRepresentable {
        func makeUIViewController(context: Context) -> PHPickerViewController {
            var config = PHPickerConfiguration()
            config.selectionLimit = 10
            config.filter = .any(of: [.images, .videos])
            
            let picker = PHPickerViewController(configuration: config)
            picker.delegate = context.coordinator
            return picker
        }
    }
    
    // Background uploads
    let uploadTask = URLSession.shared.uploadTask(
        with: request,
        from: fileData
    ) { data, response, error in
        // Handle completion
    }
    ```
    
    **Key Features:**
    - Photos framework integration
    - Background upload support
    - iCloud Drive access
    - Live Photos handling
    - HEIF/HEVC format support
  </Tab>
  
  <Tab title="Android">
    **Modern Android Patterns**
    ```kotlin
    // Storage Access Framework
    class FilePickerActivity : ComponentActivity() {
        private val filePickerLauncher = registerForActivityResult(
            ActivityResultContracts.GetContent()
        ) { uri ->
            uri?.let { uploadFile(it) }
        }
        
        private fun selectFile() {
            filePickerLauncher.launch("*/*")
        }
    }
    
    // Foreground service for large uploads
    class UploadService : Service() {
        override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
            createNotificationChannel()
            startForeground(NOTIFICATION_ID, buildNotification())
            // Perform upload
            return START_STICKY
        }
    }
    ```
    
    **Key Features:**
    - Scoped storage compliance
    - WorkManager for reliable uploads
    - Media3 for video playback
    - Runtime permissions handling
    - Android 14+ photo picker
  </Tab>
  
  <Tab title="Web & React">
    **Modern Web APIs**
    ```typescript
    // Drag & drop with File API
    const FileDropZone = () => {
      const handleDrop = (e: DragEvent) => {
        e.preventDefault();
        const files = Array.from(e.dataTransfer?.files || []);
        files.forEach(uploadFile);
      };
      
      return (
        <div
          onDrop={handleDrop}
          onDragOver={(e) => e.preventDefault()}
          className="drop-zone"
        >
          Drop files here or click to browse
        </div>
      );
    };
    
    // Web Workers for file processing
    const processFileInWorker = (file: File) => {
      const worker = new Worker('/file-processor.js');
      worker.postMessage({ file, action: 'resize' });
      
      return new Promise((resolve) => {
        worker.onmessage = (e) => resolve(e.data);
      });
    };
    ```
    
    **Key Features:**
    - File API & drag-and-drop
    - Web Workers for processing
    - Service Workers for offline
    - WebRTC for peer-to-peer
    - Progressive Web App support
  </Tab>
  
  <Tab title="React Native">
    **Cross-Platform Mobile**
    ```typescript
    import {launchImageLibrary} from 'react-native-image-picker';
    import DocumentPicker from 'react-native-document-picker';
    
    // Image/video selection
    const selectMedia = () => {
      launchImageLibrary({
        mediaType: 'mixed',
        quality: 0.8,
        includeBase64: false
      }, (response) => {
        if (response.assets) {
          response.assets.forEach(uploadAsset);
        }
      });
    };
    
    // Document selection
    const selectDocument = async () => {
      try {
        const result = await DocumentPicker.pick({
          type: [DocumentPicker.types.allFiles]
        });
        uploadFile(result[0]);
      } catch (err) {
        // Handle error
      }
    };
    ```
    
    **Key Features:**
    - Native module integration
    - Cross-platform permissions
    - Optimized bundle size
    - Native performance
    - Platform-specific UI
  </Tab>
  
  <Tab title="Flutter">
    **Unified Mobile Development**
    ```dart
    import 'package:image_picker/image_picker.dart';
    import 'package:file_picker/file_picker.dart';
    
    class MediaPicker {
      final ImagePicker _picker = ImagePicker();
      
      Future<void> pickImage() async {
        final XFile? image = await _picker.pickImage(
          source: ImageSource.gallery,
          maxWidth: 1920,
          maxHeight: 1080,
          imageQuality: 85,
        );
        
        if (image != null) {
          await uploadFile(File(image.path));
        }
      }
      
      Future<void> pickFile() async {
        FilePickerResult? result = await FilePicker.platform.pickFiles(
          type: FileType.any,
          allowMultiple: true,
        );
        
        if (result != null) {
          for (PlatformFile file in result.files) {
            await uploadFile(File(file.path!));
          }
        }
      }
    }
    ```
    
    **Key Features:**
    - Platform channels for native features
    - Unified codebase
    - Widget-based UI
    - Hot reload development
    - AOT compilation
  </Tab>
</Tabs>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Upload Failures">
    **Network Issues**: Implement exponential backoff and connection detection.
    
    ```typescript
    class NetworkAwareUploader {
      async uploadWithNetworkHandling(file: File) {
        if (!navigator.onLine) {
          throw new Error('No internet connection');
        }
        
        const connectionSpeed = await this.measureConnectionSpeed();
        const chunkSize = this.calculateOptimalChunkSize(connectionSpeed);
        
        return this.uploadInChunks(file, chunkSize);
      }
      
      private async measureConnectionSpeed(): Promise<number> {
        const startTime = Date.now();
        try {
          await fetch('/api/speed-test?size=100kb');
          const duration = Date.now() - startTime;
          return (100 * 1024) / (duration / 1000); // bytes per second
        } catch {
          return 128 * 1024; // Default to 128 KB/s
        }
      }
    }
    ```
  </Accordion>
  
  <Accordion title="Memory Management">
    **Large File Handling**: Use streaming and chunked processing to avoid memory issues.
    
    ```typescript
    // Stream processing for large files
    const processLargeFile = async (file: File) => {
      const CHUNK_SIZE = 1024 * 1024; // 1MB chunks
      const stream = file.stream();
      const reader = stream.getReader();
      
      let offset = 0;
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        
        await uploadChunk(value, offset, file.name);
        offset += value.length;
        
        // Update progress
        const progress = (offset / file.size) * 100;
        updateProgress(progress);
      }
    };
    ```
  </Accordion>
  
  <Accordion title="Format Compatibility">
    **Browser/Platform Differences**: Handle format support variations gracefully.
    
    ```typescript
    const getOptimalFormat = (originalType: string): string => {
      const supportedFormats = {
        'image/heic': 'image/jpeg',
        'image/webp': navigator.userAgent.includes('Safari') ? 'image/jpeg' : 'image/webp',
        'video/mov': 'video/mp4'
      };
      
      return supportedFormats[originalType] || originalType;
    };
    ```
  </Accordion>
  
  <Accordion title="Performance Issues">
    **Optimization Strategies**: Implement smart loading and caching strategies.
    
    ```typescript
    // Intersection Observer for lazy loading
    const LazyImage = ({ src, alt }: { src: string; alt: string }) => {
      const [isLoaded, setIsLoaded] = useState(false);
      const imgRef = useRef<HTMLImageElement>(null);
      
      useEffect(() => {
        const observer = new IntersectionObserver(
          ([entry]) => {
            if (entry.isIntersecting) {
              setIsLoaded(true);
              observer.disconnect();
            }
          },
          { threshold: 0.1 }
        );
        
        if (imgRef.current) {
          observer.observe(imgRef.current);
        }
        
        return () => observer.disconnect();
      }, []);
      
      return (
        <img
          ref={imgRef}
          src={isLoaded ? src : '/placeholder.jpg'}
          alt={alt}
          loading="lazy"
        />
      );
    };
    ```
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Implementation Guides" icon="code" href="./file">
    Deep dive into platform-specific file handling implementation
  </Card>
  
  <Card title="Image Processing" icon="image" href="./image-handling">
    Advanced image manipulation, thumbnails, and optimization
  </Card>
  
  <Card title="Video Streaming" icon="video" href="./video-handling">
    Video transcoding, adaptive streaming, and playback optimization
  </Card>
  
  <Card title="Core Concepts" icon="book" href="../core-concept">
    Understanding Social+ SDK fundamentals and architecture
  </Card>
</CardGroup>

<Tip>
**Production Ready**: All examples include error handling, progress tracking, and performance optimizations suitable for production applications.
</Tip>