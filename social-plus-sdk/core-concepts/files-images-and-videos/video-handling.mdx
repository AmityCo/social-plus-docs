---
description: "Comprehensive video handling with Social+ SDK including upload, transcoding, streaming, and multi-resolution support"
---

# Video Processing & Streaming

Social+ provides advanced video handling capabilities with automatic transcoding, multi-resolution support, and streaming optimization. This guide covers everything from basic uploads to advanced video processing workflows.

<Note>
**Video Limits**: Maximum file size is 2GB per video. Supported formats: MP4, MOV, AVI, WebM with automatic transcoding to optimized MP4 versions.
</Note>

## Overview

Social+ video system delivers:
- **Automatic transcoding** to multiple resolutions (360p, 480p, 720p, 1080p)
- **Adaptive streaming** for optimal playback experience
- **Thumbnail generation** for video previews
- **Progress tracking** during upload and transcoding
- **CDN delivery** for global streaming performance
- **Format optimization** for web and mobile playback

## Quick Start

<CodeGroup>

```typescript React/Next.js
import { FileRepository } from '@amityco/js-sdk';

// Upload a video
const uploadVideo = async (videoFile: File) => {
  const { data: video } = await FileRepository.createVideo({
    file: videoFile,
    onProgress: ({ currentPercent }) => {
      console.log(`Upload progress: ${currentPercent}%`);
    }
  });
  return video;
};

// Get video with specific resolution
const getVideoUrl = (video: any, resolution: '360p' | '480p' | '720p' | '1080p' = '720p') => {
  return video.videoUrl?.[resolution] || video.fileUrl;
};
```

```swift iOS
import AmitySDK

// Upload video
func uploadVideo(videoData: Data) {
    let file = AmityFile(fileData: videoData, attributes: ["type": "video"])
    
    AmityFileRepository().uploadVideo(file) { progress, videoFile, error in
        if let videoFile = videoFile {
            print("Video uploaded: \(videoFile.fileId)")
            // Check transcoding status
            checkTranscodingStatus(videoFile)
        }
    }
}

// Check transcoding status
func checkTranscodingStatus(_ video: AmityFile) {
    if let status = video.metadata?["status"] as? String {
        switch status {
        case "transcoded":
            print("Video ready for playback")
        case "transcoding":
            print("Video is being processed")
        case "error":
            print("Transcoding failed")
        default:
            print("Video uploaded, processing will begin")
        }
    }
}
```

```kotlin Android
import com.amity.socialcloud.sdk.core.file.AmityFileRepository

// Upload video
val fileRepository = AmityFileRepository(amityClient)

fun uploadVideo(videoFile: File) {
    val attributes = mapOf("type" to "video")
    
    fileRepository.uploadVideo(videoFile, attributes)
        .subscribe { uploadedVideo ->
            println("Video uploaded: ${uploadedVideo.getFileId()}")
            monitorTranscoding(uploadedVideo.getFileId())
        }
}

// Monitor transcoding progress
fun monitorTranscoding(videoId: String) {
    fileRepository.getVideo(videoId)
        .subscribe { video ->
            val status = video.getMetadata()["status"] as? String
            when (status) {
                "transcoded" -> println("Video ready for playback")
                "transcoding" -> println("Video processing...")
                "error" -> println("Transcoding failed")
            }
        }
}
```

```dart Flutter
import 'package:amity_sdk/amity_sdk.dart';

class VideoUploadManager {
  final AmityFileRepository _fileRepository = AmitySocialClient.newFileRepository();
  
  Future<AmityVideo?> uploadVideo(File videoFile) async {
    try {
      final attributes = {'type': 'video'};
      final result = await _fileRepository.uploadVideo(videoFile, attributes: attributes);
      
      print('Video uploaded: ${result.fileId}');
      return result;
    } catch (error) {
      print('Video upload failed: $error');
      return null;
    }
  }
  
  String getVideoUrl(AmityVideo video, String resolution) {
    final videoUrls = video.metadata?['videoUrl'] as Map<String, String>?;
    return videoUrls?[resolution] ?? video.fileUrl;
  }
}
```

</CodeGroup>

## Video Properties & Transcoding

Each uploaded video undergoes automatic transcoding and provides comprehensive metadata:

| Property | Type | Description |
|----------|------|-------------|
| `fileId` | `string` | Unique identifier for the video |
| `fileUrl` | `string` | Original video file URL (maintains original format) |
| `videoUrl` | `object` | URLs for different transcoded resolutions |
| `status` | `enum` | Transcoding status: `uploaded`, `transcoding`, `transcoded`, `error` |
| `attributes` | `object` | File metadata including name, size, and type |
| `metadata` | `object` | Video-specific data including dimensions and duration |
| `thumbnailFileId` | `string` | ID of the generated thumbnail image |

### Video Metadata Structure

```json
{
  "fileId": "vid_12345",
  "fileUrl": "https://cdn.socialplus.com/videos/original/vid_12345.mov",
  "videoUrl": {
    "original": "https://cdn.socialplus.com/videos/original/vid_12345.mp4",
    "1080p": "https://cdn.socialplus.com/videos/1080p/vid_12345.mp4",
    "720p": "https://cdn.socialplus.com/videos/720p/vid_12345.mp4",
    "480p": "https://cdn.socialplus.com/videos/480p/vid_12345.mp4",
    "360p": "https://cdn.socialplus.com/videos/360p/vid_12345.mp4"
  },
  "status": "transcoded",
  "attributes": {
    "name": "sample_video.mov",
    "extension": "mov", 
    "size": 52428800,
    "mimeType": "video/quicktime",
    "metadata": {
      "video": {
        "width": 1920,
        "height": 1080,
        "duration": 120.5,
        "bit_rate": 8000000,
        "avg_frame_rate": "30/1",
        "display_aspect_ratio": "16:9"
      },
      "audio": {
        "duration": 120.5,
        "bit_rate": 128000,
        "sample_rate": 44100
      }
    }
  },
  "thumbnailFileId": "thumb_12345"
}
```

### Available Resolutions

Social+ automatically generates multiple resolutions for adaptive streaming:

- **Original**: Same resolution as uploaded (in MP4 format)
- **1080p**: 1920×1080 (horizontal) / 1080×1920 (vertical)
- **720p**: 1280×720 (horizontal) / 720×1280 (vertical)  
- **480p**: 640×480 (horizontal) / 480×640 (vertical)
- **360p**: 480×360 (horizontal) / 360×480 (vertical)

<Info>
**Format Note**: The `fileUrl` provides the original file format, while `videoUrl.original` provides the same content in optimized MP4 format.
</Info>

## Video Upload & Processing

Upload videos with automatic transcoding, progress tracking, and format optimization. The SDK handles video compression and generates multiple resolutions for adaptive streaming.

### Basic Video Upload

<Tabs>
<Tab title="TypeScript">
```typescript
import { FileRepository, LoadingStatus } from '@amityco/js-sdk';

// Simple video upload
const uploadVideo = async (videoFile: File) => {
  try {
    const { data: video } = await FileRepository.createVideo(videoFile);
    console.log('Video uploaded:', video);
    return video;
  } catch (error) {
    console.error('Video upload failed:', error);
    throw error;
  }
};

// Upload with progress tracking
const uploadVideoWithProgress = (videoFile: File) => {
  const liveObject = FileRepository.createVideo({
    file: videoFile,
    onProgress: ({ currentFile, currentPercent }) => {
      console.log(`Upload progress: ${currentPercent}%`);
      updateProgressBar(currentPercent);
    }
  });

  liveObject.on('loadingStatusChanged', ({ newValue, model }) => {
    if (newValue === LoadingStatus.Loaded) {
      console.log('Video upload completed:', model);
      handleUploadSuccess(model);
    }
  });

  liveObject.on('dataError', (error) => {
    console.error('Upload error:', error);
    handleUploadError(error);
  });

  return liveObject;
};

// Monitor transcoding status
const monitorTranscoding = async (videoId: string, onStatusChange: (status: string) => void) => {
  const checkStatus = async () => {
    try {
      const { data: video } = await FileRepository.getVideo(videoId);
      const status = video.status || 'uploaded';
      
      onStatusChange(status);
      
      if (status === 'transcoding') {
        // Check again in 5 seconds
        setTimeout(checkStatus, 5000);
      }
    } catch (error) {
      console.error('Failed to check transcoding status:', error);
    }
  };
  
  checkStatus();
};

// Validate video before upload
const validateVideo = (file: File): { valid: boolean; errors: string[] } => {
  const errors: string[] = [];
  const maxSize = 2 * 1024 * 1024 * 1024; // 2GB
  const allowedTypes = [
    'video/mp4', 'video/quicktime', 'video/x-msvideo', 
    'video/webm', 'video/mpeg', 'video/3gpp'
  ];
  
  if (file.size > maxSize) {
    errors.push(`File size ${(file.size / (1024 * 1024 * 1024)).toFixed(2)}GB exceeds 2GB limit`);
  }
  
  if (!allowedTypes.includes(file.type)) {
    errors.push(`File type ${file.type} is not supported`);
  }
  
  return { valid: errors.length === 0, errors };
};
```
</Tab>

<Tab title="iOS">
```swift
import AmitySDK
import AVFoundation

class VideoUploadManager {
    private let fileRepository = AmityFileRepository()
    
    func uploadVideo(
        from url: URL,
        completion: @escaping (AmityFile?, Error?) -> Void
    ) {
        do {
            let videoData = try Data(contentsOf: url)
            uploadVideo(data: videoData, completion: completion)
        } catch {
            completion(nil, error)
        }
    }
    
    func uploadVideo(
        data: Data,
        completion: @escaping (AmityFile?, Error?) -> Void
    ) {
        let attributes: [String: Any] = [
            "type": "video",
            "mimeType": "video/mp4"
        ]
        
        let file = AmityFile(fileData: data, attributes: attributes)
        
        fileRepository.uploadVideo(file) { [weak self] progress, uploadedVideo, error in
            DispatchQueue.main.async {
                if let error = error {
                    completion(nil, error)
                    return
                }
                
                if let uploadedVideo = uploadedVideo {
                    self?.monitorTranscoding(uploadedVideo, completion: completion)
                } else if let progress = progress {
                    print("Upload progress: \(progress * 100)%")
                }
            }
        }
    }
    
    private func monitorTranscoding(
        _ video: AmityFile,
        completion: @escaping (AmityFile?, Error?) -> Void
    ) {
        let checkStatus = {
            self.fileRepository.getVideo(withVideoId: video.fileId) { updatedVideo, error in
                guard let updatedVideo = updatedVideo, error == nil else {
                    completion(nil, error)
                    return
                }
                
                let status = updatedVideo.metadata?["status"] as? String ?? "uploaded"
                
                switch status {
                case "transcoded":
                    completion(updatedVideo, nil)
                case "transcoding":
                    // Check again in 5 seconds
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        self.monitorTranscoding(updatedVideo, completion: completion)
                    }
                case "error":
                    let error = NSError(domain: "TranscodingError", code: 0, userInfo: [
                        NSLocalizedDescriptionKey: "Video transcoding failed"
                    ])
                    completion(nil, error)
                default:
                    // Still processing, check again
                    DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
                        self.monitorTranscoding(updatedVideo, completion: completion)
                    }
                }
            }
        }
        
        checkStatus()
    }
    
    func validateVideo(at url: URL) -> (valid: Bool, errors: [String]) {
        var errors: [String] = []
        
        // Check file size
        do {
            let fileAttributes = try FileManager.default.attributesOfItem(atPath: url.path)
            if let fileSize = fileAttributes[.size] as? Int64 {
                let maxSize: Int64 = 2 * 1024 * 1024 * 1024 // 2GB
                if fileSize > maxSize {
                    errors.append("File size exceeds 2GB limit")
                }
            }
        } catch {
            errors.append("Unable to read file attributes")
        }
        
        // Check video properties
        let asset = AVAsset(url: url)
        let videoTracks = asset.tracks(withMediaType: .video)
        
        if videoTracks.isEmpty {
            errors.append("No video track found")
        }
        
        return (errors.isEmpty, errors)
    }
    
    func compressVideo(
        inputURL: URL,
        outputURL: URL,
        quality: String = AVAssetExportPresetMediumQuality,
        completion: @escaping (Bool, Error?) -> Void
    ) {
        let asset = AVURLAsset(url: inputURL)
        
        guard let exportSession = AVAssetExportSession(asset: asset, presetName: quality) else {
            completion(false, NSError(domain: "CompressionError", code: 0, userInfo: nil))
            return
        }
        
        exportSession.outputURL = outputURL
        exportSession.outputFileType = .mp4
        
        exportSession.exportAsynchronously {
            DispatchQueue.main.async {
                switch exportSession.status {
                case .completed:
                    completion(true, nil)
                case .failed:
                    completion(false, exportSession.error)
                case .cancelled:
                    completion(false, NSError(domain: "CompressionCancelled", code: 0, userInfo: nil))
                default:
                    break
                }
            }
        }
    }
}
```
</Tab>

<Tab title="Android">
```kotlin
import com.amity.socialcloud.sdk.core.file.AmityFileRepository
import android.media.MediaMetadataRetriever
import android.net.Uri

class VideoUploadManager(private val client: AmityClient) {
    private val fileRepository = AmityFileRepository(client)
    
    fun uploadVideo(
        videoFile: File,
        onProgress: (Int) -> Unit = {},
        onSuccess: (AmityFile) -> Unit,
        onError: (Throwable) -> Unit
    ) {
        val validation = validateVideo(videoFile)
        if (!validation.valid) {
            onError(IllegalArgumentException(validation.errors.joinToString(", ")))
            return
        }
        
        val attributes = mapOf(
            "type" to "video",
            "mimeType" to "video/mp4"
        )
        
        fileRepository.uploadVideo(videoFile, attributes)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ uploadedVideo ->
                monitorTranscoding(uploadedVideo.getFileId(), onSuccess, onError)
            }, { error ->
                onError(error)
            })
    }
    
    private fun monitorTranscoding(
        videoId: String,
        onSuccess: (AmityFile) -> Unit,
        onError: (Throwable) -> Unit
    ) {
        val checkStatus = {
            fileRepository.getVideo(videoId)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe({ video ->
                    val status = video.getMetadata()["status"] as? String ?: "uploaded"
                    
                    when (status) {
                        "transcoded" -> onSuccess(video)
                        "transcoding" -> {
                            // Check again in 5 seconds
                            Handler(Looper.getMainLooper()).postDelayed({
                                monitorTranscoding(videoId, onSuccess, onError)
                            }, 5000)
                        }
                        "error" -> onError(Exception("Video transcoding failed"))
                        else -> {
                            // Still processing
                            Handler(Looper.getMainLooper()).postDelayed({
                                monitorTranscoding(videoId, onSuccess, onError)
                            }, 3000)
                        }
                    }
                }, { error ->
                    onError(error)
                })
        }
        
        checkStatus()
    }
    
    data class VideoValidation(val valid: Boolean, val errors: List<String>)
    
    fun validateVideo(file: File): VideoValidation {
        val errors = mutableListOf<String>()
        val maxSize = 2L * 1024 * 1024 * 1024 // 2GB
        
        // Check file size
        if (file.length() > maxSize) {
            errors.add("File size ${file.length() / (1024 * 1024)} MB exceeds 2GB limit")
        }
        
        // Check video properties using MediaMetadataRetriever
        try {
            val retriever = MediaMetadataRetriever()
            retriever.setDataSource(file.absolutePath)
            
            val hasVideo = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_HAS_VIDEO)
            if (hasVideo != "yes") {
                errors.add("File does not contain video track")
            }
            
            retriever.release()
        } catch (e: Exception) {
            errors.add("Unable to read video metadata: ${e.message}")
        }
        
        return VideoValidation(errors.isEmpty(), errors)
    }
    
    fun compressVideo(
        inputFile: File,
        outputFile: File,
        onProgress: (Int) -> Unit = {},
        onComplete: (Boolean, String?) -> Unit
    ) {
        // Video compression implementation would go here
        // This could use FFmpeg or Android's MediaConverter
        // For brevity, showing interface only
        
        try {
            // Implement video compression logic
            onComplete(true, null)
        } catch (e: Exception) {
            onComplete(false, e.message)
        }
    }
}
```
</Tab>

<Tab title="Flutter">
```dart
import 'package:amity_sdk/amity_sdk.dart';
import 'package:video_compress/video_compress.dart';
import 'dart:io';

class VideoUploadManager {
  final AmityFileRepository _fileRepository = AmitySocialClient.newFileRepository();
  
  Future<AmityVideo?> uploadVideo(
    File videoFile, {
    Function(double)? onProgress,
    bool compress = true,
  }) async {
    try {
      // Validate video first
      final validation = await validateVideo(videoFile);
      if (!validation.valid) {
        throw Exception('Video validation failed: ${validation.errors.join(', ')}');
      }
      
      // Compress video if needed
      File fileToUpload = videoFile;
      if (compress) {
        fileToUpload = await compressVideo(videoFile, onProgress: onProgress) ?? videoFile;
      }
      
      final attributes = <String, dynamic>{
        'type': 'video',
        'originalSize': await videoFile.length(),
      };
      
      final result = await _fileRepository.uploadVideo(fileToUpload, attributes: attributes);
      
      // Monitor transcoding
      await _monitorTranscoding(result.fileId);
      
      return result;
    } catch (error) {
      print('Video upload failed: $error');
      return null;
    }
  }
  
  Future<void> _monitorTranscoding(String videoId) async {
    while (true) {
      try {
        final video = await _fileRepository.getVideo(videoId);
        final status = video.metadata?['status'] as String? ?? 'uploaded';
        
        print('Transcoding status: $status');
        
        switch (status) {
          case 'transcoded':
            print('Video transcoding completed');
            return;
          case 'error':
            throw Exception('Video transcoding failed');
          case 'transcoding':
            await Future.delayed(const Duration(seconds: 5));
            break;
          default:
            await Future.delayed(const Duration(seconds: 3));
        }
      } catch (error) {
        print('Error checking transcoding status: $error');
        break;
      }
    }
  }
  
  Future<VideoValidation> validateVideo(File videoFile) async {
    final errors = <String>[];
    const maxSize = 2 * 1024 * 1024 * 1024; // 2GB
    
    // Check file size
    final fileSize = await videoFile.length();
    if (fileSize > maxSize) {
      errors.add('File size ${(fileSize / (1024 * 1024)).toStringAsFixed(1)} MB exceeds 2GB limit');
    }
    
    // Check file extension
    final extension = videoFile.path.split('.').last.toLowerCase();
    const allowedExtensions = ['mp4', 'mov', 'avi', 'webm', '3gp', 'mkv'];
    if (!allowedExtensions.contains(extension)) {
      errors.add('File format .$extension is not supported');
    }
    
    return VideoValidation(valid: errors.isEmpty, errors: errors);
  }
  
  Future<File?> compressVideo(
    File videoFile, {
    VideoQuality quality = VideoQuality.MediumQuality,
    Function(double)? onProgress,
  }) async {
    try {
      print('Starting video compression...');
      
      // Set up compression subscription for progress
      late StreamSubscription subscription;
      if (onProgress != null) {
        subscription = VideoCompress.compressProgress$.listen((progress) {
          onProgress(progress / 100.0);
        });
      }
      
      final info = await VideoCompress.compressVideo(
        videoFile.path,
        quality: quality,
        deleteOrigin: false,
      );
      
      // Cancel progress subscription
      if (onProgress != null) {
        subscription.cancel();
      }
      
      if (info?.file != null) {
        print('Video compressed successfully');
        return info!.file!;
      }
      
      return null;
    } catch (error) {
      print('Video compression failed: $error');
      return null;
    }
  }
  
  Stream<double> uploadVideoWithProgress(File videoFile) async* {
    yield 0.0;
    
    try {
      // Compression phase (50% of progress)
      await for (final progress in _compressVideoStream(videoFile)) {
        yield progress * 0.5;
      }
      
      // Upload phase (remaining 50%)
      final compressedFile = await compressVideo(videoFile);
      if (compressedFile != null) {
        final result = await uploadVideo(compressedFile, compress: false);
        if (result != null) {
          yield 1.0;
        }
      }
    } catch (error) {
      print('Upload with progress failed: $error');
      yield 0.0;
    }
  }
  
  Stream<double> _compressVideoStream(File videoFile) async* {
    // Simulate compression progress
    for (int i = 0; i <= 100; i += 10) {
      yield i / 100.0;
      await Future.delayed(const Duration(milliseconds: 500));
    }
  }
}

class VideoValidation {
  final bool valid;
  final List<String> errors;
  
  VideoValidation({required this.valid, required this.errors});
}
```
</Tab>
</Tabs>

### Advanced Upload Features

<Tabs>
<Tab title="TypeScript">
```typescript
// Upload with custom transcoding settings
const uploadVideoWithSettings = async (videoFile: File, settings: {
  quality?: 'low' | 'medium' | 'high';
  resolutions?: string[];
  generateThumbnail?: boolean;
  thumbnailTime?: number; // seconds
}) => {
  const { data: video } = await FileRepository.createVideo({
    file: videoFile,
    settings: {
      quality: settings.quality || 'medium',
      resolutions: settings.resolutions || ['720p', '480p', '360p'],
      generateThumbnail: settings.generateThumbnail !== false,
      thumbnailTime: settings.thumbnailTime || 5
    }
  });
  
  return video;
};

// Chunked upload for large videos
class ChunkedVideoUploader {
  private readonly chunkSize = 10 * 1024 * 1024; // 10MB chunks
  
  async uploadLargeVideo(
    videoFile: File,
    onProgress: (progress: number) => void
  ): Promise<any> {
    const totalChunks = Math.ceil(videoFile.size / this.chunkSize);
    let uploadedChunks = 0;
    
    const chunks = this.createChunks(videoFile);
    const uploadPromises = chunks.map(async (chunk, index) => {
      const chunkFile = new File([chunk], `${videoFile.name}.chunk.${index}`, {
        type: videoFile.type
      });
      
      const result = await FileRepository.uploadChunk(chunkFile, {
        chunkIndex: index,
        totalChunks,
        originalFileName: videoFile.name
      });
      
      uploadedChunks++;
      onProgress((uploadedChunks / totalChunks) * 100);
      
      return result;
    });
    
    await Promise.all(uploadPromises);
    
    // Merge chunks on server
    return await FileRepository.mergeVideoChunks(videoFile.name, totalChunks);
  }
  
  private createChunks(file: File): Blob[] {
    const chunks: Blob[] = [];
    let start = 0;
    
    while (start < file.size) {
      const end = Math.min(start + this.chunkSize, file.size);
      chunks.push(file.slice(start, end));
      start = end;
    }
    
    return chunks;
  }
}
```
</Tab>
</Tabs>

## Video Retrieval & Streaming

Access transcoded videos in multiple resolutions for optimal playback experience. Social+ provides adaptive streaming capabilities and thumbnail generation.

### Getting Video URLs

<Tabs>
<Tab title="TypeScript">
```typescript
import { FileRepository } from '@amityco/js-sdk';

// Get video with all resolutions
const getVideo = async (videoId: string) => {
  try {
    const { data: video } = await FileRepository.getVideo(videoId);
    return video;
  } catch (error) {
    console.error('Failed to retrieve video:', error);
    throw error;
  }
};

// Get specific resolution
const getVideoUrl = (video: any, resolution: '360p' | '480p' | '720p' | '1080p' | 'original' = '720p') => {
  return video.videoUrl?.[resolution] || video.fileUrl;
};

// Adaptive resolution selection
const selectOptimalResolution = (video: any, bandwidth: number, screenWidth: number) => {
  const resolutions = Object.keys(video.videoUrl || {});
  
  // Select based on bandwidth and screen size
  if (bandwidth < 1000000 || screenWidth <= 640) { // < 1Mbps or small screen
    return video.videoUrl?.['360p'] || video.fileUrl;
  } else if (bandwidth < 3000000 || screenWidth <= 1280) { // < 3Mbps or medium screen
    return video.videoUrl?.['480p'] || video.videoUrl?.['360p'] || video.fileUrl;
  } else if (screenWidth <= 1920) { // HD screen
    return video.videoUrl?.['720p'] || video.videoUrl?.['480p'] || video.fileUrl;
  } else { // 4K screen
    return video.videoUrl?.['1080p'] || video.videoUrl?.['720p'] || video.fileUrl;
  }
};

// Video player component with adaptive streaming
class AdaptiveVideoPlayer {
  private video: HTMLVideoElement;
  private currentResolution: string = '720p';
  
  constructor(videoElement: HTMLVideoElement) {
    this.video = videoElement;
    this.setupQualityMonitoring();
  }
  
  async loadVideo(videoId: string) {
    const videoData = await getVideo(videoId);
    const optimalUrl = this.getOptimalQuality(videoData);
    
    this.video.src = optimalUrl;
    this.setupResolutionSwitching(videoData);
  }
  
  private getOptimalQuality(videoData: any): string {
    const bandwidth = this.estimateBandwidth();
    const screenWidth = window.screen.width;
    return selectOptimalResolution(videoData, bandwidth, screenWidth);
  }
  
  private setupResolutionSwitching(videoData: any) {
    this.video.addEventListener('waiting', () => {
      // Switch to lower quality if buffering
      this.switchToLowerQuality(videoData);
    });
    
    this.video.addEventListener('canplaythrough', () => {
      // Can try higher quality if playback is smooth
      this.tryHigherQuality(videoData);
    });
  }
  
  private switchToLowerQuality(videoData: any) {
    const qualities = ['1080p', '720p', '480p', '360p'];
    const currentIndex = qualities.indexOf(this.currentResolution);
    
    if (currentIndex < qualities.length - 1) {
      const lowerQuality = qualities[currentIndex + 1];
      if (videoData.videoUrl?.[lowerQuality]) {
        this.switchQuality(videoData.videoUrl[lowerQuality], lowerQuality);
      }
    }
  }
  
  private tryHigherQuality(videoData: any) {
    const qualities = ['360p', '480p', '720p', '1080p'];
    const currentIndex = qualities.indexOf(this.currentResolution);
    
    if (currentIndex > 0) {
      const higherQuality = qualities[currentIndex - 1];
      if (videoData.videoUrl?.[higherQuality]) {
        this.switchQuality(videoData.videoUrl[higherQuality], higherQuality);
      }
    }
  }
  
  private switchQuality(newUrl: string, newResolution: string) {
    const currentTime = this.video.currentTime;
    const wasPlaying = !this.video.paused;
    
    this.video.src = newUrl;
    this.video.currentTime = currentTime;
    this.currentResolution = newResolution;
    
    if (wasPlaying) {
      this.video.play();
    }
    
    console.log(`Switched to ${newResolution} quality`);
  }
  
  private estimateBandwidth(): number {
    // Simple bandwidth estimation
    // In production, use more sophisticated methods
    return (navigator as any).connection?.downlink * 1000000 || 5000000; // Default to 5Mbps
  }
  
  private setupQualityMonitoring() {
    setInterval(() => {
      const bufferedEnd = this.video.buffered.length > 0 ? 
        this.video.buffered.end(this.video.buffered.length - 1) : 0;
      const bufferHealth = bufferedEnd - this.video.currentTime;
      
      console.log(`Buffer health: ${bufferHealth.toFixed(2)}s`);
    }, 5000);
  }
}
```
</Tab>

<Tab title="iOS">
```swift
import AmitySDK
import AVFoundation

class VideoStreamingManager {
    private let fileRepository = AmityFileRepository()
    
    enum VideoQuality: String, CaseIterable {
        case quality360p = "360p"
        case quality480p = "480p"
        case quality720p = "720p"
        case quality1080p = "1080p"
        case original = "original"
        
        var displayName: String {
            switch self {
            case .quality360p: return "360p"
            case .quality480p: return "480p"
            case .quality720p: return "720p (HD)"
            case .quality1080p: return "1080p (Full HD)"
            case .original: return "Original"
            }
        }
    }
    
    func getVideo(videoId: String, completion: @escaping (AmityFile?, Error?) -> Void) {
        fileRepository.getVideo(withVideoId: videoId) { video, error in
            DispatchQueue.main.async {
                completion(video, error)
            }
        }
    }
    
    func getVideoUrl(for video: AmityFile, quality: VideoQuality) -> String? {
        guard let videoUrls = video.metadata?["videoUrl"] as? [String: String] else {
            return video.fileUrl
        }
        
        return videoUrls[quality.rawValue] ?? video.fileUrl
    }
    
    func selectOptimalQuality(
        for video: AmityFile,
        screenSize: CGSize,
        networkType: NetworkType = .wifi
    ) -> VideoQuality {
        guard let videoUrls = video.metadata?["videoUrl"] as? [String: String] else {
            return .quality720p
        }
        
        let availableQualities = VideoQuality.allCases.filter { quality in
            videoUrls[quality.rawValue] != nil
        }
        
        switch networkType {
        case .cellular:
            // Prefer lower quality on cellular
            return availableQualities.first { [.quality360p, .quality480p].contains($0) } ?? .quality360p
        case .wifi:
            // Select based on screen size
            if screenSize.width <= 640 {
                return availableQualities.first { [.quality360p, .quality480p].contains($0) } ?? .quality480p
            } else if screenSize.width <= 1280 {
                return availableQualities.first { [.quality480p, .quality720p].contains($0) } ?? .quality720p
            } else {
                return availableQualities.first { [.quality720p, .quality1080p].contains($0) } ?? .quality720p
            }
        }
    }
    
    func setupAdaptivePlayer(
        for video: AmityFile,
        playerItem: AVPlayerItem
    ) -> AdaptiveVideoPlayer {
        return AdaptiveVideoPlayer(video: video, playerItem: playerItem)
    }
}

class AdaptiveVideoPlayer {
    private let video: AmityFile
    private let playerItem: AVPlayerItem
    private var currentQuality: VideoStreamingManager.VideoQuality = .quality720p
    
    init(video: AmityFile, playerItem: AVPlayerItem) {
        self.video = video
        self.playerItem = playerItem
        setupBufferMonitoring()
    }
    
    func switchQuality(to quality: VideoStreamingManager.VideoQuality) {
        guard let newUrl = VideoStreamingManager().getVideoUrl(for: video, quality: quality),
              let url = URL(string: newUrl) else { return }
        
        let currentTime = playerItem.currentTime()
        let newPlayerItem = AVPlayerItem(url: url)
        
        // Switch to new quality
        playerItem.replaceCurrentItem(with: newPlayerItem)
        newPlayerItem.seek(to: currentTime)
        
        currentQuality = quality
        print("Switched to \(quality.displayName)")
    }
    
    private func setupBufferMonitoring() {
        playerItem.addObserver(self, forKeyPath: "playbackBufferEmpty", options: .new, context: nil)
        playerItem.addObserver(self, forKeyPath: "playbackLikelyToKeepUp", options: .new, context: nil)
    }
    
    override func observeValue(
        forKeyPath keyPath: String?,
        of object: Any?,
        change: [NSKeyValueChangeKey : Any]?,
        context: UnsafeMutableRawPointer?
    ) {
        if keyPath == "playbackBufferEmpty" {
            // Buffer is empty, consider switching to lower quality
            switchToLowerQualityIfNeeded()
        } else if keyPath == "playbackLikelyToKeepUp" {
            // Playback is smooth, can try higher quality
            tryHigherQualityIfAppropriate()
        }
    }
    
    private func switchToLowerQualityIfNeeded() {
        let lowerQualities: [VideoStreamingManager.VideoQuality] = [.quality1080p, .quality720p, .quality480p, .quality360p]
        
        if let currentIndex = lowerQualities.firstIndex(of: currentQuality),
           currentIndex < lowerQualities.count - 1 {
            let lowerQuality = lowerQualities[currentIndex + 1]
            switchQuality(to: lowerQuality)
        }
    }
    
    private func tryHigherQualityIfAppropriate() {
        let higherQualities: [VideoStreamingManager.VideoQuality] = [.quality360p, .quality480p, .quality720p, .quality1080p]
        
        if let currentIndex = higherQualities.firstIndex(of: currentQuality),
           currentIndex > 0 {
            let higherQuality = higherQualities[currentIndex - 1]
            
            // Only switch if network conditions are good
            if isNetworkConditionGood() {
                switchQuality(to: higherQuality)
            }
        }
    }
    
    private func isNetworkConditionGood() -> Bool {
        // Simple network condition check
        // In production, implement more sophisticated logic
        return true
    }
}

enum NetworkType {
    case wifi
    case cellular
}
```
</Tab>

<Tab title="Android">
```kotlin
import com.amity.socialcloud.sdk.core.file.AmityFileRepository
import android.content.Context
import android.net.ConnectivityManager
import android.net.NetworkCapabilities
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.common.MediaItem

class VideoStreamingManager(private val client: AmityClient, private val context: Context) {
    private val fileRepository = AmityFileRepository(client)
    
    enum class VideoQuality(val value: String, val displayName: String) {
        QUALITY_360P("360p", "360p"),
        QUALITY_480P("480p", "480p"), 
        QUALITY_720P("720p", "720p (HD)"),
        QUALITY_1080P("1080p", "1080p (Full HD)"),
        ORIGINAL("original", "Original")
    }
    
    fun getVideo(
        videoId: String,
        callback: (AmityFile?, Throwable?) -> Unit
    ) {
        fileRepository.getVideo(videoId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ video ->
                callback(video, null)
            }, { error ->
                callback(null, error)
            })
    }
    
    fun getVideoUrl(video: AmityFile, quality: VideoQuality): String {
        val videoUrls = video.getMetadata()["videoUrl"] as? Map<String, String>
        return videoUrls?.get(quality.value) ?: video.getFileUrl()
    }
    
    fun selectOptimalQuality(
        video: AmityFile,
        screenWidth: Int,
        networkType: NetworkType = getNetworkType()
    ): VideoQuality {
        val videoUrls = video.getMetadata()["videoUrl"] as? Map<String, String> ?: return VideoQuality.QUALITY_720P
        
        val availableQualities = VideoQuality.values().filter { quality ->
            videoUrls.containsKey(quality.value)
        }
        
        return when (networkType) {
            NetworkType.CELLULAR -> {
                // Prefer lower quality on cellular
                availableQualities.firstOrNull { 
                    it in listOf(VideoQuality.QUALITY_360P, VideoQuality.QUALITY_480P) 
                } ?: VideoQuality.QUALITY_360P
            }
            NetworkType.WIFI -> {
                when {
                    screenWidth <= 640 -> availableQualities.firstOrNull { 
                        it in listOf(VideoQuality.QUALITY_360P, VideoQuality.QUALITY_480P) 
                    } ?: VideoQuality.QUALITY_480P
                    screenWidth <= 1280 -> availableQualities.firstOrNull { 
                        it in listOf(VideoQuality.QUALITY_480P, VideoQuality.QUALITY_720P) 
                    } ?: VideoQuality.QUALITY_720P
                    else -> availableQualities.firstOrNull { 
                        it in listOf(VideoQuality.QUALITY_720P, VideoQuality.QUALITY_1080P) 
                    } ?: VideoQuality.QUALITY_720P
                }
            }
        }
    }
    
    private fun getNetworkType(): NetworkType {
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val network = connectivityManager.activeNetwork
        val networkCapabilities = connectivityManager.getNetworkCapabilities(network)
        
        return when {
            networkCapabilities?.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) == true -> NetworkType.WIFI
            networkCapabilities?.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) == true -> NetworkType.CELLULAR
            else -> NetworkType.WIFI // Default to wifi
        }
    }
    
    fun createAdaptivePlayer(video: AmityFile): AdaptiveVideoPlayer {
        return AdaptiveVideoPlayer(video, this, context)
    }
    
    enum class NetworkType {
        WIFI, CELLULAR
    }
}

class AdaptiveVideoPlayer(
    private val video: AmityFile,
    private val streamingManager: VideoStreamingManager,
    private val context: Context
) {
    private var exoPlayer: ExoPlayer? = null
    private var currentQuality = VideoStreamingManager.VideoQuality.QUALITY_720P
    
    fun initialize(): ExoPlayer {
        exoPlayer = ExoPlayer.Builder(context).build()
        
        val optimalQuality = streamingManager.selectOptimalQuality(
            video,
            context.resources.displayMetrics.widthPixels
        )
        
        switchQuality(optimalQuality)
        setupAdaptiveStreaming()
        
        return exoPlayer!!
    }
    
    fun switchQuality(quality: VideoStreamingManager.VideoQuality) {
        val videoUrl = streamingManager.getVideoUrl(video, quality)
        val mediaItem = MediaItem.fromUri(videoUrl)
        
        val currentPosition = exoPlayer?.currentPosition ?: 0L
        val wasPlaying = exoPlayer?.isPlaying ?: false
        
        exoPlayer?.setMediaItem(mediaItem)
        exoPlayer?.seekTo(currentPosition)
        
        if (wasPlaying) {
            exoPlayer?.play()
        }
        
        currentQuality = quality
        println("Switched to ${quality.displayName}")
    }
    
    private fun setupAdaptiveStreaming() {
        // Monitor buffer health and network conditions
        exoPlayer?.addListener(object : Player.Listener {
            override fun onPlaybackStateChanged(playbackState: Int) {
                when (playbackState) {
                    Player.STATE_BUFFERING -> {
                        // Buffering, consider lower quality
                        considerLowerQuality()
                    }
                    Player.STATE_READY -> {
                        // Ready to play, can try higher quality if conditions are good
                        considerHigherQuality()
                    }
                }
            }
        })
    }
    
    private fun considerLowerQuality() {
        val lowerQualities = listOf(
            VideoStreamingManager.VideoQuality.QUALITY_1080P,
            VideoStreamingManager.VideoQuality.QUALITY_720P,
            VideoStreamingManager.VideoQuality.QUALITY_480P,
            VideoStreamingManager.VideoQuality.QUALITY_360P
        )
        
        val currentIndex = lowerQualities.indexOf(currentQuality)
        if (currentIndex >= 0 && currentIndex < lowerQualities.size - 1) {
            val lowerQuality = lowerQualities[currentIndex + 1]
            switchQuality(lowerQuality)
        }
    }
    
    private fun considerHigherQuality() {
        val higherQualities = listOf(
            VideoStreamingManager.VideoQuality.QUALITY_360P,
            VideoStreamingManager.VideoQuality.QUALITY_480P,
            VideoStreamingManager.VideoQuality.QUALITY_720P,
            VideoStreamingManager.VideoQuality.QUALITY_1080P
        )
        
        val currentIndex = higherQualities.indexOf(currentQuality)
        if (currentIndex > 0 && isNetworkConditionGood()) {
            val higherQuality = higherQualities[currentIndex - 1]
            switchQuality(higherQuality)
        }
    }
    
    private fun isNetworkConditionGood(): Boolean {
        // Implement network condition assessment
        return streamingManager.getNetworkType() == VideoStreamingManager.NetworkType.WIFI
    }
}
```
</Tab>

<Tab title="Flutter">
```dart
import 'package:amity_sdk/amity_sdk.dart';
import 'package:video_player/video_player.dart';
import 'dart:io';

enum VideoQuality {
  quality360p('360p', '360p'),
  quality480p('480p', '480p'),
  quality720p('720p', '720p (HD)'),
  quality1080p('1080p', '1080p (Full HD)'),
  original('original', 'Original');
  
  const VideoQuality(this.value, this.displayName);
  final String value;
  final String displayName;
}

class VideoStreamingManager {
  final AmityFileRepository _fileRepository = AmitySocialClient.newFileRepository();
  
  Future<AmityVideo?> getVideo(String videoId) async {
    try {
      return await _fileRepository.getVideo(videoId);
    } catch (error) {
      print('Failed to get video: $error');
      return null;
    }
  }
  
  String getVideoUrl(AmityVideo video, VideoQuality quality) {
    final videoUrls = video.metadata?['videoUrl'] as Map<String, String>?;
    return videoUrls?[quality.value] ?? video.fileUrl;
  }
  
  VideoQuality selectOptimalQuality(
    AmityVideo video,
    double screenWidth, {
    bool isWifi = true,
  }) {
    final videoUrls = video.metadata?['videoUrl'] as Map<String, String>?;
    if (videoUrls == null) return VideoQuality.quality720p;
    
    final availableQualities = VideoQuality.values.where((quality) {
      return videoUrls.containsKey(quality.value);
    }).toList();
    
    if (!isWifi) {
      // Prefer lower quality on cellular
      return availableQualities.firstWhere(
        (q) => [VideoQuality.quality360p, VideoQuality.quality480p].contains(q),
        orElse: () => VideoQuality.quality360p,
      );
    }
    
    // Select based on screen size for WiFi
    if (screenWidth <= 640) {
      return availableQualities.firstWhere(
        (q) => [VideoQuality.quality360p, VideoQuality.quality480p].contains(q),
        orElse: () => VideoQuality.quality480p,
      );
    } else if (screenWidth <= 1280) {
      return availableQualities.firstWhere(
        (q) => [VideoQuality.quality480p, VideoQuality.quality720p].contains(q),
        orElse: () => VideoQuality.quality720p,
      );
    } else {
      return availableQualities.firstWhere(
        (q) => [VideoQuality.quality720p, VideoQuality.quality1080p].contains(q),
        orElse: () => VideoQuality.quality720p,
      );
    }
  }
  
  AdaptiveVideoPlayer createAdaptivePlayer(AmityVideo video) {
    return AdaptiveVideoPlayer(video, this);
  }
}

class AdaptiveVideoPlayer {
  final AmityVideo video;
  final VideoStreamingManager streamingManager;
  VideoPlayerController? _controller;
  VideoQuality _currentQuality = VideoQuality.quality720p;
  
  AdaptiveVideoPlayer(this.video, this.streamingManager);
  
  Future<VideoPlayerController> initialize(BuildContext context) async {
    final screenWidth = MediaQuery.of(context).size.width;
    final isWifi = await _isWifiConnected();
    
    _currentQuality = streamingManager.selectOptimalQuality(
      video,
      screenWidth,
      isWifi: isWifi,
    );
    
    await _initializeController(_currentQuality);
    _setupAdaptiveStreaming();
    
    return _controller!;
  }
  
  Future<void> _initializeController(VideoQuality quality) async {
    final videoUrl = streamingManager.getVideoUrl(video, quality);
    
    _controller?.dispose();
    _controller = VideoPlayerController.network(videoUrl);
    
    await _controller!.initialize();
    print('Initialized with ${quality.displayName}');
  }
  
  Future<void> switchQuality(VideoQuality quality) async {
    if (_controller == null) return;
    
    final currentPosition = _controller!.value.position;
    final wasPlaying = _controller!.value.isPlaying;
    
    await _initializeController(quality);
    await _controller!.seekTo(currentPosition);
    
    if (wasPlaying) {
      await _controller!.play();
    }
    
    _currentQuality = quality;
    print('Switched to ${quality.displayName}');
  }
  
  void _setupAdaptiveStreaming() {
    _controller?.addListener(() {
      if (_controller!.value.hasError) {
        print('Video error: ${_controller!.value.errorDescription}');
        _considerLowerQuality();
      }
      
      // Monitor buffer health
      final buffered = _controller!.value.buffered;
      if (buffered.isNotEmpty) {
        final bufferEnd = buffered.last.end;
        final currentPos = _controller!.value.position;
        final bufferHealth = bufferEnd - currentPos;
        
        if (bufferHealth < const Duration(seconds: 5)) {
          _considerLowerQuality();
        } else if (bufferHealth > const Duration(seconds: 15)) {
          _considerHigherQuality();
        }
      }
    });
  }
  
  void _considerLowerQuality() {
    const lowerQualities = [
      VideoQuality.quality1080p,
      VideoQuality.quality720p,
      VideoQuality.quality480p,
      VideoQuality.quality360p,
    ];
    
    final currentIndex = lowerQualities.indexOf(_currentQuality);
    if (currentIndex >= 0 && currentIndex < lowerQualities.length - 1) {
      final lowerQuality = lowerQualities[currentIndex + 1];
      switchQuality(lowerQuality);
    }
  }
  
  void _considerHigherQuality() {
    const higherQualities = [
      VideoQuality.quality360p,
      VideoQuality.quality480p,
      VideoQuality.quality720p,
      VideoQuality.quality1080p,
    ];
    
    final currentIndex = higherQualities.indexOf(_currentQuality);
    if (currentIndex > 0) {
      final higherQuality = higherQualities[currentIndex - 1];
      switchQuality(higherQuality);
    }
  }
  
  Future<bool> _isWifiConnected() async {
    // Simple connectivity check
    // In production, use connectivity_plus package
    return true; // Placeholder
  }
  
  void dispose() {
    _controller?.dispose();
  }
}

// Video player widget with quality selector
class AdaptiveVideoPlayerWidget extends StatefulWidget {
  final String videoId;
  
  const AdaptiveVideoPlayerWidget({Key? key, required this.videoId}) : super(key: key);
  
  @override
  _AdaptiveVideoPlayerWidgetState createState() => _AdaptiveVideoPlayerWidgetState();
}

class _AdaptiveVideoPlayerWidgetState extends State<AdaptiveVideoPlayerWidget> {
  VideoStreamingManager? _streamingManager;
  AdaptiveVideoPlayer? _adaptivePlayer;
  VideoPlayerController? _controller;
  bool _isLoading = true;
  
  @override
  void initState() {
    super.initState();
    _initializePlayer();
  }
  
  Future<void> _initializePlayer() async {
    _streamingManager = VideoStreamingManager();
    
    final video = await _streamingManager!.getVideo(widget.videoId);
    if (video != null) {
      _adaptivePlayer = _streamingManager!.createAdaptivePlayer(video);
      _controller = await _adaptivePlayer!.initialize(context);
      
      setState(() {
        _isLoading = false;
      });
    }
  }
  
  @override
  Widget build(BuildContext context) {
    if (_isLoading || _controller == null) {
      return const Center(child: CircularProgressIndicator());
    }
    
    return Column(
      children: [
        AspectRatio(
          aspectRatio: _controller!.value.aspectRatio,
          child: VideoPlayer(_controller!),
        ),
        VideoProgressIndicator(_controller!, allowScrubbing: true),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            IconButton(
              onPressed: () {
                _controller!.value.isPlaying
                    ? _controller!.pause()
                    : _controller!.play();
              },
              icon: Icon(
                _controller!.value.isPlaying ? Icons.pause : Icons.play_arrow,
              ),
            ),
            PopupMenuButton<VideoQuality>(
              child: const Icon(Icons.settings),
              onSelected: (quality) {
                _adaptivePlayer?.switchQuality(quality);
              },
              itemBuilder: (context) => VideoQuality.values.map((quality) {
                return PopupMenuItem(
                  value: quality,
                  child: Text(quality.displayName),
                );
              }).toList(),
            ),
          ],
        ),
      ],
    );
  }
  
  @override
  void dispose() {
    _adaptivePlayer?.dispose();
    super.dispose();
  }
}
```
</Tab>
</Tabs>

## Video Thumbnails

Social+ automatically generates video thumbnails for preview purposes. Thumbnails are created during the transcoding process and provide visual previews for video content.

### Accessing Video Thumbnails

<Tabs>
<Tab title="TypeScript">
```typescript
import { FileRepository } from '@amityco/js-sdk';

// Get video thumbnail
const getVideoThumbnail = async (videoId: string) => {
  try {
    const { data: video } = await FileRepository.getVideo(videoId);
    
    if (video.thumbnailFileId) {
      const { data: thumbnail } = await FileRepository.getImage(video.thumbnailFileId);
      return thumbnail;
    }
    
    return null;
  } catch (error) {
    console.error('Failed to get video thumbnail:', error);
    return null;
  }
};

// Get thumbnail with specific size
const getVideoThumbnailUrl = async (
  videoId: string, 
  size: 'small' | 'medium' | 'large' = 'medium'
) => {
  const thumbnail = await getVideoThumbnail(videoId);
  if (thumbnail?.sizes?.[size]) {
    return thumbnail.sizes[size];
  }
  return thumbnail?.fileUrl || null;
};

// Video thumbnail component
class VideoThumbnailLoader {
  static async loadThumbnail(
    videoId: string,
    imgElement: HTMLImageElement,
    size: 'small' | 'medium' | 'large' = 'medium'
  ) {
    try {
      const thumbnailUrl = await getVideoThumbnailUrl(videoId, size);
      
      if (thumbnailUrl) {
        imgElement.src = thumbnailUrl;
        imgElement.alt = 'Video thumbnail';
        imgElement.classList.add('video-thumbnail');
        
        // Add play button overlay
        this.addPlayButton(imgElement);
      } else {
        // Show default video placeholder
        imgElement.src = '/images/video-placeholder.svg';
        imgElement.alt = 'Video (thumbnail not available)';
      }
    } catch (error) {
      console.error('Failed to load video thumbnail:', error);
      imgElement.src = '/images/video-error.svg';
    }
  }
  
  private static addPlayButton(imgElement: HTMLImageElement) {
    const container = document.createElement('div');
    container.className = 'video-thumbnail-container';
    container.style.position = 'relative';
    container.style.display = 'inline-block';
    
    const playButton = document.createElement('div');
    playButton.className = 'video-play-button';
    playButton.innerHTML = '▶';
    playButton.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      cursor: pointer;
      transition: background 0.3s;
    `;
    
    playButton.addEventListener('mouseenter', () => {
      playButton.style.background = 'rgba(0, 0, 0, 0.9)';
    });
    
    playButton.addEventListener('mouseleave', () => {
      playButton.style.background = 'rgba(0, 0, 0, 0.7)';
    });
    
    imgElement.parentNode?.insertBefore(container, imgElement);
    container.appendChild(imgElement);
    container.appendChild(playButton);
  }
}

// Generate custom thumbnail at specific time
const generateCustomThumbnail = async (videoFile: File, timeInSeconds: number = 5) => {
  return new Promise<File>((resolve, reject) => {
    const video = document.createElement('video');
    video.preload = 'metadata';
    
    video.onloadedmetadata = () => {
      video.currentTime = Math.min(timeInSeconds, video.duration);
    };
    
    video.onseeked = () => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d')!;
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      canvas.toBlob((blob) => {
        if (blob) {
          const thumbnailFile = new File([blob], 'thumbnail.jpg', {
            type: 'image/jpeg',
            lastModified: Date.now()
          });
          resolve(thumbnailFile);
        } else {
          reject(new Error('Failed to generate thumbnail'));
        }
      }, 'image/jpeg', 0.8);
    };
    
    video.onerror = () => reject(new Error('Failed to load video'));
    video.src = URL.createObjectURL(videoFile);
  });
};
```
</Tab>

<Tab title="iOS">
```swift
import AmitySDK
import AVFoundation
import UIKit

class VideoThumbnailManager {
    private let fileRepository = AmityFileRepository()
    
    func getVideoThumbnail(
        videoId: String,
        size: ImageSize = .medium,
        completion: @escaping (UIImage?, Error?) -> Void
    ) {
        fileRepository.getVideo(withVideoId: videoId) { [weak self] video, error in
            guard let self = self, let video = video, error == nil else {
                completion(nil, error)
                return
            }
            
            guard let thumbnailFileId = video.metadata?["thumbnailFileId"] as? String else {
                completion(nil, NSError(domain: "NoThumbnail", code: 0, userInfo: [
                    NSLocalizedDescriptionKey: "Thumbnail not available"
                ]))
                return
            }
            
            self.downloadThumbnail(thumbnailFileId: thumbnailFileId, size: size, completion: completion)
        }
    }
    
    private func downloadThumbnail(
        thumbnailFileId: String,
        size: ImageSize,
        completion: @escaping (UIImage?, Error?) -> Void
    ) {
        fileRepository.getImage(withImageId: thumbnailFileId) { imageFile, error in
            guard let imageFile = imageFile, error == nil else {
                completion(nil, error)
                return
            }
            
            let thumbnailUrl = self.getThumbnailUrl(for: imageFile, size: size)
            self.downloadImage(from: thumbnailUrl, completion: completion)
        }
    }
    
    private func getThumbnailUrl(for imageFile: AmityFile, size: ImageSize) -> String {
        guard let sizes = imageFile.metadata?["sizes"] as? [String: String] else {
            return imageFile.fileUrl
        }
        
        return sizes[size.rawValue] ?? imageFile.fileUrl
    }
    
    private func downloadImage(from url: String, completion: @escaping (UIImage?, Error?) -> Void) {
        guard let imageUrl = URL(string: url) else {
            completion(nil, NSError(domain: "InvalidURL", code: 0, userInfo: nil))
            return
        }
        
        URLSession.shared.dataTask(with: imageUrl) { data, response, error in
            DispatchQueue.main.async {
                if let error = error {
                    completion(nil, error)
                    return
                }
                
                guard let data = data, let image = UIImage(data: data) else {
                    completion(nil, NSError(domain: "ImageDecoding", code: 0, userInfo: nil))
                    return
                }
                
                completion(image, nil)
            }
        }.resume()
    }
    
    // Generate custom thumbnail from video URL
    func generateThumbnail(
        from videoUrl: URL,
        at time: CMTime = CMTime(seconds: 5, preferredTimescale: 1),
        completion: @escaping (UIImage?, Error?) -> Void
    ) {
        let asset = AVURLAsset(url: videoUrl)
        let imageGenerator = AVAssetImageGenerator(asset: asset)
        imageGenerator.appliesPreferredTrackTransform = true
        imageGenerator.maximumSize = CGSize(width: 600, height: 600)
        
        imageGenerator.generateCGImagesAsynchronously(forTimes: [NSValue(time: time)]) { _, cgImage, _, result, error in
            DispatchQueue.main.async {
                if let error = error {
                    completion(nil, error)
                    return
                }
                
                guard let cgImage = cgImage else {
                    completion(nil, NSError(domain: "ThumbnailGeneration", code: 0, userInfo: nil))
                    return
                }
                
                let image = UIImage(cgImage: cgImage)
                completion(image, nil)
            }
        }
    }
}

// Custom video thumbnail view
class VideoThumbnailView: UIView {
    private let imageView = UIImageView()
    private let playButton = UIButton()
    private let loadingIndicator = UIActivityIndicatorView(style: .medium)
    
    var onPlayButtonTapped: (() -> Void)?
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupViews()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        setupViews()
    }
    
    private func setupViews() {
        // Image view setup
        imageView.contentMode = .scaleAspectFill
        imageView.clipsToBounds = true
        addSubview(imageView)
        
        // Play button setup
        playButton.setImage(UIImage(systemName: "play.circle.fill"), for: .normal)
        playButton.tintColor = .white
        playButton.backgroundColor = UIColor.black.withAlphaComponent(0.7)
        playButton.layer.cornerRadius = 30
        playButton.addTarget(self, action: #selector(playButtonTapped), for: .touchUpInside)
        addSubview(playButton)
        
        // Loading indicator
        loadingIndicator.color = .white
        addSubview(loadingIndicator)
        
        setupConstraints()
    }
    
    private func setupConstraints() {
        imageView.translatesAutoresizingMaskIntoConstraints = false
        playButton.translatesAutoresizingMaskIntoConstraints = false
        loadingIndicator.translatesAutoresizingMaskIntoConstraints = false
        
        NSLayoutConstraint.activate([
            imageView.topAnchor.constraint(equalTo: topAnchor),
            imageView.leadingAnchor.constraint(equalTo: leadingAnchor),
            imageView.trailingAnchor.constraint(equalTo: trailingAnchor),
            imageView.bottomAnchor.constraint(equalTo: bottomAnchor),
            
            playButton.centerXAnchor.constraint(equalTo: centerXAnchor),
            playButton.centerYAnchor.constraint(equalTo: centerYAnchor),
            playButton.widthAnchor.constraint(equalToConstant: 60),
            playButton.heightAnchor.constraint(equalToConstant: 60),
            
            loadingIndicator.centerXAnchor.constraint(equalTo: centerXAnchor),
            loadingIndicator.centerYAnchor.constraint(equalTo: centerYAnchor)
        ])
    }
    
    func loadThumbnail(videoId: String) {
        loadingIndicator.startAnimating()
        playButton.isHidden = true
        
        let thumbnailManager = VideoThumbnailManager()
        thumbnailManager.getVideoThumbnail(videoId: videoId) { [weak self] image, error in
            self?.loadingIndicator.stopAnimating()
            
            if let image = image {
                self?.imageView.image = image
                self?.playButton.isHidden = false
            } else {
                // Show placeholder
                self?.imageView.image = UIImage(named: "video_placeholder")
                self?.playButton.isHidden = false
            }
        }
    }
    
    @objc private func playButtonTapped() {
        onPlayButtonTapped?()
    }
}
```
</Tab>

<Tab title="Android">
```kotlin
import com.amity.socialcloud.sdk.core.file.AmityFileRepository
import android.widget.ImageView
import android.graphics.Bitmap
import android.media.MediaMetadataRetriever
import com.bumptech.glide.Glide
import com.bumptech.glide.load.resource.bitmap.RoundedCorners

class VideoThumbnailManager(private val client: AmityClient) {
    private val fileRepository = AmityFileRepository(client)
    
    fun loadVideoThumbnail(
        videoId: String,
        imageView: ImageView,
        size: ImageSize = ImageSize.MEDIUM,
        showPlayButton: Boolean = true
    ) {
        fileRepository.getVideo(videoId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ video ->
                val thumbnailFileId = video.getMetadata()["thumbnailFileId"] as? String
                
                if (thumbnailFileId != null) {
                    loadThumbnailImage(thumbnailFileId, imageView, size, showPlayButton)
                } else {
                    // Show placeholder
                    showVideoPlaceholder(imageView, showPlayButton)
                }
            }, { error ->
                println("Failed to get video: ${error.message}")
                showVideoPlaceholder(imageView, showPlayButton)
            })
    }
    
    private fun loadThumbnailImage(
        thumbnailFileId: String,
        imageView: ImageView,
        size: ImageSize,
        showPlayButton: Boolean
    ) {
        fileRepository.getImage(thumbnailFileId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ thumbnailFile ->
                val thumbnailUrl = getThumbnailUrl(thumbnailFile, size)
                
                Glide.with(imageView.context)
                    .load(thumbnailUrl)
                    .centerCrop()
                    .placeholder(R.drawable.video_placeholder)
                    .into(imageView)
                
                if (showPlayButton) {
                    addPlayButtonOverlay(imageView)
                }
            }, { error ->
                println("Failed to get thumbnail: ${error.message}")
                showVideoPlaceholder(imageView, showPlayButton)
            })
    }
    
    private fun getThumbnailUrl(thumbnailFile: AmityFile, size: ImageSize): String {
        val sizes = thumbnailFile.getMetadata()["sizes"] as? Map<String, String>
        return sizes?.get(size.value) ?: thumbnailFile.getFileUrl()
    }
    
    private fun showVideoPlaceholder(imageView: ImageView, showPlayButton: Boolean) {
        imageView.setImageResource(R.drawable.video_placeholder)
        
        if (showPlayButton) {
            addPlayButtonOverlay(imageView)
        }
    }
    
    private fun addPlayButtonOverlay(imageView: ImageView) {
        // Create play button overlay
        val overlay = LayoutInflater.from(imageView.context)
            .inflate(R.layout.video_play_overlay, null)
        
        if (imageView.parent is ViewGroup) {
            val container = imageView.parent as ViewGroup
            val params = imageView.layoutParams
            
            val frameLayout = FrameLayout(imageView.context)
            frameLayout.layoutParams = params
            
            container.removeView(imageView)
            frameLayout.addView(imageView)
            frameLayout.addView(overlay)
            container.addView(frameLayout)
        }
    }
    
    // Generate thumbnail from video file
    fun generateThumbnail(
        videoFile: File,
        timeUs: Long = 5_000_000L // 5 seconds
    ): Bitmap? {
        return try {
            val retriever = MediaMetadataRetriever()
            retriever.setDataSource(videoFile.absolutePath)
            
            val bitmap = retriever.getFrameAtTime(timeUs, MediaMetadataRetriever.OPTION_CLOSEST_SYNC)
            retriever.release()
            
            bitmap
        } catch (e: Exception) {
            println("Failed to generate thumbnail: ${e.message}")
            null
        }
    }
    
    enum class ImageSize(val value: String) {
        SMALL("small"),
        MEDIUM("medium"),
        LARGE("large")
    }
}

// Custom video thumbnail view
class VideoThumbnailView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : FrameLayout(context, attrs, defStyleAttr) {
    
    private val imageView: ImageView
    private val playButton: ImageView
    private val loadingIndicator: ProgressBar
    private val thumbnailManager = VideoThumbnailManager(AmityClient.getInstance())
    
    var onPlayButtonClicked: (() -> Unit)? = null
    
    init {
        inflate(context, R.layout.view_video_thumbnail, this)
        
        imageView = findViewById(R.id.thumbnail_image)
        playButton = findViewById(R.id.play_button)
        loadingIndicator = findViewById(R.id.loading_indicator)
        
        playButton.setOnClickListener { onPlayButtonClicked?.invoke() }
    }
    
    fun loadThumbnail(videoId: String) {
        loadingIndicator.visibility = View.VISIBLE
        playButton.visibility = View.GONE
        
        thumbnailManager.loadVideoThumbnail(
            videoId = videoId,
            imageView = imageView,
            showPlayButton = false
        )
        
        // Show play button after loading
        imageView.viewTreeObserver.addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener {
            override fun onGlobalLayout() {
                imageView.viewTreeObserver.removeOnGlobalLayoutListener(this)
                loadingIndicator.visibility = View.GONE
                playButton.visibility = View.VISIBLE
            }
        })
    }
}
```
</Tab>

<Tab title="Flutter">
```dart
import 'package:amity_sdk/amity_sdk.dart';
import 'package:flutter/material.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:video_thumbnail/video_thumbnail.dart';
import 'dart:io';

class VideoThumbnailManager {
  final AmityFileRepository _fileRepository = AmitySocialClient.newFileRepository();
  
  Future<String?> getVideoThumbnailUrl(
    String videoId, {
    String size = 'medium',
  }) async {
    try {
      final video = await _fileRepository.getVideo(videoId);
      final thumbnailFileId = video.metadata?['thumbnailFileId'] as String?;
      
      if (thumbnailFileId != null) {
        final thumbnail = await _fileRepository.getImage(thumbnailFileId);
        final sizes = thumbnail.metadata?['sizes'] as Map<String, String>?;
        return sizes?[size] ?? thumbnail.fileUrl;
      }
      
      return null;
    } catch (error) {
      print('Failed to get video thumbnail: $error');
      return null;
    }
  }
  
  Future<File?> generateCustomThumbnail(
    String videoPath, {
    int timeMs = 5000,
    int quality = 75,
  }) async {
    try {
      final thumbnailPath = await VideoThumbnail.thumbnailFile(
        video: videoPath,
        timeMs: timeMs,
        quality: quality,
      );
      
      return thumbnailPath != null ? File(thumbnailPath) : null;
    } catch (error) {
      print('Failed to generate custom thumbnail: $error');
      return null;
    }
  }
}

// Video thumbnail widget
class VideoThumbnailWidget extends StatefulWidget {
  final String videoId;
  final double? width;
  final double? height;
  final VoidCallback? onTap;
  final bool showPlayButton;
  final String thumbnailSize;
  
  const VideoThumbnailWidget({
    Key? key,
    required this.videoId,
    this.width,
    this.height,
    this.onTap,
    this.showPlayButton = true,
    this.thumbnailSize = 'medium',
  }) : super(key: key);
  
  @override
  _VideoThumbnailWidgetState createState() => _VideoThumbnailWidgetState();
}

class _VideoThumbnailWidgetState extends State<VideoThumbnailWidget> {
  final VideoThumbnailManager _thumbnailManager = VideoThumbnailManager();
  String? _thumbnailUrl;
  bool _isLoading = true;
  
  @override
  void initState() {
    super.initState();
    _loadThumbnail();
  }
  
  Future<void> _loadThumbnail() async {
    final thumbnailUrl = await _thumbnailManager.getVideoThumbnailUrl(
      widget.videoId,
      size: widget.thumbnailSize,
    );
    
    if (mounted) {
      setState(() {
        _thumbnailUrl = thumbnailUrl;
        _isLoading = false;
      });
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: widget.onTap,
      child: Container(
        width: widget.width,
        height: widget.height,
        child: Stack(
          fit: StackFit.expand,
          children: [
            // Thumbnail image
            if (_isLoading)
              Container(
                color: Colors.grey[300],
                child: const Center(
                  child: CircularProgressIndicator(),
                ),
              )
            else if (_thumbnailUrl != null)
              CachedNetworkImage(
                imageUrl: _thumbnailUrl!,
                fit: BoxFit.cover,
                placeholder: (context, url) => Container(
                  color: Colors.grey[300],
                  child: const Center(child: CircularProgressIndicator()),
                ),
                errorWidget: (context, url, error) => _buildPlaceholder(),
              )
            else
              _buildPlaceholder(),
            
            // Play button overlay
            if (widget.showPlayButton && !_isLoading)
              Center(
                child: Container(
                  width: 60,
                  height: 60,
                  decoration: BoxDecoration(
                    color: Colors.black.withOpacity(0.7),
                    shape: BoxShape.circle,
                  ),
                  child: const Icon(
                    Icons.play_arrow,
                    color: Colors.white,
                    size: 30,
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildPlaceholder() {
    return Container(
      color: Colors.grey[300],
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.videocam_off,
            size: 40,
            color: Colors.grey[600],
          ),
          const SizedBox(height: 8),
          Text(
            'Video thumbnail\nnot available',
            textAlign: TextAlign.center,
            style: TextStyle(
              color: Colors.grey[600],
              fontSize: 12,
            ),
          ),
        ],
      ),
    );
  }
}

// Video thumbnail grid for multiple videos
class VideoThumbnailGrid extends StatelessWidget {
  final List<String> videoIds;
  final int crossAxisCount;
  final double aspectRatio;
  final Function(String videoId)? onVideoTap;
  
  const VideoThumbnailGrid({
    Key? key,
    required this.videoIds,
    this.crossAxisCount = 3,
    this.aspectRatio = 1.0,
    this.onVideoTap,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return GridView.builder(
      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: crossAxisCount,
        childAspectRatio: aspectRatio,
        crossAxisSpacing: 8,
        mainAxisSpacing: 8,
      ),
      itemCount: videoIds.length,
      itemBuilder: (context, index) {
        final videoId = videoIds[index];
        
        return VideoThumbnailWidget(
          videoId: videoId,
          onTap: () => onVideoTap?.call(videoId),
          thumbnailSize: 'small', // Use small thumbnails in grid
        );
      },
    );
  }
}

// Custom thumbnail generator widget
class ThumbnailGeneratorWidget extends StatefulWidget {
  final String videoPath;
  final Function(File thumbnailFile)? onThumbnailGenerated;
  
  const ThumbnailGeneratorWidget({
    Key? key,
    required this.videoPath,
    this.onThumbnailGenerated,
  }) : super(key: key);
  
  @override
  _ThumbnailGeneratorWidgetState createState() => _ThumbnailGeneratorWidgetState();
}

class _ThumbnailGeneratorWidgetState extends State<ThumbnailGeneratorWidget> {
  final VideoThumbnailManager _thumbnailManager = VideoThumbnailManager();
  File? _generatedThumbnail;
  bool _isGenerating = false;
  
  Future<void> _generateThumbnail(int timeMs) async {
    setState(() {
      _isGenerating = true;
    });
    
    final thumbnail = await _thumbnailManager.generateCustomThumbnail(
      widget.videoPath,
      timeMs: timeMs,
    );
    
    if (mounted) {
      setState(() {
        _generatedThumbnail = thumbnail;
        _isGenerating = false;
      });
      
      if (thumbnail != null) {
        widget.onThumbnailGenerated?.call(thumbnail);
      }
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        if (_generatedThumbnail != null)
          Container(
            height: 200,
            width: double.infinity,
            child: Image.file(
              _generatedThumbnail!,
              fit: BoxFit.cover,
            ),
          )
        else if (_isGenerating)
          Container(
            height: 200,
            width: double.infinity,
            color: Colors.grey[300],
            child: const Center(child: CircularProgressIndicator()),
          )
        else
          Container(
            height: 200,
            width: double.infinity,
            color: Colors.grey[300],
            child: const Center(
              child: Text('No thumbnail generated'),
            ),
          ),
        
        const SizedBox(height: 16),
        
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            ElevatedButton(
              onPressed: () => _generateThumbnail(1000), // 1 second
              child: const Text('1s'),
            ),
            ElevatedButton(
              onPressed: () => _generateThumbnail(5000), // 5 seconds
              child: const Text('5s'),
            ),
            ElevatedButton(
              onPressed: () => _generateThumbnail(10000), // 10 seconds
              child: const Text('10s'),
            ),
          ],
        ),
      ],
    );
  }
}
```
</Tab>
</Tabs>