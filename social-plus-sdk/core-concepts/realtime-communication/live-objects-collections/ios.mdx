---
title: "iOS Live Objects/Collections"  
description: "Live Objects are supported in the iOS SDK with AmityObject and AmityCollection"
---

## Overview

In iOS Social Plus SDK, we have a concept of **Live Object** and **Live Collection**. LiveObject is represented by `AmityObject` and LiveCollection is represented by `AmityCollection`. These generic classes encapsulate any other object and notify the observer whenever any property of the encapsulated object changes.

- **Live Object** helps to observe changes in a single object
- **Live Collection** helps to observe changes in a list of objects

Examples: `AmityObject<AmityPost>` or `AmityCollection<AmityMessage>`.

## How it Works

The SDK handles data from various sources that are constantly updating:

<CardGroup cols={3}>
  <Card title="Local Cache" icon="database">
    Data present in local storage
  </Card>
  <Card title="Server Queries" icon="server">
    Data queried from the server
  </Card>
  <Card title="Real-time Events" icon="bolt">
    Data received from real-time events
  </Card>
</CardGroup>

Data you're accessing can get updated by other sources and become out of sync. Live Object and Live Collection help sync this constantly updating data, so you always get the most recent version. When data updates, you're notified through helper methods.

**Key Benefits:**
- Automatic data synchronization
- No manual refresh needed
- Real-time updates
- Lifecycle management through tokens

Both `AmityObject` and `AmityCollection` provide methods for observing changes. The lifecycle of observation is tied to its token - when the token is invalidated or deallocated, observation ends.

## AmityNotificationToken

`AmityNotificationToken` is a simple object that tracks what is being observed. Each Live Object or Live Collection observation is tied to its respective token. When the token is invalidated or deallocated, observation ends.

```swift
class MyClass {
    var token: AmityNotificationToken?
    
    func doSomething() {
        // AmityNotification is alive in MyClass scope
    }
}
```

The token is used in combination with `AmityObject` or `AmityCollection`. Let's explore this in detail.

### Token Lifecycle Management

```swift
var token1: AmityNotificationToken?
var token2: AmityNotificationToken?

func example() {
    let liveObject: AmityObject<AmityChannel> = channelRepository.getChannel("1234")
    
    // observe block
    token1 = liveObject.observe { liveObject, error in
        // Handle changes
    }
    
    // observeOnce block
    token2 = liveObject.observeOnce { liveObject, error in
        // Handle single observation
    }
}
```

### Invalidating Tokens

The `AmityNotificationToken` provides an `invalidate()` method to stop observation:

```swift
// Manually invalidate the token
token1?.invalidate()

// Alternatively, deallocate the token
token1 = nil
```

## AmityObject - Single Object Observation

`AmityObject` is a generic class that tracks a single object. Any object encapsulated by `AmityObject` becomes a live object.

**Examples:**
- `AmityObject<AmityMessage>`
- `AmityObject<AmityChannel>`
- `AmityObject<AmityPost>`

### Available Methods

`AmityObject` exposes two key methods:

<CardGroup cols={2}>
  <Card title="observe" icon="eye">
    Can be triggered multiple times throughout the application lifetime
  </Card>
  <Card title="observeOnce" icon="eye-slash">
    Triggered only once, then automatically stops observing
  </Card>
</CardGroup>

<Warning>
Ensure the user is logged in before observing `AmityObject`. Refer to the [authentication guide](/social-plus-sdk/getting-started/authentication) for details.
</Warning>

### Observer Behavior

Both `observe` and `observeOnce` methods:
- Are called from the main thread (safe for UI updates)
- Trigger immediately with local data if available
- Make parallel server requests for fresh data
- Trigger again when server data returns
- Respond to future changes from any source

### Basic Object Observation

```swift
var token: AmityNotificationToken?

func observeChannel() {
    let liveObject: AmityObject<AmityChannel> = channelRepository.getChannel("1234")
    
    token = liveObject.observe { liveObject, error in
        guard error == nil else {
            print("Error observing channel: \(error!)")
            return
        }
        
        // Check data status
        let dataStatus: AmityDataStatus = liveObject.dataStatus
        print("Data status: \(dataStatus)")
        
        // Access the channel object
        guard let channel = liveObject.object else { return }
        
        // Use channel properties
        let channelId = channel.channelId
        let displayName = channel.displayName
        
        // Update UI on main thread (already guaranteed)
        updateChannelUI(with: channel)
    }
}
```

### Accessing Object Properties

`AmityObject` provides several properties for data access:

| Property | Type | Description |
|----------|------|-------------|
| `dataStatus` | `AmityDataStatus` | Whether data is fresh or local |
| `loadingStatus` | `AmityLoadingStatus` | Current loading state |
| `object` | `T?` | The actual encapsulated object |

### Observing Fresh Data Only

If you only want fresh data from the server:

```swift
var token: AmityNotificationToken?

func observeFreshChannelData() {
    let liveObject = channelRepository.getChannel("1234")
    
    token = liveObject.observe { [weak self] liveObject, error in
        // Only process fresh data
        guard liveObject.dataStatus == .fresh else { return }
        
        guard let channel = liveObject.object else { return }
        
        // Process fresh channel data
        let channelId = channel.channelId
        let displayName = channel.displayName
        
        // Stop observing after getting fresh data
        self?.token?.invalidate()
    }
}
```

### Direct Object Access

For local data without observation:

```swift
let liveObject: AmityObject<AmityChannel> = channelRepository.getChannel("1234")

// Access local data directly (if available)
if let channel = liveObject.object {
    print("Channel name: \(channel.displayName)")
}
```

<Info>
While direct access is possible, we recommend using `observe` or `observeOnce` blocks for reliable data access.
</Info>

### AmityLoadingStatus

Track loading states with `AmityLoadingStatus`:

| Value | Status | Description |
|-------|--------|-------------|
| `0` | `notLoading` | Data is fresh locally, no loading needed |
| `1` | `loading` | Currently loading from server |
| `2` | `loaded` | Successfully loaded fresh data |
| `3` | `error` | Failed to load due to error |

```swift
token = liveObject.observe { liveObject, error in
    switch liveObject.loadingStatus {
    case .notLoading:
        // Data is already fresh
        break
    case .loading:
        showLoadingIndicator()
    case .loaded:
        hideLoadingIndicator()
        updateUI(with: liveObject.object)
    case .error:
        hideLoadingIndicator()
        showErrorState()
    }
}
```
## AmityCollection - Collection Observation

`AmityCollection` is a generic class that tracks a collection of objects. Any collection encapsulated by `AmityCollection` becomes a live collection.

**Examples:**
- `AmityCollection<AmityMessage>`
- `AmityCollection<AmityChannel>`
- `AmityCollection<AmityPost>`

### Available Methods

Like `AmityObject`, `AmityCollection` exposes:

<CardGroup cols={2}>
  <Card title="observe" icon="eye">
    Continuously observes collection changes
  </Card>
  <Card title="observeOnce" icon="eye-slash">
    Observes collection once, then stops
  </Card>
</CardGroup>

<Warning>
Ensure the user is logged in before observing `AmityCollection`. Refer to the [authentication guide](/social-plus-sdk/getting-started/authentication) for details.
</Warning>

### Collection Data Access

Unlike traditional arrays, `AmityCollection` doesn't return all data at once. Instead, data is accessed individually using the `object(at:)` method, allowing efficient memory usage.

**Key Properties:**
- `count()` - Number of objects in collection
- `dataStatus` - Whether data is fresh or local
- `loadingStatus` - Current loading state

### Basic Collection Observation

```swift
var token: AmityNotificationToken?

func observeChannels() {
    // Create query for live channels
    let query = AmityChannelQuery()
    query.types = [AmityChannelQueryType.live]
    query.includeDeleted = false
    
    let liveCollection = channelRepository.getChannels(with: query)
    
    token = liveCollection.observe { liveCollection, change, error in
        guard error == nil else {
            print("Error observing channels: \(error!)")
            return
        }
        
        // Check data status
        let dataStatus: AmityDataStatus = liveCollection.dataStatus
        print("Data status: \(dataStatus)")
        
        // Access collection data
        print("Total channels: \(liveCollection.count())")
        
        // Loop through all channels
        for i in 0..<liveCollection.count() {
            if let channel = liveCollection.object(at: i) {
                let channelId = channel.channelId
                let displayName = channel.displayName
                print("Channel: \(displayName)")
            }
        }
    }
}
```

### Pagination

`AmityCollection` returns a maximum of 20 items per page with built-in pagination:

| Method | Description |
|--------|-------------|
| `nextPage()` | Load next page of results |
| `previousPage()` | Load previous page of results |
| `resetPage()` | Reset to first page |
| `hasNext` | Check if next page exists |
| `hasPrevious` | Check if previous page exists |

```swift
// Handle pagination in scroll view
func handlePagination() {
    guard let collection = liveCollection else { return }
    
    // Load next page when user scrolls to bottom
    if collection.hasNext {
        collection.nextPage()
    }
    
    // Reset to first page
    collection.resetPage()
}
```

### UITableView Integration

Complete example of using `AmityCollection` with UITableView:

```swift
class ChannelListViewController: UITableViewController {
    var liveCollection: AmityCollection<AmityChannel>!
    var token: AmityNotificationToken?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        tableView.register(UITableViewCell.self, forCellReuseIdentifier: "cell")
        setupDataSource()
    }
    
    func setupDataSource() {
        let query = AmityChannelQuery()
        query.types = [AmityChannelQueryType.live]
        query.includeDeleted = false
        
        // Get live collection
        liveCollection = channelRepository.getChannels(with: query)
        
        // Observe live collection
        token = liveCollection.observe { [weak self] liveCollection, changes, error in
            DispatchQueue.main.async {
                self?.tableView.reloadData()
            }
        }
    }
    
    override func numberOfSections(in tableView: UITableView) -> Int {
        return 1
    }
    
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return Int(liveCollection.count())
    }
    
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath)
        
        if let channel = liveCollection.object(at: indexPath.row) {
            cell.textLabel?.text = channel.displayName
        }
        
        return cell
    }
    
    override func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {
        // Load more when approaching the end
        if indexPath.row == Int(liveCollection.count()) - 3 && liveCollection.hasNext {
            liveCollection.nextPage()
        }
    }
}
    }
}
```

### Advanced Collection with Change Tracking

Handle granular collection changes for smooth UI updates:

```swift
private func observePostsWithChangeTracking() {
    postsToken = postsCollection?.observe { [weak self] liveCollection, change, error in
        guard let self = self else { return }
        
        if let error = error {
            self.handleError(error)
            return
        }
        
        // Handle specific changes for animated updates
        if let change = change {
            self.tableView.performBatchUpdates {
                // Handle deletions
                if !change.deletions.isEmpty {
                    let deletionPaths = change.deletions.map { IndexPath(row: $0, section: 0) }
                    self.tableView.deleteRows(at: deletionPaths, with: .fade)
                }
                
                // Handle insertions
                if !change.insertions.isEmpty {
                    let insertionPaths = change.insertions.map { IndexPath(row: $0, section: 0) }
                    self.tableView.insertRows(at: insertionPaths, with: .fade)
                }
                
                // Handle modifications
                if !change.modifications.isEmpty {
                    let modificationPaths = change.modifications.map { IndexPath(row: $0, section: 0) }
                    self.tableView.reloadRows(at: modificationPaths, with: .none)
                }
            }
        } else {
            // Full reload for initial data
            self.updatePostsArray()
            self.tableView.reloadData()
        }
    }
}

private func updatePostsArray() {
    guard let collection = postsCollection else { return }
    
    posts = []
    for i in 0..<collection.count() {
        if let post = collection.object(at: i) {
            posts.append(post)
        }
    }
}
```

### Pagination Implementation

```swift
extension PostListViewController: UITableViewDataSource, UITableViewDelegate {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return posts.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "PostCell", for: indexPath) as! PostCell
        cell.configure(with: posts[indexPath.row])
        return cell
    }
    
    func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {
        // Load more when approaching end
        if indexPath.row == posts.count - 3,
           let collection = postsCollection,
           collection.hasNext {
            collection.nextPage()
        }
    }
}
```

### Collection Utilities

Efficiently work with all objects in a collection:

```swift
// Get all objects at once
private func getAllPosts() -> [AmityPost] {
    guard let collection = postsCollection else { return [] }
    return collection.allObjects()
}

// Reset to first page
private func resetToFirstPage() {
    postsCollection?.resetPage()
}

// Check pagination status
private func updatePaginationUI() {
    guard let collection = postsCollection else { return }
    
    loadMoreButton.isEnabled = collection.hasNext
    previousButton.isEnabled = collection.hasPrevious
}
```

## SwiftUI Integration

Use live objects and collections directly in SwiftUI with `@ObservedObject`.

### SwiftUI Live Object

```swift
import SwiftUI
import AmitySDK

struct PostDetailView: View {
    @ObservedObject private var livePost: AmityObject<AmityPost>
    
    init(postId: String) {
        let repository = AmityPostRepository(client: AmityUIKitManager.client)
        self.livePost = repository.getPost(postId)
    }
    
    var body: some View {
        VStack {
            if livePost.loadingStatus == .loading {
                ProgressView("Loading post...")
            } else if let post = livePost.snapshot {
                VStack(alignment: .leading, spacing: 12) {
                    Text(post.displayName ?? "Untitled")
                        .font(.headline)
                    
                    if let content = post.data?["text"] as? String {
                        Text(content)
                            .font(.body)
                    }
                    
                    HStack {
                        Label("\(post.reactionsCount)", systemImage: "heart")
                        Label("\(post.commentsCount)", systemImage: "bubble")
                    }
                    .font(.caption)
                    .foregroundColor(.secondary)
                }
                .padding()
            } else {
                Text("Post not found")
                    .foregroundColor(.secondary)
            }
        }
        .navigationTitle("Post Details")
    }
}
```

### SwiftUI Live Collection

```swift
struct PostListView: View {
    @ObservedObject private var postsCollection: AmityCollection<AmityPost>
    
    init() {
        let repository = AmityPostRepository(client: AmityUIKitManager.client)
        self.postsCollection = repository.getPosts()
    }
    
    var body: some View {
        NavigationView {
            List {
                ForEach(postsCollection.snapshots, id: \.postId) { post in
                    PostRowView(post: post)
                        .onAppear {
                            loadMoreIfNeeded(for: post)
                        }
                }
            }
            .navigationTitle("Posts")
            .refreshable {
                postsCollection.resetPage()
            }
        }
    }
    
    private func loadMoreIfNeeded(for post: AmityPost) {
        if postsCollection.snapshots.last?.postId == post.postId,
           postsCollection.hasNext {
            postsCollection.nextPage()
        }
    }
}

struct PostRowView: View {
    let post: AmityPost
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(post.displayName ?? "Untitled")
                .font(.headline)
            
            if let content = post.data?["text"] as? String {
                Text(content)
                    .font(.body)
                    .lineLimit(3)
            }
            
            HStack {
                Label("\(post.reactionsCount)", systemImage: "heart")
                Label("\(post.commentsCount)", systemImage: "bubble")
                Spacer()
                Text(post.createdAt?.formatted() ?? "")
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
        .padding(.vertical, 4)
    }
}
```

### Combine Integration

Use with Combine for reactive programming:

```swift
import Combine
import AmitySDK

class PostViewModel: ObservableObject {
    @Published var posts: [AmityPost] = []
    @Published var isLoading = false
    @Published var error: Error?
    
    private var postsCollection: AmityCollection<AmityPost>?
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        setupPostsObservation()
    }
    
    private func setupPostsObservation() {
        let repository = AmityPostRepository(client: AmityUIKitManager.client)
        postsCollection = repository.getPosts()
        
        // Observe loading status
        postsCollection?.publisher(for: \.loadingStatus)
            .map { $0 == .loading }
            .assign(to: \.isLoading, on: self)
            .store(in: &cancellables)
        
        // Observe snapshots (data)
        postsCollection?.publisher(for: \.snapshots)
            .assign(to: \.posts, on: self)
            .store(in: &cancellables)
        
        // Observe errors
        postsCollection?.publisher(for: \.error)
            .compactMap { $0 }
            .assign(to: \.error, on: self)
            .store(in: &cancellables)
    }
    
    func loadMore() {
        postsCollection?.nextPage()
    }
    
    func refresh() {
        postsCollection?.resetPage()
    }
}
```

## Error Handling

Implement robust error handling for production applications:

```swift
private func handleAmityError(_ error: AmityError) {
    switch error.code {
    case .notLoggedIn:
        // Redirect to login
        showLoginRequired()
        
    case .permissionDenied:
        // Show permission error
        showAlert(title: "Access Denied", message: "You don't have permission to view this content.")
        
    case .networkError:
        // Show network error with retry
        showNetworkErrorWithRetry()
        
    case .rateLimitExceeded:
        // Show rate limit message
        showAlert(title: "Rate Limited", message: "Please wait before making more requests.")
        
    default:
        // Generic error handling
        showAlert(title: "Error", message: error.localizedDescription)
    }
}

private func showNetworkErrorWithRetry() {
    let alert = UIAlertController(
        title: "Network Error",
        message: "Failed to load data. Please check your connection and try again.",
        preferredStyle: .alert
    )
    
    alert.addAction(UIAlertAction(title: "Retry", style: .default) { _ in
        // Retry the operation
        self.observePosts()
    })
    
    alert.addAction(UIAlertAction(title: "Cancel", style: .cancel))
    
    present(alert, animated: true)
}
```

## Best Practices

### Memory Management

```swift
class PostManager {
    private var tokens: [AmityNotificationToken] = []
    
    func startObserving() {
        // Store all tokens
        let postToken = livePost.observe { ... }
        let commentsToken = liveComments.observe { ... }
        
        tokens.append(contentsOf: [postToken, commentsToken])
    }
    
    func stopObserving() {
        // Clean up all tokens
        tokens.forEach { $0.invalidate() }
        tokens.removeAll()
    }
    
    deinit {
        stopObserving()
    }
}
```

### Performance Optimization

```swift
// Use data status to avoid unnecessary UI updates
private func observePostsEfficiently() {
    postsToken = postsCollection?.observe { [weak self] liveCollection, change, error in
        // Only update UI for fresh data or significant changes
        guard liveCollection.dataStatus == .fresh || change != nil else {
            return
        }
        
        // Batch UI updates
        DispatchQueue.main.async {
            self?.updateUI()
        }
    }
}

// Implement efficient scrolling
func scrollViewDidScroll(_ scrollView: UIScrollView) {
    let threshold: CGFloat = 100
    let contentHeight = scrollView.contentSize.height
    let frameHeight = scrollView.frame.size.height
    let scrollOffset = scrollView.contentOffset.y
    
    if scrollOffset > contentHeight - frameHeight - threshold {
        loadMoreIfNeeded()
    }
}
```

### SwiftUI Common Issues

<Warning>
**Nested ObservableObject Issue**: When embedding `AmityCollection` inside another `ObservableObject`, SwiftUI may not detect changes properly.

**Solution**: Create dedicated views that directly observe Amity objects:

```swift
// ❌ Problematic pattern
class MyViewModel: ObservableObject {
    @Published var posts: AmityCollection<AmityPost>
    // SwiftUI won't detect changes in posts.snapshots
}

// ✅ Recommended pattern  
struct PostListView: View {
    @ObservedObject private var postsCollection: AmityCollection<AmityPost>
    // Direct observation works correctly
}
```
</Warning>

<Info>
**Published Property Timing**: `@Published` properties trigger updates in `willSet`, meaning subscribers receive the old value. Access the updated value in the next run loop or use snapshot properties directly.
</Info>

## Troubleshooting

### Common Issues

1. **Observations Not Triggering**
   - Ensure user is logged in
   - Verify token is retained in appropriate scope
   - Check network connectivity

2. **Memory Leaks**
   - Always invalidate tokens when done
   - Use weak references in closures
   - Implement proper cleanup in `deinit`

3. **SwiftUI Update Issues**
   - Use `snapshot`/`snapshots` properties instead of `model`/`models`
   - Create dedicated observer views
   - Avoid nested observable objects

4. **Performance Issues**
   - Implement efficient pagination
   - Use `dataStatus` to filter unnecessary updates
   - Batch UI updates on main queue

### Debug Information

Enable detailed logging for debugging:

```swift
// In your AppDelegate or App setup
AmityLogger.setLogLevel(.debug)

// Monitor observation lifecycle
postsToken = postsCollection?.observe { liveCollection, change, error in
    print("Collection updated: count=\(liveCollection.count()), status=\(liveCollection.dataStatus)")
    
    if let change = change {
        print("Changes - inserted: \(change.insertions), deleted: \(change.deletions), modified: \(change.modifications)")
    }
}
```

## Next Steps

- **[Core Concepts](../core-concept.mdx)** - Understanding SDK fundamentals
- **[Error Handling](../error-handling.mdx)** - Comprehensive error management  
- **[Session State](../session-state.mdx)** - Authentication and session management
- **[Real-time Events](../realtime-events/README.mdx)** - Advanced event handling