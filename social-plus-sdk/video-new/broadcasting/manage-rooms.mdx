---
title: "Manage Rooms"
description: "Query, update, stop, and delete rooms with comprehensive lifecycle management"
---

# Manage Rooms

Manage room lifecycle including queries, updates, stream control, and deletion operations for interactive livestreaming.

## Querying Rooms

### Get Room by ID

Retrieve a single room with real-time updates:

<CodeGroup>
```swift iOS
let roomLiveObject = AmityRoomRepository.shared.getRoom(roomId: "room-123")

roomLiveObject.observe { room in
    print("Room: \(room.title)")
    print("Status: \(room.status)")
    print("Participants: \(room.participants.count)")
    print("Live URL: \(room.livePlaybackUrl ?? "Not live")")
}
```

```kotlin Android
val roomLiveObject = AmityRoomRepository.getRoom(roomId = "room-123")

roomLiveObject.observe()
    .subscribe { room ->
        Log.d("Room", "Title: ${room.title}")
        Log.d("Room", "Status: ${room.status}")
        Log.d("Room", "Participants: ${room.participants.size}")
        Log.d("Room", "Live URL: ${room.livePlaybackUrl ?: "Not live"}")
    }
```

```typescript TypeScript
const roomLiveObject = roomRepository.getRoom("room-123");

roomLiveObject.on("dataUpdated", (room) => {
    console.log("Room:", room.title);
    console.log("Status:", room.status);
    console.log("Participants:", room.participants.length);
    console.log("Live URL:", room.livePlaybackUrl || "Not live");
});
```

```dart Flutter
final roomLiveObject = AmityRoomRepository().getRoom(roomId: "room-123");

roomLiveObject.listen((room) {
    print("Room: ${room.title}");
    print("Status: ${room.status}");
    print("Participants: ${room.participants.length}");
    print("Live URL: ${room.livePlaybackUrl ?? 'Not live'}");
});
```
</CodeGroup>

### Query Multiple Rooms

Get rooms with filtering and sorting:

<CodeGroup>
```swift iOS
let roomsCollection = AmityRoomRepository.shared.getRooms(
    statuses: [.live, .idle],
    types: [.coHosts],
    isDeleted: false,
    sortBy: .firstCreated
)

roomsCollection.observe { rooms in
    rooms.forEach { room in
        print("Room: \(room.title) - Status: \(room.status)")
    }
}
```

```kotlin Android
val roomsCollection = AmityRoomRepository.getRooms(
    statuses = listOf(AmityRoomStatus.LIVE, AmityRoomStatus.IDLE),
    types = listOf(AmityRoomType.CO_HOSTS),
    isDeleted = false,
    sortBy = AmityRoomSortOption.FIRST_CREATED
)

roomsCollection.observe()
    .subscribe { rooms ->
        rooms.forEach { room ->
            Log.d("Room", "Title: ${room.title} - Status: ${room.status}")
        }
    }
```

```typescript TypeScript
const roomsCollection = roomRepository.getRooms({
    statuses: [AmityRoomStatus.LIVE, AmityRoomStatus.IDLE],
    types: [AmityRoomType.CO_HOSTS],
    isDeleted: false,
    sortBy: AmityRoomSortOption.FIRST_CREATED
});

roomsCollection.on("dataUpdated", (rooms) => {
    rooms.forEach(room => {
        console.log(`Room: ${room.title} - Status: ${room.status}`);
    });
});
```

```dart Flutter
final roomsCollection = AmityRoomRepository().getRooms(
    statuses: [AmityRoomStatus.LIVE, AmityRoomStatus.IDLE],
    types: [AmityRoomType.CO_HOSTS],
    isDeleted: false,
    sortBy: AmityRoomSortOption.FIRST_CREATED
);

roomsCollection.listen((rooms) {
    for (var room in rooms) {
        print("Room: ${room.title} - Status: ${room.status}");
    }
});
```
</CodeGroup>

### Query Live Rooms Only

Get currently broadcasting rooms:

<CodeGroup>
```swift iOS
let liveRooms = AmityRoomRepository.shared.getRooms(
    statuses: [.live],
    types: nil,
    isDeleted: false,
    sortBy: .lastCreated
)

liveRooms.observe { rooms in
    print("Currently live: \(rooms.count) rooms")
}
```

```kotlin Android
val liveRooms = AmityRoomRepository.getRooms(
    statuses = listOf(AmityRoomStatus.LIVE),
    types = null,
    isDeleted = false,
    sortBy = AmityRoomSortOption.LAST_CREATED
)

liveRooms.observe()
    .subscribe { rooms ->
        Log.d("Room", "Currently live: ${rooms.size} rooms")
    }
```

```typescript TypeScript
const liveRooms = roomRepository.getRooms({
    statuses: [AmityRoomStatus.LIVE],
    types: null,
    isDeleted: false,
    sortBy: AmityRoomSortOption.LAST_CREATED
});

liveRooms.on("dataUpdated", (rooms) => {
    console.log("Currently live:", rooms.length, "rooms");
});
```

```dart Flutter
final liveRooms = AmityRoomRepository().getRooms(
    statuses: [AmityRoomStatus.LIVE],
    types: null,
    isDeleted: false,
    sortBy: AmityRoomSortOption.LAST_CREATED
);

liveRooms.listen((rooms) {
    print("Currently live: ${rooms.length} rooms");
});
```
</CodeGroup>

## Query Parameters

<AccordionGroup>
  <Accordion title="statuses" icon="signal">
    **Type:** `AmityRoomStatus[]`  
    **Required:** No  
    **Values:** `idle` | `live` | `waitingReconnect` | `ended` | `recorded`
    
    Filter rooms by their current status. Pass multiple statuses to match any.
  </Accordion>
  
  <Accordion title="types" icon="diagram-project">
    **Type:** `AmityRoomType[]`  
    **Required:** No  
    **Values:** `coHosts` | `directStreaming`
    
    Filter rooms by type.
  </Accordion>
  
  <Accordion title="isDeleted" icon="trash">
    **Type:** `boolean`  
    **Required:** No  
    **Default:** `false`
    
    Include or exclude deleted rooms.
  </Accordion>
  
  <Accordion title="sortBy" icon="sort">
    **Type:** `AmityRoomSortOption`  
    **Required:** No  
    **Values:** `firstCreated` | `lastCreated`  
    **Default:** `firstCreated`
    
    Sort rooms by creation date.
  </Accordion>
</AccordionGroup>

## Updating Rooms

Update room details (creator only):

<CodeGroup>
```swift iOS
Task { @MainActor in
    do {
        let updatedRoom = try await AmityRoomRepository.shared.updateRoom(
            roomId: "room-123",
            title: "Updated Room Title",
            description: "New description with updated details",
            thumbnailFileId: "new-thumbnail-file-id",
            metadata: ["category": "updated"],
            channelEnabled: true
        )
        print("Room updated: \(updatedRoom.title)")
    } catch {
        print("Failed to update room: \(error)")
    }
}
```

```kotlin Android
AmityRoomRepository.updateRoom(
    roomId = "room-123",
    title = "Updated Room Title",
    description = "New description with updated details",
    thumbnailFileId = "new-thumbnail-file-id",
    metadata = mapOf("category" to "updated"),
    channelEnabled = true
).subscribe(
    onSuccess = { room ->
        Log.d("Room", "Updated: ${room.title}")
    },
    onError = { error ->
        Log.e("Room", "Failed to update", error)
    }
)
```

```typescript TypeScript
try {
    const updatedRoom = await roomRepository.updateRoom("room-123", {
        title: "Updated Room Title",
        description: "New description with updated details",
        thumbnailFileId: "new-thumbnail-file-id",
        metadata: { category: "updated" },
        channelEnabled: true
    });
    console.log("Room updated:", updatedRoom.title);
} catch (error) {
    console.error("Failed to update room:", error);
}
```

```dart Flutter
try {
    final updatedRoom = await AmityRoomRepository().updateRoom(
        roomId: "room-123",
        title: "Updated Room Title",
        description: "New description with updated details",
        thumbnailFileId: "new-thumbnail-file-id",
        metadata: {"category": "updated"},
        channelEnabled: true
    );
    print("Room updated: ${updatedRoom.title}");
} catch (error) {
    print("Failed to update room: $error");
}
```
</CodeGroup>

<Note>
**Updatable Fields**: Only title, description, thumbnailFileId, metadata, and channelEnabled can be updated. Participants and room type cannot be changed after creation.
</Note>

## Stopping a Stream

Stop an active broadcast:

<CodeGroup>
```swift iOS
Task { @MainActor in
    do {
        try await AmityRoomRepository.shared.stop(roomId: "room-123")
        print("Stream stopped successfully")
    } catch {
        print("Failed to stop stream: \(error)")
    }
}
```

```kotlin Android
AmityRoomRepository.stop(roomId = "room-123")
    .subscribe(
        onComplete = {
            Log.d("Room", "Stream stopped successfully")
        },
        onError = { error ->
            Log.e("Room", "Failed to stop stream", error)
        }
    )
```

```typescript TypeScript
try {
    await roomRepository.stop("room-123");
    console.log("Stream stopped successfully");
} catch (error) {
    console.error("Failed to stop stream:", error);
}
```

```dart Flutter
try {
    await AmityRoomRepository().stop(roomId: "room-123");
    print("Stream stopped successfully");
} catch (error) {
    print("Failed to stop stream: $error");
}
```
</CodeGroup>

<Warning>
**Stream Status**: Stopping a stream changes the room status to "ended". The stream cannot be restarted in the same room.
</Warning>

## Deleting a Room

Permanently delete a room:

<CodeGroup>
```swift iOS
Task { @MainActor in
    do {
        try await AmityRoomRepository.shared.deleteRoom(roomId: "room-123")
        print("Room deleted successfully")
    } catch {
        print("Failed to delete room: \(error)")
    }
}
```

```kotlin Android
AmityRoomRepository.deleteRoom(roomId = "room-123")
    .subscribe(
        onComplete = {
            Log.d("Room", "Deleted successfully")
        },
        onError = { error ->
            Log.e("Room", "Failed to delete", error)
        }
    )
```

```typescript TypeScript
try {
    await roomRepository.deleteRoom("room-123");
    console.log("Room deleted successfully");
} catch (error) {
    console.error("Failed to delete room:", error);
}
```

```dart Flutter
try {
    await AmityRoomRepository().deleteRoom(roomId: "room-123");
    print("Room deleted successfully");
} catch (error) {
    print("Failed to delete room: $error");
}
```
</CodeGroup>

<Warning>
**Permanent Action**: Deleting a room is permanent and cannot be undone. Stop the stream before deleting.
</Warning>

## Getting Recorded URLs

Retrieve recorded stream URLs after broadcast ends:

<CodeGroup>
```swift iOS
Task { @MainActor in
    do {
        let recordedUrls = try await AmityRoomRepository.shared.getRecordedUrls(
            roomId: "room-123"
        )
        
        if recordedUrls.isEmpty {
            print("No recordings available")
        } else {
            recordedUrls.forEach { url in
                print("Recording URL: \(url)")
            }
        }
    } catch {
        print("Failed to get recorded URLs: \(error)")
    }
}
```

```kotlin Android
AmityRoomRepository.getRecordedUrls(roomId = "room-123")
    .subscribe(
        onSuccess = { urls ->
            if (urls.isEmpty()) {
                Log.d("Room", "No recordings available")
            } else {
                urls.forEach { url ->
                    Log.d("Room", "Recording URL: $url")
                }
            }
        },
        onError = { error ->
            Log.e("Room", "Failed to get recorded URLs", error)
        }
    )
```

```typescript TypeScript
try {
    const recordedUrls = await roomRepository.getRecordedUrls("room-123");
    
    if (recordedUrls.length === 0) {
        console.log("No recordings available");
    } else {
        recordedUrls.forEach(url => {
            console.log("Recording URL:", url);
        });
    }
} catch (error) {
    console.error("Failed to get recorded URLs:", error);
}
```

```dart Flutter
try {
    final recordedUrls = await AmityRoomRepository().getRecordedUrls(
        roomId: "room-123"
    );
    
    if (recordedUrls.isEmpty) {
        print("No recordings available");
    } else {
        for (var url in recordedUrls) {
            print("Recording URL: $url");
        }
    }
} catch (error) {
    print("Failed to get recorded URLs: $error");
}
```
</CodeGroup>

<Info>
**Recording Availability**: Recordings are available after the room status changes to "recorded". This may take some time after the stream ends.
</Info>

## Common Patterns

### Monitor Room Status

Track room status changes in real-time:

<CodeGroup>

```swift iOS
let roomLiveObject = AmityRoomRepository.shared.getRoom(roomId: roomId)

roomLiveObject.observe { room in
    switch room.status {
    case .idle:
        showStatus("Room created, ready to start")
        enableStartButton()
        
    case .live:
        showStatus("Broadcasting live")
        updateViewerCount()
        enableStopButton()
        
    case .waitingReconnect:
        showStatus("Reconnecting...")
        showReconnectingUI()
        
    case .ended:
        showStatus("Stream ended")
        disableStreamControls()
        checkForRecording()
        
    case .recorded:
        showStatus("Recording available")
        enablePlaybackButton()
    }
}
```

```kotlin Android
val roomLiveObject = AmityRoomRepository.getRoom(roomId = roomId)

roomLiveObject.observe()
    .subscribe { room ->
        when (room.status) {
            AmityRoomStatus.IDLE -> {
                showStatus("Room created, ready to start")
                enableStartButton()
            }
            AmityRoomStatus.LIVE -> {
                showStatus("Broadcasting live")
                updateViewerCount()
                enableStopButton()
            }
            AmityRoomStatus.WAITING_RECONNECT -> {
                showStatus("Reconnecting...")
                showReconnectingUI()
            }
            AmityRoomStatus.ENDED -> {
                showStatus("Stream ended")
                disableStreamControls()
                checkForRecording()
            }
            AmityRoomStatus.RECORDED -> {
                showStatus("Recording available")
                enablePlaybackButton()
            }
        }
    }
```

```typescript TypeScript
const roomLiveObject = roomRepository.getRoom(roomId);

roomLiveObject.on("dataUpdated", (room) => {
    switch (room.status) {
        case AmityRoomStatus.IDLE:
            showStatus("Room created, ready to start");
            enableStartButton();
            break;
            
        case AmityRoomStatus.LIVE:
            showStatus("Broadcasting live");
            updateViewerCount();
            enableStopButton();
            break;
            
        case AmityRoomStatus.WAITING_RECONNECT:
            showStatus("Reconnecting...");
            showReconnectingUI();
            break;
            
        case AmityRoomStatus.ENDED:
            showStatus("Stream ended");
            disableStreamControls();
            checkForRecording();
            break;
            
        case AmityRoomStatus.RECORDED:
            showStatus("Recording available");
            enablePlaybackButton();
            break;
    }
});
```

```dart Flutter
final roomLiveObject = AmityRoomRepository().getRoom(roomId: roomId);

roomLiveObject.listen((room) {
    switch (room.status) {
        case AmityRoomStatus.idle:
            showStatus("Room created, ready to start");
            enableStartButton();
            break;
            
        case AmityRoomStatus.live:
            showStatus("Broadcasting live");
            updateViewerCount();
            enableStopButton();
            break;
            
        case AmityRoomStatus.waitingReconnect:
            showStatus("Reconnecting...");
            showReconnectingUI();
            break;
            
        case AmityRoomStatus.ended:
            showStatus("Stream ended");
            disableStreamControls();
            checkForRecording();
            break;
            
        case AmityRoomStatus.recorded:
            showStatus("Recording available");
            enablePlaybackButton();
            break;
    }
});
```

</CodeGroup>

### Display Live Rooms List

Show currently active broadcasts:

<CodeGroup>

```swift iOS
let liveRooms = AmityRoomRepository.shared.getRooms(
    statuses: [.live],
    types: [.coHosts],
    isDeleted: false,
    sortBy: .lastCreated
)

liveRooms.observe { rooms in
    let roomList = rooms.map { room in
        RoomListItem(
            roomId: room.roomId,
            title: room.title,
            thumbnail: room.getThumbnail()?.fileUrl,
            participantCount: room.participants.count,
            playbackUrl: room.livePlaybackUrl,
            channelId: room.channelId
        )
    }
    updateLiveRoomsList(roomList)
}
```

```kotlin Android
val liveRooms = AmityRoomRepository.getRooms(
    statuses = listOf(AmityRoomStatus.LIVE),
    types = listOf(AmityRoomType.CO_HOSTS),
    isDeleted = false,
    sortBy = AmityRoomSortOption.LAST_CREATED
)

liveRooms.observe()
    .subscribe { rooms ->
        val roomList = rooms.map { room ->
            RoomListItem(
                roomId = room.roomId,
                title = room.title,
                thumbnail = room.getThumbnail()?.fileUrl,
                participantCount = room.participants.size,
                playbackUrl = room.livePlaybackUrl,
                channelId = room.channelId
            )
        }
        updateLiveRoomsList(roomList)
    }
```

```typescript TypeScript
const liveRooms = roomRepository.getRooms({
    statuses: [AmityRoomStatus.LIVE],
    types: [AmityRoomType.CO_HOSTS],
    sortBy: AmityRoomSortOption.LAST_CREATED
});

liveRooms.on("dataUpdated", (rooms) => {
    const roomList = rooms.map(room => ({
        roomId: room.roomId,
        title: room.title,
        thumbnail: room.getThumbnail()?.fileUrl,
        participantCount: room.participants.length,
        playbackUrl: room.livePlaybackUrl,
        channelId: room.channelId
    }));
    
    updateLiveRoomsList(roomList);
});
```

```dart Flutter
final liveRooms = AmityRoomRepository().getRooms(
    statuses: [AmityRoomStatus.live],
    types: [AmityRoomType.coHosts],
    isDeleted: false,
    sortBy: AmityRoomSortOption.lastCreated
);

liveRooms.listen((rooms) {
    final roomList = rooms.map((room) => RoomListItem(
        roomId: room.roomId,
        title: room.title,
        thumbnail: room.getThumbnail()?.fileUrl,
        participantCount: room.participants.length,
        playbackUrl: room.livePlaybackUrl,
        channelId: room.channelId,
    )).toList();
    
    updateLiveRoomsList(roomList);
});
```

</CodeGroup>

### Stream Lifecycle Management

Complete stream management workflow:

<CodeGroup>

```swift iOS
// Start streaming
func startStreaming(roomId: String) async {
    do {
        let broadcasterData = try await AmityRoomRepository.shared.getBroadcastData(
            roomId: roomId
        )
        
        if case .coHosts(let token, let url) = broadcasterData {
            try await initializeLiveKit(url: url, token: token)
        }
        
        try await beginBroadcast()
        print("Streaming started")
    } catch {
        print("Failed to start streaming: \(error)")
    }
}

// Stop streaming
func stopStreaming(roomId: String) async {
    do {
        endBroadcast()
        try await AmityRoomRepository.shared.stop(roomId: roomId)
        print("Streaming stopped")
        
        // Wait for recording
        DispatchQueue.main.asyncAfter(deadline: .now() + 30) {
            Task {
                if let urls = try? await AmityRoomRepository.shared.getRecordedUrls(roomId: roomId),
                   let firstUrl = urls.first {
                    print("Recording available: \(firstUrl)")
                }
            }
        }
    } catch {
        print("Failed to stop streaming: \(error)")
    }
}
```

```kotlin Android
// Start streaming
fun startStreaming(roomId: String) {
    AmityRoomRepository.getBroadcastData(roomId = roomId)
        .subscribe(
            onSuccess = { broadcasterData ->
                when (broadcasterData) {
                    is AmityRoomBroadcastData.CoHosts -> {
                        initializeLiveKit(
                            url = broadcasterData.coHostUrl,
                            token = broadcasterData.coHostToken
                        )
                    }
                    is AmityRoomBroadcastData.DirectStreaming -> {
                        initializeRTMP(url = broadcasterData.directStreamUrl)
                    }
                }
                beginBroadcast()
                Log.d("Stream", "Streaming started")
            },
            onError = { error ->
                Log.e("Stream", "Failed to start streaming", error)
            }
        )
}

// Stop streaming
fun stopStreaming(roomId: String) {
    endBroadcast()
    AmityRoomRepository.stop(roomId = roomId)
        .subscribe(
            onComplete = {
                Log.d("Stream", "Streaming stopped")
                
                // Wait for recording
                Handler(Looper.getMainLooper()).postDelayed({
                    AmityRoomRepository.getRecordedUrls(roomId = roomId)
                        .subscribe { urls ->
                            if (urls.isNotEmpty()) {
                                Log.d("Stream", "Recording available: ${urls.first()}")
                            }
                        }
                }, 30000)
            },
            onError = { error ->
                Log.e("Stream", "Failed to stop streaming", error)
            }
        )
}
```

```typescript TypeScript
// Start streaming
async function startStreaming(roomId: string) {
    try {
        const broadcasterData = await roomRepository.getBroadcastData(roomId);
        
        if (broadcasterData.type === "coHosts") {
            await initializeLiveKit(
                broadcasterData.coHostUrl,
                broadcasterData.coHostToken
            );
        }
        
        await beginBroadcast();
        console.log("Streaming started");
    } catch (error) {
        console.error("Failed to start streaming:", error);
    }
}

// Stop streaming
async function stopStreaming(roomId: string) {
    try {
        await endBroadcast();
        await roomRepository.stop(roomId);
        console.log("Streaming stopped");
        
        // Wait for recording
        setTimeout(async () => {
            const urls = await roomRepository.getRecordedUrls(roomId);
            if (urls.length > 0) {
                console.log("Recording available:", urls[0]);
            }
        }, 30000); // Wait 30 seconds for recording processing
    } catch (error) {
        console.error("Failed to stop streaming:", error);
    }
}
```

```dart Flutter
// Start streaming
Future<void> startStreaming(String roomId) async {
    try {
        final broadcasterData = await AmityRoomRepository().getBroadcastData(
            roomId: roomId
        );
        
        if (broadcasterData is CoHostsBroadcastData) {
            await initializeLiveKit(
                url: broadcasterData.coHostUrl,
                token: broadcasterData.coHostToken,
            );
        }
        
        await beginBroadcast();
        print("Streaming started");
    } catch (error) {
        print("Failed to start streaming: $error");
    }
}

// Stop streaming
Future<void> stopStreaming(String roomId) async {
    try {
        endBroadcast();
        await AmityRoomRepository().stop(roomId: roomId);
        print("Streaming stopped");
        
        // Wait for recording
        await Future.delayed(Duration(seconds: 30));
        final urls = await AmityRoomRepository().getRecordedUrls(roomId: roomId);
        if (urls.isNotEmpty) {
            print("Recording available: ${urls.first}");
        }
    } catch (error) {
        print("Failed to stop streaming: $error");
    }
}
```

</CodeGroup>

### Room Cleanup

Clean up ended rooms:

<CodeGroup>

```swift iOS
func cleanupEndedRooms() {
    let endedRooms = AmityRoomRepository.shared.getRooms(
        statuses: [.ended, .recorded],
        types: nil,
        isDeleted: false,
        sortBy: .firstCreated
    )
    
    endedRooms.observe { rooms in
        let oldRooms = rooms.filter { room in
            guard let endedAt = room.endedAt else { return false }
            let daysSinceEnd = Date().timeIntervalSince(endedAt) / (60 * 60 * 24)
            return daysSinceEnd > 7 // Older than 7 days
        }
        
        for room in oldRooms {
            Task {
                do {
                    try await AmityRoomRepository.shared.deleteRoom(roomId: room.roomId)
                    print("Deleted old room: \(room.roomId)")
                } catch {
                    print("Failed to delete room \(room.roomId): \(error)")
                }
            }
        }
    }
}
```

```kotlin Android
fun cleanupEndedRooms() {
    val endedRooms = AmityRoomRepository.getRooms(
        statuses = listOf(AmityRoomStatus.ENDED, AmityRoomStatus.RECORDED),
        types = null,
        isDeleted = false,
        sortBy = AmityRoomSortOption.FIRST_CREATED
    )
    
    endedRooms.observe()
        .subscribe { rooms ->
            val oldRooms = rooms.filter { room ->
                room.endedAt?.let { endedAt ->
                    val daysSinceEnd = (System.currentTimeMillis() - endedAt.time) / (1000 * 60 * 60 * 24)
                    daysSinceEnd > 7 // Older than 7 days
                } ?: false
            }
            
            oldRooms.forEach { room ->
                AmityRoomRepository.deleteRoom(roomId = room.roomId)
                    .subscribe(
                        onComplete = {
                            Log.d("Cleanup", "Deleted old room: ${room.roomId}")
                        },
                        onError = { error ->
                            Log.e("Cleanup", "Failed to delete room ${room.roomId}", error)
                        }
                    )
            }
        }
}
```

```typescript TypeScript
async function cleanupEndedRooms() {
    const endedRooms = roomRepository.getRooms({
        statuses: [AmityRoomStatus.ENDED, AmityRoomStatus.RECORDED],
        sortBy: AmityRoomSortOption.FIRST_CREATED
    });
    
    endedRooms.on("dataUpdated", async (rooms) => {
        const oldRooms = rooms.filter(room => {
            const endTime = new Date(room.endedAt!);
            const daysSinceEnd = (Date.now() - endTime.getTime()) / (1000 * 60 * 60 * 24);
            return daysSinceEnd > 7; // Older than 7 days
        });
        
        for (const room of oldRooms) {
            try {
                await roomRepository.deleteRoom(room.roomId);
                console.log(`Deleted old room: ${room.roomId}`);
            } catch (error) {
                console.error(`Failed to delete room ${room.roomId}:`, error);
            }
        }
    });
}
```

```dart Flutter
void cleanupEndedRooms() {
    final endedRooms = AmityRoomRepository().getRooms(
        statuses: [AmityRoomStatus.ended, AmityRoomStatus.recorded],
        types: null,
        isDeleted: false,
        sortBy: AmityRoomSortOption.firstCreated
    );
    
    endedRooms.listen((rooms) async {
        final oldRooms = rooms.where((room) {
            if (room.endedAt == null) return false;
            final daysSinceEnd = DateTime.now().difference(room.endedAt!).inDays;
            return daysSinceEnd > 7; // Older than 7 days
        }).toList();
        
        for (final room in oldRooms) {
            try {
                await AmityRoomRepository().deleteRoom(roomId: room.roomId);
                print("Deleted old room: ${room.roomId}");
            } catch (error) {
                print("Failed to delete room ${room.roomId}: $error");
            }
        }
    });
}
```

</CodeGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="Status Monitoring" icon="eye">
    Monitor room status for better UX:
    
    - Subscribe to room updates for real-time status
    - Handle all status transitions appropriately
    - Show appropriate UI for each status
    - Auto-reconnect on temporary disconnections
  </Accordion>
  
  <Accordion title="Stream Control" icon="toggle-on">
    Implement proper stream controls:
    
    - Validate room status before starting/stopping
    - Provide clear feedback to users
    - Handle network interruptions gracefully
    - Implement timeout mechanisms
  </Accordion>
  
  <Accordion title="Recording Management" icon="video">
    Manage recordings effectively:
    
    - Poll for recordings after stream ends
    - Store recording URLs for playback
    - Implement retry logic for unavailable recordings
    - Clean up old recordings
  </Accordion>
  
  <Accordion title="Resource Management" icon="memory">
    Optimize resource usage:
    
    - Unsubscribe from live collections when not needed
    - Delete ended rooms after recording retrieval
    - Limit concurrent live room queries
    - Cache frequently accessed room data
  </Accordion>
</AccordionGroup>

## Permission Checks

Verify permissions before operations:

<CodeGroup>

```swift iOS
// Check if user can stop/delete room
let roomLiveObject = AmityRoomRepository.shared.getRoom(roomId: roomId)

roomLiveObject.observe { room in
    let isCreator = room.creatorId == AmityCoreClient.currentUserId
    let isHost = room.participants.first { $0.type == .host && $0.userId == AmityCoreClient.currentUserId } != nil
    let isCoHost = room.participants.first { $0.type == .coHost && $0.userId == AmityCoreClient.currentUserId } != nil
    
    if isCreator || isHost {
        // User can stop or delete the room
        showStreamControls()
    } else if isCoHost {
        // Co-host can leave but not stop/delete
        showCoHostControls()
    } else {
        // User is viewer
        showViewerControls()
    }
}
```

```kotlin Android
// Check if user can stop/delete room
val roomLiveObject = AmityRoomRepository.getRoom(roomId = roomId)

roomLiveObject.observe()
    .subscribe { room ->
        val currentUserId = AmityCoreClient.getUserId()
        val isCreator = room.creatorId == currentUserId
        val isHost = room.participants.any { 
            it.type == AmityRoom.ParticipantType.HOST && it.userId == currentUserId 
        }
        val isCoHost = room.participants.any { 
            it.type == AmityRoom.ParticipantType.CoHost && it.userId == currentUserId 
        }
        
        when {
            isCreator || isHost -> {
                // User can stop or delete the room
                showStreamControls()
            }
            isCoHost -> {
                // Co-host can leave but not stop/delete
                showCoHostControls()
            }
            else -> {
                // User is viewer
                showViewerControls()
            }
        }
    }
```

```typescript TypeScript
// Check if user can stop/delete room
const roomLiveObject = roomRepository.getRoom(roomId);

roomLiveObject.on("dataUpdated", (room) => {
    const currentUserId = amityClient.userId;
    const isCreator = room.creatorId === currentUserId;
    const isHost = room.participants.some(
        p => p.type === 'host' && p.userId === currentUserId
    );
    const isCoHost = room.participants.some(
        p => p.type === 'coHost' && p.userId === currentUserId
    );

    if (isCreator || isHost) {
        // User can stop or delete the room
        showStreamControls();
    } else if (isCoHost) {
        // Co-host can leave but not stop/delete
        showCoHostControls();
    } else {
        // User is viewer
        showViewerControls();
    }
});
```

```dart Flutter
// Check if user can stop/delete room
final roomLiveObject = AmityRoomRepository().getRoom(roomId: roomId);

roomLiveObject.listen((room) {
    final currentUserId = AmityCoreClient.userId;
    final isCreator = room.creatorId == currentUserId;
    final isHost = room.participants.any(
        (p) => p.type == ParticipantType.host && p.userId == currentUserId
    );
    final isCoHost = room.participants.any(
        (p) => p.type == ParticipantType.coHost && p.userId == currentUserId
    );
    
    if (isCreator || isHost) {
        // User can stop or delete the room
        showStreamControls();
    } else if (isCoHost) {
        // Co-host can leave but not stop/delete
        showCoHostControls();
    } else {
        // User is viewer
        showViewerControls();
    }
});
```

</CodeGroup>

## Error Handling

<CodeGroup>
```swift iOS
do {
    try await AmityRoomRepository.shared.stop(roomId: roomId)
} catch AmityError.permissionDenied {
    showError("You don't have permission to stop this stream")
} catch AmityError.notFound {
    showError("Room not found")
} catch AmityError.invalidStatus {
    showError("Stream is not currently active")
} catch {
    showError("Failed to stop stream: \(error.localizedDescription)")
}
```

```kotlin Android
AmityRoomRepository.stop(roomId = roomId)
    .subscribe(
        onComplete = { /* Success */ },
        onError = { error ->
            when (error) {
                is AmityException.PermissionDenied -> {
                    showError("You don't have permission to stop this stream")
                }
                is AmityException.NotFound -> {
                    showError("Room not found")
                }
                is AmityException.InvalidStatus -> {
                    showError("Stream is not currently active")
                }
                else -> {
                    showError("Failed to stop stream: ${error.message}")
                }
            }
        }
    )
```

```typescript TypeScript
try {
    await roomRepository.stop(roomId);
} catch (error) {
    if (error.code === 'PERMISSION_DENIED') {
        showError("You don't have permission to stop this stream");
    } else if (error.code === 'NOT_FOUND') {
        showError("Room not found");
    } else if (error.code === 'INVALID_STATUS') {
        showError("Stream is not currently active");
    } else {
        showError(`Failed to stop stream: ${error.message}`);
    }
}
```

```dart Flutter
try {
    await AmityRoomRepository().stop(roomId: roomId);
} catch (error) {
    if (error is AmityPermissionDeniedException) {
        showError("You don't have permission to stop this stream");
    } else if (error is AmityNotFoundException) {
        showError("Room not found");
    } else if (error is AmityInvalidStatusException) {
        showError("Stream is not currently active");
    } else {
        showError("Failed to stop stream: $error");
    }
}
```
</CodeGroup>

## Related Topics

<CardGroup cols={3}>
  <Card title="Rooms Overview" href="./rooms-overview" icon="book">
    Learn about room concepts
  </Card>
  <Card title="Create Room" href="./create-room" icon="plus">
    Set up new rooms
  </Card>
  <Card title="Livestream Posts" href="/social-plus-sdk/social/posts/livestream-posts" icon="video">
    Link rooms to posts
  </Card>
</CardGroup>
