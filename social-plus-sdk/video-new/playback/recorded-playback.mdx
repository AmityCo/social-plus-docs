---
title: Recorded Stream Playback
description: Play back recorded live streams with full video controls and quality options
---

# Recorded Stream Playback

After a live stream ends, it's automatically processed and saved as a recorded video. This guide covers how to play recorded streams with full video controls and different format options.

## Understanding Recorded Streams

### Stream Recording Process

When a live stream ends, it goes through several states:

1. **LIVE** → Stream is actively broadcasting
2. **ENDED** → Stream has stopped, recording is being processed
3. **RECORDED** → Recording is ready for playback

<Note>
There may be a delay between when a stream ends (ENDED status) and when the recording becomes available (RECORDED status). Processing time depends on stream duration and server load.
</Note>

### Supported Recording Formats

Different platforms support various recording formats:

| Platform | FLV | MP4 | M3U8/HLS | Native Player |
|----------|:---:|:---:|:--------:|:-------------:|
| Android | ✅ | ✅ | ✅ | ExoPlayer recommended |
| iOS | ❌ | ✅ | ✅ | AVPlayer native support |
| Web | ❌ | ✅ | ✅ | HTML5 video |
| React Native | ❌ | ✅ | ✅ | Platform-specific |
| Flutter | ❌ | ✅ | ✅ | video_player package |

## Accessing Recorded Content

### Get Recording URLs

<Tabs>
<TabItem value="android" label="Android">

```kotlin
class RecordedStreamManager {
    
    fun getRecordedStreamUrls(streamId: String) {
        streamRepository
            .getStream(streamId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe { stream ->
                if (stream.status == AmityStream.Status.RECORDED) {
                    val recordings = stream.recordings
                    
                    recordings.forEach { recording ->
                        // Get different format URLs
                        val flvUrl = recording.getUrl(AmityRecordingData.Format.FLV)
                        val mp4Url = recording.getUrl(AmityRecordingData.Format.MP4)
                        val hlsUrl = recording.getUrl(AmityRecordingData.Format.M3U8)
                        
                        Log.d("Recording", "FLV URL: $flvUrl")
                        Log.d("Recording", "MP4 URL: $mp4Url")
                        Log.d("Recording", "HLS URL: $hlsUrl")
                        
                        // Choose preferred format for playback
                        playRecording(mp4Url ?: flvUrl ?: hlsUrl)
                    }
                } else {
                    when (stream.status) {
                        AmityStream.Status.ENDED -> {
                            showMessage("Recording is being processed, please wait...")
                        }
                        AmityStream.Status.LIVE -> {
                            showMessage("Stream is currently live")
                        }
                        else -> {
                            showMessage("No recording available")
                        }
                    }
                }
            }
    }
    
    private fun playRecording(url: String?) {
        url?.let { videoUrl ->
            setupExoPlayerForRecording(videoUrl)
        }
    }
}
```

</TabItem>
<TabItem value="ios" label="iOS">

```swift
class RecordedStreamManager {
    
    func getRecordedStreamUrls(streamId: String) {
        let streamProxy = streamRepository.getStreamById(streamId)
        
        streamToken = streamProxy.observe { [weak self] proxy, error in
            guard let stream = proxy.object else { return }
            
            if stream.status == .recorded {
                self?.processRecordingData(stream.recordingData)
            } else {
                switch stream.status {
                case .ended:
                    self?.showMessage("Recording is being processed, please wait...")
                case .live:
                    self?.showMessage("Stream is currently live")
                default:
                    self?.showMessage("No recording available")
                }
            }
        }
    }
    
    private func processRecordingData(_ recordingData: [AmityLiveVideoRecordingData]) {
        for (index, dataItem) in recordingData.enumerated() {
            // Get MP4 URL (preferred for iOS)
            if let mp4Url = dataItem.url(for: .MP4) {
                print("Recording \(index) MP4 URL: \(mp4Url)")
                playRecordedVideo(url: mp4Url)
                return
            }
            
            // Fallback to HLS if MP4 not available
            if let hlsUrl = dataItem.url(for: .M3U8) {
                print("Recording \(index) HLS URL: \(hlsUrl)")
                playRecordedVideo(url: hlsUrl)
                return
            }
        }
        
        showError("No compatible recording format found")
    }
    
    private func playRecordedVideo(url: URL) {
        // Use AVPlayer for recorded content (iOS native support)
        let player = AVPlayer(url: url)
        let playerViewController = AVPlayerViewController()
        playerViewController.player = player
        
        present(playerViewController, animated: true) {
            player.play()
        }
    }
}
```

</TabItem>
<TabItem value="web" label="Web">

```typescript
class RecordedStreamManager {
    
    async getRecordedStreamUrls(streamId: string) {
        try {
            const { data: stream } = await StreamRepository.getStream(streamId);
            
            if (stream.status === 'recorded') {
                return this.processRecordings(stream.recordings);
            } else {
                switch (stream.status) {
                    case 'ended':
                        throw new Error("Recording is being processed, please wait...");
                    case 'live':
                        throw new Error("Stream is currently live");
                    default:
                        throw new Error("No recording available");
                }
            }
        } catch (error) {
            console.error('Failed to get recorded stream:', error);
            throw error;
        }
    }
    
    private processRecordings(recordings: any[]) {
        const availableFormats: { format: string; url: string }[] = [];
        
        recordings.forEach((recording, index) => {
            if (recording.mp4Url) {
                availableFormats.push({ format: 'MP4', url: recording.mp4Url });
            }
            if (recording.hlsUrl) {
                availableFormats.push({ format: 'HLS', url: recording.hlsUrl });
            }
        });
        
        return availableFormats;
    }
    
    async playRecordedVideo(url: string, format: string) {
        const videoElement = document.getElementById('recordedVideo') as HTMLVideoElement;
        
        if (format === 'HLS' && url.includes('.m3u8')) {
            // Use HLS.js for HLS streams
            if (Hls.isSupported()) {
                const hls = new Hls();
                hls.loadSource(url);
                hls.attachMedia(videoElement);
                
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    videoElement.play();
                });
            } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
                // Safari native HLS support
                videoElement.src = url;
                await videoElement.play();
            }
        } else {
            // Direct MP4 playback
            videoElement.src = url;
            await videoElement.play();
        }
    }
}
```

</TabItem>
<TabItem value="react-native" label="React Native">

```typescript
import { StreamRepository } from '@amityco/ts-sdk-react-native';

class RecordedStreamManager {
    
    async getRecordedStreamUrls(streamId: string) {
        return new Promise((resolve, reject) => {
            const unsubscriber = StreamRepository.getStreamById(streamId, ({ data, error }) => {
                if (error) {
                    reject(new Error(`Failed to get stream: ${error.message}`));
                    return;
                }
                
                if (data) {
                    if (data.status === 'recorded') {
                        const recordings = this.processRecordings(data.recordings);
                        resolve(recordings);
                    } else {
                        switch (data.status) {
                            case 'ended':
                                reject(new Error("Recording is being processed, please wait..."));
                                break;
                            case 'live':
                                reject(new Error("Stream is currently live"));
                                break;
                            default:
                                reject(new Error("No recording available"));
                        }
                    }
                }
                
                unsubscriber();
            });
        });
    }
    
    private processRecordings(recordings: any[]) {
        return recordings.map((recording, index) => ({
            index,
            mp4Url: recording.mp4Url,
            hlsUrl: recording.hlsUrl,
            duration: recording.duration,
            fileSize: recording.fileSize
        }));
    }
}
```

</TabItem>
<TabItem value="flutter" label="Flutter">

```dart
class RecordedStreamManager {
    
    Future<List<RecordingInfo>> getRecordedStreamUrls(String streamId) async {
        try {
            final stream = await AmityStreamRepository.getStreamById(streamId);
            
            if (stream.status == AmityStreamStatus.recorded) {
                return _processRecordings(stream.recordings);
            } else {
                switch (stream.status) {
                    case AmityStreamStatus.ended:
                        throw Exception("Recording is being processed, please wait...");
                    case AmityStreamStatus.live:
                        throw Exception("Stream is currently live");
                    default:
                        throw Exception("No recording available");
                }
            }
        } catch (error) {
            print('Failed to get recorded stream: $error');
            rethrow;
        }
    }
    
    List<RecordingInfo> _processRecordings(List<dynamic> recordings) {
        return recordings.asMap().entries.map((entry) {
            final index = entry.key;
            final recording = entry.value;
            
            return RecordingInfo(
                index: index,
                mp4Url: recording.mp4Url,
                hlsUrl: recording.hlsUrl,
                duration: recording.duration,
                fileSize: recording.fileSize,
            );
        }).toList();
    }
}

class RecordingInfo {
    final int index;
    final String? mp4Url;
    final String? hlsUrl;
    final Duration? duration;
    final int? fileSize;
    
    RecordingInfo({
        required this.index,
        this.mp4Url,
        this.hlsUrl,
        this.duration,
        this.fileSize,
    });
}
```

</TabItem>
</Tabs>

## Video Player Implementation

### Platform-Specific Players

<Tabs>
<TabItem value="android" label="Android">

#### ExoPlayer for Recorded Videos

```kotlin
import com.google.android.exoplayer2.*
import com.google.android.exoplayer2.ui.PlayerView

class RecordedVideoPlayer(private val context: Context) {
    
    private var exoPlayer: ExoPlayer? = null
    private var playerView: PlayerView? = null
    
    fun setupPlayer(playerView: PlayerView) {
        this.playerView = playerView
        
        exoPlayer = ExoPlayer.Builder(context).build()
        playerView.player = exoPlayer
        
        // Add player event listeners
        exoPlayer?.addListener(object : Player.Listener {
            override fun onPlayerStateChanged(playWhenReady: Boolean, playbackState: Int) {
                when (playbackState) {
                    Player.STATE_READY -> {
                        Log.d("Player", "Ready to play")
                    }
                    Player.STATE_BUFFERING -> {
                        Log.d("Player", "Buffering...")
                    }
                    Player.STATE_ENDED -> {
                        Log.d("Player", "Playback ended")
                    }
                    Player.STATE_IDLE -> {
                        Log.d("Player", "Player idle")
                    }
                }
            }
            
            override fun onPlayerError(error: PlaybackException) {
                Log.e("Player", "Playback error: ${error.message}")
                handlePlayerError(error)
            }
        })
    }
    
    fun playRecording(url: String) {
        val mediaItem = MediaItem.fromUri(url)
        exoPlayer?.setMediaItem(mediaItem)
        exoPlayer?.prepare()
        exoPlayer?.playWhenReady = true
    }
    
    fun pause() {
        exoPlayer?.pause()
    }
    
    fun resume() {
        exoPlayer?.play()
    }
    
    fun seekTo(positionMs: Long) {
        exoPlayer?.seekTo(positionMs)
    }
    
    fun getCurrentPosition(): Long {
        return exoPlayer?.currentPosition ?: 0
    }
    
    fun getDuration(): Long {
        return exoPlayer?.duration ?: 0
    }
    
    fun release() {
        exoPlayer?.release()
        exoPlayer = null
    }
    
    private fun handlePlayerError(error: PlaybackException) {
        // Handle different types of errors
        when (error.errorCode) {
            PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED -> {
                // Network error - retry or show message
                Log.e("Player", "Network connection failed")
            }
            PlaybackException.ERROR_CODE_PARSING_CONTAINER_MALFORMED -> {
                // File format error
                Log.e("Player", "Invalid video format")
            }
            else -> {
                Log.e("Player", "Unknown playback error: ${error.message}")
            }
        }
    }
}
```

#### Layout for Recorded Video

```xml
<androidx.constraintlayout.widget.ConstraintLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <com.google.android.exoplayer2.ui.PlayerView
        android:id="@+id/player_view"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        app:layout_constraintDimensionRatio="16:9"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:use_controller="true"
        app:show_buffering="when_playing" />
        
    <!-- Custom controls can be added here -->
    
</androidx.constraintlayout.widget.ConstraintLayout>
```

</TabItem>
<TabItem value="ios" label="iOS">

#### AVPlayer for Recorded Videos

```swift
import AVKit
import AVFoundation

class RecordedVideoPlayer {
    private var player: AVPlayer?
    private var playerViewController: AVPlayerViewController?
    private var timeObserver: Any?
    
    func setupPlayer() -> AVPlayerViewController {
        playerViewController = AVPlayerViewController()
        return playerViewController!
    }
    
    func playRecording(url: URL) {
        player = AVPlayer(url: url)
        playerViewController?.player = player
        
        // Add time observer for progress tracking
        setupTimeObserver()
        
        // Add player status observer
        player?.addObserver(self, forKeyPath: "status", options: [], context: nil)
        
        // Start playback
        player?.play()
    }
    
    private func setupTimeObserver() {
        let interval = CMTime(seconds: 1.0, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        timeObserver = player?.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            self?.updatePlaybackProgress(time)
        }
    }
    
    private func updatePlaybackProgress(_ time: CMTime) {
        let currentTime = CMTimeGetSeconds(time)
        let duration = CMTimeGetSeconds(player?.currentItem?.duration ?? CMTime.zero)
        
        // Update UI with progress
        let progress = currentTime / duration
        print("Playback progress: \(progress * 100)%")
    }
    
    // Player controls
    func pause() {
        player?.pause()
    }
    
    func resume() {
        player?.play()
    }
    
    func seekTo(seconds: Double) {
        let time = CMTime(seconds: seconds, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        player?.seek(to: time)
    }
    
    func getCurrentTime() -> Double {
        return CMTimeGetSeconds(player?.currentTime() ?? CMTime.zero)
    }
    
    func getDuration() -> Double {
        return CMTimeGetSeconds(player?.currentItem?.duration ?? CMTime.zero)
    }
    
    // Cleanup
    func cleanup() {
        if let timeObserver = timeObserver {
            player?.removeTimeObserver(timeObserver)
            self.timeObserver = nil
        }
        
        player?.removeObserver(self, forKeyPath: "status")
        player = nil
        playerViewController = nil
    }
    
    // Observer for player status
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if keyPath == "status" {
            if let player = object as? AVPlayer {
                switch player.status {
                case .readyToPlay:
                    print("Player ready to play")
                case .failed:
                    print("Player failed: \(player.error?.localizedDescription ?? "Unknown error")")
                    handlePlayerError(player.error)
                case .unknown:
                    print("Player status unknown")
                @unknown default:
                    break
                }
            }
        }
    }
    
    private func handlePlayerError(_ error: Error?) {
        guard let error = error else { return }
        print("Player error: \(error.localizedDescription)")
        // Handle error appropriately
    }
}
```

#### social.plus Recorded Stream Player

```swift
import AmityVideoPlayerKit

class AmityRecordedPlayer {
    private var recordedStreamPlayer: AmityRecordedStreamPlayer?
    
    func setupPlayer() -> UIView {
        recordedStreamPlayer = AmityRecordedStreamPlayer()
        recordedStreamPlayer?.delegate = self
        return recordedStreamPlayer!.playerView
    }
    
    func playRecording(url: URL) {
        recordedStreamPlayer?.play(url: url)
    }
}

extension AmityRecordedPlayer: AmityRecordedStreamPlayerDelegate {
    func playerDidStartPlaying() {
        print("Recorded stream playback started")
    }
    
    func playerDidFailWithError(_ error: Error) {
        print("Recorded stream player error: \(error.localizedDescription)")
    }
    
    func playerDidFinishPlaying() {
        print("Recorded stream playback finished")
    }
}
```

</TabItem>
<TabItem value="web" label="Web">

#### HTML5 Video Player

```html
<div class="video-container">
    <video 
        id="recordedVideo" 
        controls 
        preload="metadata"
        poster="thumbnail.jpg">
        Your browser does not support the video tag.
    </video>
    
    <!-- Custom controls (optional) -->
    <div class="custom-controls">
        <button id="playPauseBtn">Play/Pause</button>
        <input type="range" id="progressBar" min="0" max="100" value="0">
        <span id="timeDisplay">00:00 / 00:00</span>
        <button id="fullscreenBtn">Fullscreen</button>
    </div>
</div>
```

```javascript
class RecordedVideoPlayer {
    constructor(videoElementId) {
        this.video = document.getElementById(videoElementId);
        this.setupEventListeners();
        this.setupCustomControls();
    }
    
    async playRecording(url, format = 'MP4') {
        try {
            if (format === 'HLS' && url.includes('.m3u8')) {
                await this.setupHLSPlayer(url);
            } else {
                // Direct MP4 playback
                this.video.src = url;
                await this.video.play();
            }
        } catch (error) {
            console.error('Failed to play recording:', error);
            this.handlePlayerError(error);
        }
    }
    
    async setupHLSPlayer(hlsUrl) {
        if (Hls.isSupported()) {
            this.hls = new Hls({
                enableWorker: true,
                lowLatencyMode: false,
            });
            
            this.hls.loadSource(hlsUrl);
            this.hls.attachMedia(this.video);
            
            this.hls.on(Hls.Events.MANIFEST_PARSED, () => {
                this.video.play();
            });
            
            this.hls.on(Hls.Events.ERROR, (event, data) => {
                console.error('HLS error:', data);
                this.handleHLSError(data);
            });
        } else if (this.video.canPlayType('application/vnd.apple.mpegurl')) {
            // Safari native HLS support
            this.video.src = hlsUrl;
            await this.video.play();
        } else {
            throw new Error('HLS not supported in this browser');
        }
    }
    
    setupEventListeners() {
        this.video.addEventListener('loadstart', () => {
            console.log('Video loading started');
        });
        
        this.video.addEventListener('loadedmetadata', () => {
            console.log('Video metadata loaded');
            this.updateDuration();
        });
        
        this.video.addEventListener('canplay', () => {
            console.log('Video can start playing');
        });
        
        this.video.addEventListener('playing', () => {
            console.log('Video started playing');
        });
        
        this.video.addEventListener('pause', () => {
            console.log('Video paused');
        });
        
        this.video.addEventListener('ended', () => {
            console.log('Video ended');
            this.onVideoEnded();
        });
        
        this.video.addEventListener('timeupdate', () => {
            this.updateProgress();
        });
        
        this.video.addEventListener('error', (e) => {
            console.error('Video error:', e);
            this.handlePlayerError(e);
        });
    }
    
    setupCustomControls() {
        const playPauseBtn = document.getElementById('playPauseBtn');
        const progressBar = document.getElementById('progressBar');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        
        playPauseBtn?.addEventListener('click', () => {
            if (this.video.paused) {
                this.video.play();
            } else {
                this.video.pause();
            }
        });
        
        progressBar?.addEventListener('input', (e) => {
            const seekTime = (e.target.value / 100) * this.video.duration;
            this.video.currentTime = seekTime;
        });
        
        fullscreenBtn?.addEventListener('click', () => {
            if (this.video.requestFullscreen) {
                this.video.requestFullscreen();
            }
        });
    }
    
    updateProgress() {
        const progressBar = document.getElementById('progressBar');
        const timeDisplay = document.getElementById('timeDisplay');
        
        if (progressBar && this.video.duration) {
            const progress = (this.video.currentTime / this.video.duration) * 100;
            progressBar.value = progress;
        }
        
        if (timeDisplay) {
            const current = this.formatTime(this.video.currentTime);
            const duration = this.formatTime(this.video.duration);
            timeDisplay.textContent = `${current} / ${duration}`;
        }
    }
    
    updateDuration() {
        const timeDisplay = document.getElementById('timeDisplay');
        if (timeDisplay) {
            const duration = this.formatTime(this.video.duration);
            timeDisplay.textContent = `00:00 / ${duration}`;
        }
    }
    
    formatTime(seconds) {
        if (isNaN(seconds)) return '00:00';
        
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    
    handlePlayerError(error) {
        console.error('Player error:', error);
        // Show user-friendly error message
        this.showError('Unable to play video. Please try again.');
    }
    
    handleHLSError(data) {
        if (data.fatal) {
            switch (data.type) {
                case Hls.ErrorTypes.NETWORK_ERROR:
                    console.error('Fatal network error');
                    this.hls.startLoad();
                    break;
                case Hls.ErrorTypes.MEDIA_ERROR:
                    console.error('Fatal media error');
                    this.hls.recoverMediaError();
                    break;
                default:
                    console.error('Fatal error, cannot recover');
                    this.hls.destroy();
                    break;
            }
        }
    }
    
    onVideoEnded() {
        // Handle video end (show replay button, suggest related content, etc.)
        console.log('Video playback completed');
    }
    
    destroy() {
        if (this.hls) {
            this.hls.destroy();
        }
    }
}
```

</TabItem>
<TabItem value="react-native" label="React Native">

#### React Native Video Player

```typescript
import React, { useRef, useState, useEffect } from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Alert } from 'react-native';
import Video from 'react-native-video';

interface Props {
    recordingUrl: string;
    title?: string;
}

const RecordedVideoPlayer: React.FC<Props> = ({ recordingUrl, title }) => {
    const videoRef = useRef<Video>(null);
    const [isPlaying, setIsPlaying] = useState(false);
    const [currentTime, setCurrentTime] = useState(0);
    const [duration, setDuration] = useState(0);
    const [loading, setLoading] = useState(true);
    
    const handleLoad = (data: any) => {
        setDuration(data.duration);
        setLoading(false);
        console.log('Video loaded, duration:', data.duration);
    };
    
    const handleProgress = (data: any) => {
        setCurrentTime(data.currentTime);
    };
    
    const handleEnd = () => {
        setIsPlaying(false);
        setCurrentTime(0);
        console.log('Video playback ended');
    };
    
    const handleError = (error: any) => {
        setLoading(false);
        console.error('Video error:', error);
        Alert.alert('Playback Error', 'Unable to play the video. Please try again.');
    };
    
    const togglePlayPause = () => {
        setIsPlaying(!isPlaying);
    };
    
    const seekTo = (time: number) => {
        videoRef.current?.seek(time);
    };
    
    const formatTime = (seconds: number) => {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    };
    
    return (
        <View style={styles.container}>
            {title && <Text style={styles.title}>{title}</Text>}
            
            <Video
                ref={videoRef}
                source={{ uri: recordingUrl }}
                style={styles.video}
                paused={!isPlaying}
                onLoad={handleLoad}
                onProgress={handleProgress}
                onEnd={handleEnd}
                onError={handleError}
                resizeMode="contain"
                controls={false} // Use custom controls
            />
            
            {loading && (
                <View style={styles.loadingOverlay}>
                    <Text>Loading...</Text>
                </View>
            )}
            
            {/* Custom Controls */}
            <View style={styles.controls}>
                <TouchableOpacity onPress={togglePlayPause} style={styles.playButton}>
                    <Text style={styles.buttonText}>
                        {isPlaying ? 'Pause' : 'Play'}
                    </Text>
                </TouchableOpacity>
                
                <View style={styles.timeContainer}>
                    <Text style={styles.timeText}>
                        {formatTime(currentTime)} / {formatTime(duration)}
                    </Text>
                </View>
                
                {/* Progress bar could be added here */}
            </View>
        </View>
    );
};

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#000',
    },
    title: {
        color: '#fff',
        fontSize: 18,
        fontWeight: 'bold',
        padding: 16,
    },
    video: {
        flex: 1,
        aspectRatio: 16 / 9,
    },
    loadingOverlay: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
    },
    controls: {
        flexDirection: 'row',
        alignItems: 'center',
        padding: 16,
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
    },
    playButton: {
        backgroundColor: '#007AFF',
        paddingHorizontal: 20,
        paddingVertical: 10,
        borderRadius: 8,
    },
    buttonText: {
        color: '#fff',
        fontWeight: 'bold',
    },
    timeContainer: {
        flex: 1,
        alignItems: 'center',
    },
    timeText: {
        color: '#fff',
        fontSize: 16,
    },
});

export default RecordedVideoPlayer;
```

</TabItem>
<TabItem value="flutter" label="Flutter">

#### Flutter Video Player

```dart
import 'package:flutter/material.dart';
import 'package:video_player/video_player.dart';

class RecordedVideoPlayer extends StatefulWidget {
    final String videoUrl;
    final String? title;
    
    const RecordedVideoPlayer({
        Key? key,
        required this.videoUrl,
        this.title,
    }) : super(key: key);
    
    @override
    _RecordedVideoPlayerState createState() => _RecordedVideoPlayerState();
}

class _RecordedVideoPlayerState extends State<RecordedVideoPlayer> {
    late VideoPlayerController _controller;
    bool _isInitialized = false;
    bool _hasError = false;
    
    @override
    void initState() {
        super.initState();
        _initializePlayer();
    }
    
    Future<void> _initializePlayer() async {
        try {
            _controller = VideoPlayerController.network(widget.videoUrl);
            
            await _controller.initialize();
            
            // Add listener for player state changes
            _controller.addListener(_onPlayerStateChanged);
            
            setState(() {
                _isInitialized = true;
            });
            
            // Auto-play the video
            await _controller.play();
            
        } catch (error) {
            print('Failed to initialize video player: $error');
            setState(() {
                _hasError = true;
            });
        }
    }
    
    void _onPlayerStateChanged() {
        if (!mounted) return;
        
        setState(() {
            // Update UI based on player state
        });
        
        // Handle player completion
        if (_controller.value.position >= _controller.value.duration) {
            print('Video playback completed');
            _onVideoCompleted();
        }
    }
    
    void _onVideoCompleted() {
        // Handle video completion
        ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Video finished playing')),
        );
    }
    
    String _formatDuration(Duration duration) {
        String twoDigits(int n) => n.toString().padLeft(2, '0');
        String twoDigitMinutes = twoDigits(duration.inMinutes.remainder(60));
        String twoDigitSeconds = twoDigits(duration.inSeconds.remainder(60));
        return "$twoDigitMinutes:$twoDigitSeconds";
    }
    
    @override
    Widget build(BuildContext context) {
        return Scaffold(
            appBar: AppBar(
                title: Text(widget.title ?? 'Recorded Video'),
                backgroundColor: Colors.black,
            ),
            backgroundColor: Colors.black,
            body: _buildVideoPlayer(),
        );
    }
    
    Widget _buildVideoPlayer() {
        if (_hasError) {
            return Center(
                child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                        Icon(Icons.error, size: 64, color: Colors.red),
                        SizedBox(height: 16),
                        Text(
                            'Unable to load video',
                            style: TextStyle(color: Colors.white, fontSize: 18),
                        ),
                        SizedBox(height: 16),
                        ElevatedButton(
                            onPressed: () {
                                setState(() {
                                    _hasError = false;
                                });
                                _initializePlayer();
                            },
                            child: Text('Retry'),
                        ),
                    ],
                ),
            );
        }
        
        if (!_isInitialized) {
            return Center(
                child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                        CircularProgressIndicator(),
                        SizedBox(height: 16),
                        Text(
                            'Loading video...',
                            style: TextStyle(color: Colors.white),
                        ),
                    ],
                ),
            );
        }
        
        return Column(
            children: [
                Expanded(
                    child: AspectRatio(
                        aspectRatio: _controller.value.aspectRatio,
                        child: VideoPlayer(_controller),
                    ),
                ),
                _buildControls(),
            ],
        );
    }
    
    Widget _buildControls() {
        return Container(
            color: Colors.black87,
            padding: EdgeInsets.all(16),
            child: Column(
                children: [
                    // Progress bar
                    VideoProgressIndicator(
                        _controller,
                        allowScrubbing: true,
                        colors: VideoProgressColors(
                            playedColor: Colors.blue,
                            bufferedColor: Colors.grey,
                            backgroundColor: Colors.black,
                        ),
                    ),
                    SizedBox(height: 16),
                    
                    // Controls row
                    Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                            // Play/Pause button
                            IconButton(
                                onPressed: () {
                                    setState(() {
                                        if (_controller.value.isPlaying) {
                                            _controller.pause();
                                        } else {
                                            _controller.play();
                                        }
                                    });
                                },
                                icon: Icon(
                                    _controller.value.isPlaying ? Icons.pause : Icons.play_arrow,
                                    color: Colors.white,
                                    size: 32,
                                ),
                            ),
                            
                            // Time display
                            Text(
                                '${_formatDuration(_controller.value.position)} / ${_formatDuration(_controller.value.duration)}',
                                style: TextStyle(color: Colors.white),
                            ),
                            
                            // Fullscreen button
                            IconButton(
                                onPressed: () {
                                    // Implement fullscreen toggle
                                },
                                icon: Icon(
                                    Icons.fullscreen,
                                    color: Colors.white,
                                    size: 32,
                                ),
                            ),
                        ],
                    ),
                ],
            ),
        );
    }
    
    @override
    void dispose() {
        _controller.removeListener(_onPlayerStateChanged);
        _controller.dispose();
        super.dispose();
    }
}
```

</TabItem>
</Tabs>

## Advanced Features

### Quality Selection

Some recorded streams may be available in multiple qualities:

```javascript
// Web example for quality selection
class QualitySelector {
    constructor(player) {
        this.player = player;
        this.availableQualities = [];
    }
    
    setAvailableQualities(recordings) {
        this.availableQualities = recordings.map(recording => ({
            label: this.getQualityLabel(recording),
            url: recording.mp4Url || recording.hlsUrl,
            bitrate: recording.bitrate,
            resolution: recording.resolution
        }));
    }
    
    getQualityLabel(recording) {
        if (recording.resolution) {
            return `${recording.resolution}p`;
        }
        if (recording.bitrate) {
            return `${Math.round(recording.bitrate / 1000)}k`;
        }
        return 'Auto';
    }
    
    switchQuality(qualityIndex) {
        const currentTime = this.player.getCurrentTime();
        const quality = this.availableQualities[qualityIndex];
        
        this.player.loadVideo(quality.url);
        this.player.seekTo(currentTime);
    }
}
```

### Download & Offline Support

For mobile platforms, consider offering download functionality:

<Tabs>
<TabItem value="android" label="Android">

```kotlin
class VideoDownloadManager(private val context: Context) {
    
    fun downloadRecording(url: String, filename: String) {
        val downloadManager = context.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
        
        val request = DownloadManager.Request(Uri.parse(url))
            .setTitle("Recording Download")
            .setDescription("Downloading recorded stream")
            .setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename)
            .setAllowedNetworkTypes(DownloadManager.Request.NETWORK_WIFI or DownloadManager.Request.NETWORK_MOBILE)
            .setAllowedOverRoaming(false)
            .setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)
        
        val downloadId = downloadManager.enqueue(request)
        
        // Monitor download progress
        monitorDownload(downloadId)
    }
    
    private fun monitorDownload(downloadId: Long) {
        // Implementation for monitoring download progress
    }
}
```

</TabItem>
<TabItem value="ios" label="iOS">

```swift
class VideoDownloadManager {
    
    func downloadRecording(url: URL, filename: String) {
        let session = URLSession.shared
        
        let downloadTask = session.downloadTask(with: url) { [weak self] localURL, response, error in
            if let error = error {
                print("Download failed: \(error.localizedDescription)")
                return
            }
            
            guard let localURL = localURL else { return }
            
            self?.saveDownloadedFile(from: localURL, filename: filename)
        }
        
        downloadTask.resume()
    }
    
    private func saveDownloadedFile(from tempURL: URL, filename: String) {
        let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let destinationURL = documentsPath.appendingPathComponent(filename)
        
        do {
            try FileManager.default.moveItem(at: tempURL, to: destinationURL)
            print("File saved to: \(destinationURL)")
        } catch {
            print("Failed to save file: \(error.localizedDescription)")
        }
    }
}
```

</TabItem>
</Tabs>

## Error Handling

### Common Issues and Solutions

<CardGroup cols={2}>
<Card title="Recording Not Ready" icon="clock">
**Issue**: Stream status is ENDED but no recording available  
**Solution**: Wait for processing to complete, show progress indicator
</Card>

<Card title="Format Not Supported" icon="file-video">
**Issue**: Browser/device doesn't support video format  
**Solution**: Provide fallback formats (MP4 → HLS → WebM)
</Card>

<Card title="Network Errors" icon="wifi">
**Issue**: Slow loading or buffering issues  
**Solution**: Implement progressive loading, quality adaptation
</Card>

<Card title="Playback Errors" icon="triangle-exclamation">
**Issue**: Video fails to play  
**Solution**: Retry mechanism, alternative formats, clear error messages
</Card>
</CardGroup>

<Warning>
**Processing Time**: Recorded streams may take several minutes to process after a live stream ends. Always check the stream status before attempting playback.
</Warning>

<Tip>
**Performance**: For better user experience, preload video metadata and show thumbnails while the full video loads.
</Tip>

## Next Steps

With recorded playback implemented:

1. **[Player Controls](./player-controls.mdx)** - Add custom player UI and controls
2. **[Live Viewing](./live-viewing.mdx)** - Implement live stream viewing
3. **[Push Notifications](../notifications/push-notifications.mdx)** - Notify users when recordings are ready

For platform-specific optimizations:
- **[Android Specific](../platform-specific/android-specific.mdx)**
- **[iOS Specific](../platform-specific/ios-specific.mdx)**
- **[Web Specific](../platform-specific/web-specific.mdx)**
