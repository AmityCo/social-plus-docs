---
title: "Livestream Analytics"
description: "Track watch minutes and viewer engagement for live and recorded room playback"
---

# Livestream Analytics

The social.plus Video SDK provides comprehensive analytics capabilities for tracking viewer engagement and watch time during live and recorded room playback. This feature enables you to collect valuable insights about how users interact with your video content.

## Overview

<CardGroup cols={2}>
  <Card title="Watch Session Tracking" icon="clock">
    **Track viewer watch time**

    - Create watch sessions for viewers
    - Separate tracking for live and recorded content
  </Card>
  <Card title="Network Resilient Sync" icon="cloud-arrow-up">
    **Reliable data collection**

    - Local persistence of analytics data
    - Automatic sync with jitter delay
    - Network-aware retry logic
  </Card>
</CardGroup>

## Key Concepts

### Watch Sessions

A watch session represents a period of time during which a viewer is actively watching a room. Key characteristics:

- **Unique Session IDs**: Each session has a unique identifier with prefixes indicating content type
  - `room_` prefix for live room watching
  - `room_playback_` prefix for recorded content

## Getting Started

<Steps>
  <Step title="Access Room Analytics">
    Get the analytics instance from any `AmityRoom` object.
  </Step>
  <Step title="Create Watch Session">
    Create a session when a viewer starts watching.
  </Step>
  <Step title="Update Watch Duration">
    Update the session periodically with accumulated watch time.
  </Step>
  <Step title="Sync Sessions">
    Sync pending sessions when the viewer stops watching.
  </Step>
</Steps>

## API Reference

### AmityRoom Extension

The `AmityRoom` class is extended with an analytics capability:

<CodeGroup>

```swift iOS
extension AmityRoom {
    /// Get analytics instance for this room
    /// - Returns: AmityRoomAnalytics instance for tracking watch sessions
    func analytics() -> AmityRoomAnalytics
}
```


```kotlin Android
class AmityRoom {
    /**
     * Get analytics instance for this room
     * @return AmityRoomAnalytics instance for tracking watch sessions
     */
    fun analytics(): AmityRoomAnalytics
}
```


```typescript TypeScript
class AmityRoom {
    /**
     * Get analytics instance for this room
     * @returns AmityRoomAnalytics instance for tracking watch sessions
     */
    analytics(): AmityRoomAnalytics;
}
```

</CodeGroup>

### AmityRoomAnalytics

The main class for managing room analytics operations:

<AccordionGroup>
  <Accordion title="createWatchSession" icon="play">
    **Create a new watch session for the current room**

    Creates a unique watch session to track viewer engagement. The session ID format depends on the room status:

    - Live rooms: `room_<unique-id>`
    - Recorded rooms: `room_playback_<unique-id>`

    **Parameters:**

    | Parameter   | Type   | Required | Description                         |
    | ----------- | ------ | -------- | ----------------------------------- |
    | `startedAt` | `Date` | Yes      | The timestamp when watching started |

    **Returns:** `Promise<String>` - Unique session identifier

    **Throws:** `BusinessException` if room is not in watchable state (not LIVE or RECORDED)

    <CodeGroup>

    ```swift iOS
    import AmitySDK
    
    func startWatchSession(room: AmityRoom) async throws -> String {
        let analytics = room.analytics()
        let sessionId = try await analytics.createWatchSession(startedAt: Date())
        print("Watch session created: \(sessionId)")
        return sessionId
    }
    ```

    
    ```kotlin Android
    import com.amity.socialcloud.sdk.video.AmityRoom
    import kotlinx.coroutines.Dispatchers
    import kotlinx.coroutines.withContext
    import java.util.Date
    
    suspend fun startWatchSession(room: AmityRoom): String {
        return withContext(Dispatchers.IO) {
            val analytics = room.analytics()
            val sessionId = analytics.createWatchSession(startedAt = Date())
            println("Watch session created: $sessionId")
            sessionId
        }
    }
    ```

    
    ```typescript TypeScript
    import { AmityRoom } from '@amityco/ts-sdk';
    
    async function startWatchSession(room: AmityRoom): Promise<string> {
        const analytics = room.analytics();
        const sessionId = await analytics.createWatchSession(new Date());
        console.log('Watch session created:', sessionId);
        return sessionId;
    }
    ```

    </CodeGroup>
  </Accordion>
  <Accordion title="updateWatchSession" icon="clock-rotate-left">
    **Update an existing watch session with duration**

    Updates the watch session with the current accumulated watch time. Call this periodically (recommended: every 1 second) while the viewer is actively watching.

    **Parameters:**

    | Parameter   | Type     | Required | Description                                |
    | ----------- | -------- | -------- | ------------------------------------------ |
    | `sessionId` | `String` | Yes      | The unique identifier of the watch session |
    | `duration`  | `Number` | Yes      | The total watch duration in seconds        |
    | `endedAt`   | `Date`   | Yes      | The timestamp when this update occurred    |

    **Returns:** `Promise<void>`

    <CodeGroup>

    ```swift iOS
    import AmitySDK
    
    func updateSession(
        room: AmityRoom, 
        sessionId: String, 
        watchedSeconds: Int
    ) async throws {
        let analytics = room.analytics()
        try await analytics.updateWatchSession(
            sessionId: sessionId,
            duration: watchedSeconds,
            endedAt: Date()
        )
    }
    ```

    
    ```kotlin Android
    import com.amity.socialcloud.sdk.video.AmityRoom
    import kotlinx.coroutines.Dispatchers
    import kotlinx.coroutines.withContext
    import java.util.Date
    
    suspend fun updateSession(
        room: AmityRoom,
        sessionId: String,
        watchedSeconds: Long
    ) {
        withContext(Dispatchers.IO) {
            val analytics = room.analytics()
            analytics.updateWatchSession(
                sessionId = sessionId,
                duration = watchedSeconds,
                endedAt = Date()
            )
        }
    }
    ```

    
    ```typescript TypeScript
    import { AmityRoom } from '@amityco/ts-sdk';
    
    async function updateSession(
        room: AmityRoom,
        sessionId: string,
        watchedSeconds: number
    ): Promise<void> {
        const analytics = room.analytics();
        await analytics.updateWatchSession(
            sessionId,
            watchedSeconds,
            new Date()
        );
    }
    ```

    </CodeGroup>
  </Accordion>
  <Accordion title="syncPendingWatchSessions" icon="cloud-arrow-up">
    **Sync all pending watch sessions to backend**

    Triggers synchronization of all locally stored watch sessions that haven't been synced yet. 

    **Returns:** `void` 

    <CodeGroup>

    ```swift iOS
    import AmitySDK
    
    func syncAllSessions(room: AmityRoom) {
        let analytics = room.analytics()
        analytics.syncPendingWatchSessions()
        // Sync happens asynchronously with jitter delay
    }
    ```

    
    ```kotlin Android
    import com.amity.socialcloud.sdk.video.AmityRoom
    
    fun syncAllSessions(room: AmityRoom) {
        val analytics = room.analytics()
        analytics.syncPendingWatchSessions()
        // Sync happens asynchronously with jitter delay
    }
    ```

    
    ```typescript TypeScript
    import { AmityRoom } from '@amityco/ts-sdk';
    
    function syncAllSessions(room: AmityRoom): void {
        const analytics = room.analytics();
        analytics.syncPendingWatchSessions();
        // Sync happens asynchronously with jitter delay
    }
    ```

    </CodeGroup>

    <Warning>
      Only call `syncPendingWatchSessions()` when the user leaves the room or transitions from viewer to co-host. Do not call on every pause event.
    </Warning>
  </Accordion>
</AccordionGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="Session Creation" icon="circle-play">
    **When to create sessions:**

    - Create a session when a viewer enters the room player page
    - Only create for actual viewers (not hosts or co-hosts)
    - Only create for LIVE or RECORDED rooms
    - Prevent duplicate sessions by tracking the current room ID

    ```typescript
    // ✅ Correct: Check all conditions before creating
    if (isActualViewer && (room.status === 'live' || room.status === 'recorded')) {
        if (watchingRoomId !== room.roomId) {
            sessionId = await room.analytics().createWatchSession(new Date());
        }
    }
    
    // ❌ Incorrect: Creating without checks
    sessionId = await room.analytics().createWatchSession(new Date());
    ```
  </Accordion>
  <Accordion title="Duration Tracking" icon="stopwatch">
    **Accurate time tracking:**

    - Only count time when video is actively playing
    - Pause tracking during buffering states
    - Use accumulated time + elapsed since last resume for accurate totals

    ```typescript
    // ✅ Correct: Calculate total from accumulated + current elapsed
    const totalDuration = accumulatedWatchTimeSeconds + 
        Math.floor((Date.now() - lastResumeTime.getTime()) / 1000);
    
    // ❌ Incorrect: Using wall clock time
    const totalDuration = Math.floor((Date.now() - sessionStartTime.getTime()) / 1000);
    ```
  </Accordion>
  <Accordion title="Sync Timing" icon="cloud-arrow-up">
    **When to sync:**

    - ✅ When user leaves the room player page
    - ✅ When user transitions from viewer to co-host
    - ❌ Do NOT sync on video pause
    - ❌ Do NOT sync on app background

    ```typescript
    // ✅ Correct: Sync on page exit
    function onPageExit() {
        stopWatchTracking(shouldSync: true);
    }
    
    // ❌ Incorrect: Syncing on pause
    function onVideoPause() {
        pauseWatchTracking();
        room.analytics().syncPendingWatchSessions(); // Don't do this!
    }
    ```
  </Accordion>
  <Accordion title="Role Transitions" icon="arrow-right-arrow-left">
    **Handle viewer ↔ co-host transitions:**

    - When becoming a co-host: Stop tracking and sync immediately
    - When returning to viewer: Create a fresh new session
    - Never reuse session IDs across role transitions

    ```typescript
    // Viewer → Co-host
    function onBecomeCoHost() {
        stopWatchTracking(shouldSync: true);
    }
    
    // Co-host → Viewer
    function onReturnToViewer() {
        // Creates a completely new session
        startWatchTracking(isStreamerMode, cohostUserId, currentUserId);
    }
    ```
  </Accordion>
</AccordionGroup>

## Error Handling

### Common Errors

| Error                                               | Cause                                                              | Solution                                  |
| --------------------------------------------------- | ------------------------------------------------------------------ | ----------------------------------------- |
| `BusinessException: room is not in watchable state` | Attempting to create session for room that is not LIVE or RECORDED | Check room status before creating session |

## Related Topics

<CardGroup cols={3}>
  <Card title="Live Room Viewing" icon="play" href="/social-plus-sdk/video-new/broadcasting/live-viewing">
    Learn how to implement live room playback
  </Card>
  <Card title="Recorded Playback" icon="video" href="/social-plus-sdk/video-new/broadcasting/recorded-playback">
    Implement recorded stream playback
  </Card>
  <Card title="Co-Host Management" icon="users" href="/social-plus-sdk/video-new/broadcasting/co-host-management">
    Handle co-host transitions that affect analytics
  </Card>
</CardGroup>