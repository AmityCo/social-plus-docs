---
title: "Users"
description: "User profiles, relationships, and social interactions including follow system and user management"
---

# Users

Social+ UIKit user components provide comprehensive user profile management, social relationships, and interaction features. These components handle user profiles, follow systems, blocked users, and relationship management.

## Overview

User components are fundamental to social applications, enabling users to create profiles, connect with others, and manage their social relationships. The system supports both public and private user accounts with granular privacy controls.

<img src="/images/uikit/users-overview.png" alt="Users Overview" />

## User Profiles

### User Profile Page

Display comprehensive user information with posts and social stats.

<CodeGroup>
```swift iOS
import AmitySocialCloudUIKit

// User profile view controller
class UserProfileViewController: UIViewController {
    private let userId: String
    private var user: AmityUser?
    private let profileHeaderView = UserProfileHeaderView()
    private let statsView = UserStatsView()
    private let feedViewController: AmityUserFeedViewController
    
    init(userId: String) {
        self.userId = userId
        self.feedViewController = AmityUserFeedViewController(userId: userId)
        super.init(nibName: nil, bundle: nil)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        loadUserData()
        setupFollowButton()
    }
    
    private func setupUI() {
        view.backgroundColor = .systemBackground
        
        // Add header view
        view.addSubview(profileHeaderView)
        view.addSubview(statsView)
        
        // Add feed view controller
        addChild(feedViewController)
        view.addSubview(feedViewController.view)
        feedViewController.didMove(toParent: self)
        
        setupConstraints()
    }
    
    private func loadUserData() {
        AmityUserRepository().getUser(userId) { [weak self] result in
            DispatchQueue.main.async {
                switch result {
                case .success(let user):
                    self?.user = user
                    self?.updateUI(with: user)
                case .failure(let error):
                    self?.showError("Failed to load user: \(error.localizedDescription)")
                }
            }
        }
    }
    
    private func updateUI(with user: AmityUser) {
        // Update header
        profileHeaderView.configure(
            avatar: user.avatar?.fileUrl,
            displayName: user.displayName ?? "Unknown User",
            username: user.userId,
            bio: user.description,
            isPrivateAccount: user.isPrivate
        )
        
        // Update stats
        statsView.configure(
            postsCount: user.postsCount,
            followersCount: user.followersCount,
            followingCount: user.followingCount
        )
        
        // Update navigation
        title = user.displayName
        updateFollowButton()
    }
    
    private func setupFollowButton() {
        guard userId != AmityManager.shared.currentUserId else { return }
        
        let followButton = UIBarButtonItem(
            title: "Follow",
            style: .plain,
            target: self,
            action: #selector(followButtonTapped)
        )
        navigationItem.rightBarButtonItem = followButton
    }
    
    private func updateFollowButton() {
        guard let user = user,
              let followButton = navigationItem.rightBarButtonItem else { return }
        
        switch user.followStatus {
        case .following:
            followButton.title = "Unfollow"
            followButton.tintColor = .systemRed
        case .pending:
            followButton.title = "Pending"
            followButton.isEnabled = false
            followButton.tintColor = .systemGray
        case .none:
            followButton.title = "Follow"
            followButton.tintColor = .systemBlue
            followButton.isEnabled = true
        }
    }
    
    @objc private func followButtonTapped() {
        guard let user = user else { return }
        
        let userRepository = AmityUserRepository()
        
        switch user.followStatus {
        case .following:
            userRepository.unfollowUser(userId) { [weak self] result in
                DispatchQueue.main.async {
                    self?.handleFollowResult(result)
                }
            }
        case .none:
            userRepository.followUser(userId) { [weak self] result in
                DispatchQueue.main.async {
                    self?.handleFollowResult(result)
                }
            }
        case .pending:
            // Cancel follow request
            userRepository.cancelFollowRequest(userId) { [weak self] result in
                DispatchQueue.main.async {
                    self?.handleFollowResult(result)
                }
            }
        }
    }
}
```

```kotlin Android
import com.amity.socialcloud.uikit.social.user.UserProfileActivity

class UserProfileActivity : AppCompatActivity() {
    private lateinit var binding: ActivityUserProfileBinding
    private lateinit var userRepository: AmityUserRepository
    private var userId: String = ""
    private var user: AmityUser? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityUserProfileBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        userId = intent.getStringExtra(EXTRA_USER_ID) ?: ""
        userRepository = AmityUserRepository()
        
        setupUI()
        loadUserData()
    }
    
    private fun setupUI() {
        // Setup toolbar
        setSupportActionBar(binding.toolbar)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        
        // Setup tabs
        setupTabs()
        
        // Setup follow button if not current user
        if (userId != getCurrentUserId()) {
            setupFollowButton()
        }
    }
    
    private fun loadUserData() {
        userRepository.getUser(userId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                { user ->
                    this.user = user
                    updateUI(user)
                },
                { error ->
                    showError("Failed to load user: ${error.message}")
                }
            )
    }
    
    private fun updateUI(user: AmityUser) {
        binding.apply {
            // Load avatar
            Glide.with(this@UserProfileActivity)
                .load(user.avatar?.fileUrl)
                .placeholder(R.drawable.default_avatar)
                .circleCrop()
                .into(userAvatar)
            
            // Set user info
            userName.text = user.displayName ?: "Unknown User"
            userUsername.text = "@${user.userId}"
            userBio.text = user.description
            
            // Set privacy indicator
            if (user.isPrivate) {
                privacyIndicator.visibility = View.VISIBLE
                privacyIndicator.setImageResource(R.drawable.ic_lock)
            } else {
                privacyIndicator.visibility = View.GONE
            }
            
            // Update stats
            postsCount.text = user.postsCount.toString()
            followersCount.text = user.followersCount.toString()
            followingCount.text = user.followingCount.toString()
            
            // Setup click listeners for stats
            followersContainer.setOnClickListener { showFollowers() }
            followingContainer.setOnClickListener { showFollowing() }
        }
        
        updateFollowButton()
        title = user.displayName
    }
    
    private fun setupFollowButton() {
        binding.followButton.apply {
            visibility = View.VISIBLE
            setOnClickListener { handleFollowButtonClick() }
        }
    }
    
    private fun updateFollowButton() {
        val user = this.user ?: return
        
        binding.followButton.apply {
            when (user.followStatus) {
                AmityFollowStatus.FOLLOWING -> {
                    text = "Unfollow"
                    setBackgroundColor(ContextCompat.getColor(context, R.color.red))
                }
                AmityFollowStatus.PENDING -> {
                    text = "Pending"
                    setBackgroundColor(ContextCompat.getColor(context, R.color.gray))
                    isEnabled = false
                }
                AmityFollowStatus.NONE -> {
                    text = if (user.isPrivate) "Request to Follow" else "Follow"
                    setBackgroundColor(ContextCompat.getColor(context, R.color.blue))
                    isEnabled = true
                }
            }
        }
    }
    
    private fun handleFollowButtonClick() {
        val user = this.user ?: return
        
        when (user.followStatus) {
            AmityFollowStatus.FOLLOWING -> unfollowUser()
            AmityFollowStatus.NONE -> followUser()
            AmityFollowStatus.PENDING -> cancelFollowRequest()
        }
    }
    
    private fun followUser() {
        userRepository.followUser(userId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                { 
                    showToast("Follow request sent")
                    loadUserData() // Refresh to get updated status
                },
                { error -> showError("Failed to follow user: ${error.message}") }
            )
    }
    
    private fun setupTabs() {
        val adapter = UserProfileTabAdapter(this, userId)
        binding.viewPager.adapter = adapter
        TabLayoutMediator(binding.tabLayout, binding.viewPager) { tab, position ->
            tab.text = when (position) {
                0 -> "Posts"
                1 -> "Media"
                2 -> "About"
                else -> ""
            }
        }.attach()
    }
}
```

```javascript Web
import { AmityUserProfile } from '@amityco/ui-kit';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [activeTab, setActiveTab] = useState('posts');
  const [followLoading, setFollowLoading] = useState(false);

  useEffect(() => {
    loadUser();
  }, [userId]);

  const loadUser = async () => {
    try {
      const userData = await getUser(userId);
      setUser(userData);
    } catch (error) {
      console.error('Failed to load user:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleFollowToggle = async () => {
    if (!user) return;
    
    setFollowLoading(true);
    try {
      switch (user.followStatus) {
        case 'following':
          await unfollowUser(userId);
          setUser(prev => ({ 
            ...prev, 
            followStatus: 'none',
            followersCount: prev.followersCount - 1
          }));
          break;
        case 'none':
          await followUser(userId);
          const newStatus = user.isPrivate ? 'pending' : 'following';
          const followerDelta = user.isPrivate ? 0 : 1;
          setUser(prev => ({ 
            ...prev, 
            followStatus: newStatus,
            followersCount: prev.followersCount + followerDelta
          }));
          break;
        case 'pending':
          await cancelFollowRequest(userId);
          setUser(prev => ({ ...prev, followStatus: 'none' }));
          break;
      }
    } catch (error) {
      console.error('Failed to toggle follow:', error);
    } finally {
      setFollowLoading(false);
    }
  };

  const handleStatsClick = (type) => {
    switch (type) {
      case 'followers':
        // Navigate to followers list
        break;
      case 'following':
        // Navigate to following list
        break;
      case 'posts':
        setActiveTab('posts');
        break;
    }
  };

  if (loading) return <UserProfileSkeleton />;
  if (!user) return <div>User not found</div>;

  return (
    <div className="user-profile">
      {/* Profile Header */}
      <div className="profile-header">
        <div className="cover-image">
          <img src={user.coverImage} alt="" className="cover" />
        </div>
        
        <div className="profile-info">
          <div className="avatar-container">
            <Avatar src={user.avatar} size="large" />
            {user.isPrivate && (
              <div className="privacy-badge">
                <LockIcon size="small" />
              </div>
            )}
          </div>
          
          <div className="user-details">
            <h1 className="display-name">{user.displayName}</h1>
            <p className="username">@{user.username}</p>
            {user.bio && <p className="bio">{user.bio}</p>}
            
            <div className="user-meta">
              <span className="join-date">
                Joined {formatDate(user.createdAt)}
              </span>
              {user.location && (
                <span className="location">
                  <LocationIcon size="small" />
                  {user.location}
                </span>
              )}
            </div>
          </div>
          
          {userId !== getCurrentUserId() && (
            <FollowButton
              user={user}
              loading={followLoading}
              onToggle={handleFollowToggle}
            />
          )}
        </div>
      </div>

      {/* Profile Stats */}
      <div className="profile-stats">
        <button
          className="stat"
          onClick={() => handleStatsClick('posts')}
        >
          <strong>{user.postsCount.toLocaleString()}</strong>
          <span>Posts</span>
        </button>
        
        <button
          className="stat"
          onClick={() => handleStatsClick('followers')}
        >
          <strong>{user.followersCount.toLocaleString()}</strong>
          <span>Followers</span>
        </button>
        
        <button
          className="stat"
          onClick={() => handleStatsClick('following')}
        >
          <strong>{user.followingCount.toLocaleString()}</strong>
          <span>Following</span>
        </button>
      </div>

      {/* Profile Tabs */}
      <div className="profile-tabs">
        <nav className="tab-nav">
          {['posts', 'media', 'about'].map(tab => (
            <button
              key={tab}
              className={`tab ${activeTab === tab ? 'active' : ''}`}
              onClick={() => setActiveTab(tab)}
            >
              {tab.charAt(0).toUpperCase() + tab.slice(1)}
            </button>
          ))}
        </nav>
        
        <div className="tab-content">
          {activeTab === 'posts' && <UserFeed userId={userId} />}
          {activeTab === 'media' && <UserMedia userId={userId} />}
          {activeTab === 'about' && <UserAbout user={user} />}
        </div>
      </div>
    </div>
  );
}

function FollowButton({ user, loading, onToggle }) {
  const getButtonText = () => {
    if (loading) return 'Loading...';
    
    switch (user.followStatus) {
      case 'following':
        return 'Unfollow';
      case 'pending':
        return 'Pending';
      case 'none':
        return user.isPrivate ? 'Request to Follow' : 'Follow';
      default:
        return 'Follow';
    }
  };

  const getButtonClass = () => {
    switch (user.followStatus) {
      case 'following':
        return 'unfollow-button';
      case 'pending':
        return 'pending-button';
      default:
        return 'follow-button';
    }
  };

  return (
    <button
      className={`user-action-button ${getButtonClass()}`}
      onClick={onToggle}
      disabled={loading || user.followStatus === 'pending'}
    >
      {getButtonText()}
    </button>
  );
}
```

```dart Flutter
import 'package:amity_uikit_beta_service/amity_uikit_beta_service.dart';

class UserProfilePage extends StatefulWidget {
  final String userId;

  const UserProfilePage({Key? key, required this.userId}) : super(key: key);

  @override
  _UserProfilePageState createState() => _UserProfilePageState();
}

class _UserProfilePageState extends State<UserProfilePage>
    with SingleTickerProviderStateMixin {
  AmityUser? user;
  bool loading = true;
  bool followLoading = false;
  late TabController tabController;

  @override
  void initState() {
    super.initState();
    tabController = TabController(length: 3, vsync: this);
    loadUser();
  }

  Future<void> loadUser() async {
    try {
      final userData = await AmityUserRepository.getUser(widget.userId);
      setState(() {
        user = userData;
        loading = false;
      });
    } catch (error) {
      setState(() => loading = false);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to load user: $error')),
      );
    }
  }

  Future<void> handleFollowToggle() async {
    if (user == null) return;
    
    setState(() => followLoading = true);
    
    try {
      switch (user!.followStatus) {
        case AmityFollowStatus.following:
          await AmityUserRepository.unfollowUser(widget.userId);
          setState(() {
            user = user!.copyWith(
              followStatus: AmityFollowStatus.none,
              followersCount: user!.followersCount - 1,
            );
          });
          break;
        case AmityFollowStatus.none:
          await AmityUserRepository.followUser(widget.userId);
          final newStatus = user!.isPrivate 
              ? AmityFollowStatus.pending 
              : AmityFollowStatus.following;
          final followerDelta = user!.isPrivate ? 0 : 1;
          setState(() {
            user = user!.copyWith(
              followStatus: newStatus,
              followersCount: user!.followersCount + followerDelta,
            );
          });
          break;
        case AmityFollowStatus.pending:
          await AmityUserRepository.cancelFollowRequest(widget.userId);
          setState(() {
            user = user!.copyWith(followStatus: AmityFollowStatus.none);
          });
          break;
      }
    } catch (error) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to toggle follow: $error')),
      );
    } finally {
      setState(() => followLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    if (loading) {
      return Scaffold(
        appBar: AppBar(),
        body: Center(child: CircularProgressIndicator()),
      );
    }

    if (user == null) {
      return Scaffold(
        appBar: AppBar(),
        body: Center(child: Text('User not found')),
      );
    }

    return Scaffold(
      body: NestedScrollView(
        headerSliverBuilder: (context, innerBoxIsScrolled) => [
          SliverAppBar(
            expandedHeight: 300,
            pinned: true,
            flexibleSpace: FlexibleSpaceBar(
              background: UserProfileHeader(
                user: user!,
                onFollowToggle: widget.userId != getCurrentUserId() 
                    ? handleFollowToggle 
                    : null,
                followLoading: followLoading,
              ),
            ),
          ),
        ],
        body: Column(
          children: [
            UserStats(
              user: user!,
              onStatsClick: (type) {
                // Handle stats click
                switch (type) {
                  case 'followers':
                    Navigator.push(context, MaterialPageRoute(
                      builder: (context) => FollowersPage(userId: widget.userId),
                    ));
                    break;
                  case 'following':
                    Navigator.push(context, MaterialPageRoute(
                      builder: (context) => FollowingPage(userId: widget.userId),
                    ));
                    break;
                }
              },
            ),
            
            TabBar(
              controller: tabController,
              tabs: [
                Tab(text: 'Posts'),
                Tab(text: 'Media'),
                Tab(text: 'About'),
              ],
            ),
            
            Expanded(
              child: TabBarView(
                controller: tabController,
                children: [
                  UserFeedTab(userId: widget.userId),
                  UserMediaTab(userId: widget.userId),
                  UserAboutTab(user: user!),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    tabController.dispose();
    super.dispose();
  }
}

class UserProfileHeader extends StatelessWidget {
  final AmityUser user;
  final VoidCallback? onFollowToggle;
  final bool followLoading;

  const UserProfileHeader({
    Key? key,
    required this.user,
    this.onFollowToggle,
    this.followLoading = false,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.all(16),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          Row(
            children: [
              Stack(
                children: [
                  CircleAvatar(
                    radius: 40,
                    backgroundImage: user.avatar != null 
                        ? NetworkImage(user.avatar!) 
                        : null,
                    child: user.avatar == null 
                        ? Icon(Icons.person, size: 40)
                        : null,
                  ),
                  if (user.isPrivate)
                    Positioned(
                      bottom: 0,
                      right: 0,
                      child: Container(
                        padding: EdgeInsets.all(4),
                        decoration: BoxDecoration(
                          color: Colors.white,
                          shape: BoxShape.circle,
                        ),
                        child: Icon(Icons.lock, size: 16),
                      ),
                    ),
                ],
              ),
              
              SizedBox(width: 16),
              
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      user.displayName ?? 'Unknown User',
                      style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                    Text(
                      '@${user.userId}',
                      style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Colors.white70,
                      ),
                    ),
                    if (user.description?.isNotEmpty == true)
                      Padding(
                        padding: EdgeInsets.only(top: 8),
                        child: Text(
                          user.description!,
                          style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                            color: Colors.white,
                          ),
                        ),
                      ),
                  ],
                ),
              ),
              
              if (onFollowToggle != null)
                UserFollowButton(
                  user: user,
                  loading: followLoading,
                  onToggle: onFollowToggle!,
                ),
            ],
          ),
        ],
      ),
    );
  }
}
```
</CodeGroup>

### Edit User Profile

Allow users to edit their own profile information.

<CodeGroup>
```swift iOS
class EditProfileViewController: UIViewController {
    private let currentUser: AmityUser
    private let scrollView = UIScrollView()
    private let contentView = UIView()
    
    // Form fields
    private let avatarImageView = UIImageView()
    private let changeAvatarButton = UIButton()
    private let displayNameTextField = UITextField()
    private let bioTextView = UITextView()
    private let privateAccountSwitch = UISwitch()
    
    init(user: AmityUser) {
        self.currentUser = user
        super.init(nibName: nil, bundle: nil)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        populateFields()
        setupValidation()
    }
    
    private func setupUI() {
        title = "Edit Profile"
        view.backgroundColor = .systemBackground
        
        // Navigation buttons
        navigationItem.leftBarButtonItem = UIBarButtonItem(
            barButtonSystemItem: .cancel,
            target: self,
            action: #selector(cancelTapped)
        )
        
        navigationItem.rightBarButtonItem = UIBarButtonItem(
            barButtonSystemItem: .save,
            target: self,
            action: #selector(saveTapped)
        )
        
        // Setup scroll view
        view.addSubview(scrollView)
        scrollView.addSubview(contentView)
        
        // Avatar section
        avatarImageView.contentMode = .scaleAspectFill
        avatarImageView.clipsToBounds = true
        avatarImageView.layer.cornerRadius = 50
        avatarImageView.backgroundColor = .systemGray5
        
        changeAvatarButton.setTitle("Change Photo", for: .normal)
        changeAvatarButton.addTarget(self, action: #selector(changeAvatarTapped), for: .touchUpInside)
        
        // Form fields
        displayNameTextField.borderStyle = .roundedRect
        displayNameTextField.placeholder = "Display Name"
        
        bioTextView.layer.borderColor = UIColor.systemGray4.cgColor
        bioTextView.layer.borderWidth = 1
        bioTextView.layer.cornerRadius = 8
        bioTextView.font = UIFont.systemFont(ofSize: 16)
        
        // Privacy toggle
        let privateLabel = UILabel()
        privateLabel.text = "Private Account"
        
        let privateStackView = UIStackView(arrangedSubviews: [privateLabel, privateAccountSwitch])
        privateStackView.axis = .horizontal
        privateStackView.distribution = .equalSpacing
        
        // Layout
        let stackView = UIStackView(arrangedSubviews: [
            avatarImageView,
            changeAvatarButton,
            createFormRow(label: "Display Name", field: displayNameTextField),
            createFormRow(label: "Bio", field: bioTextView),
            privateStackView
        ])
        
        stackView.axis = .vertical
        stackView.spacing = 16
        stackView.alignment = .fill
        
        contentView.addSubview(stackView)
        setupConstraints(stackView)
    }
    
    private func populateFields() {
        // Load current avatar
        if let avatarUrl = currentUser.avatar?.fileUrl {
            loadImage(from: avatarUrl) { [weak self] image in
                DispatchQueue.main.async {
                    self?.avatarImageView.image = image
                }
            }
        }
        
        displayNameTextField.text = currentUser.displayName
        bioTextView.text = currentUser.description
        privateAccountSwitch.isOn = currentUser.isPrivate
    }
    
    @objc private func changeAvatarTapped() {
        let imagePicker = UIImagePickerController()
        imagePicker.delegate = self
        imagePicker.sourceType = .photoLibrary
        imagePicker.allowsEditing = true
        present(imagePicker, animated: true)
    }
    
    @objc private func saveTapped() {
        saveProfile()
    }
    
    private func saveProfile() {
        let updatedProfile = AmityUserUpdateProfile(
            displayName: displayNameTextField.text,
            description: bioTextView.text,
            isPrivate: privateAccountSwitch.isOn
        )
        
        AmityUserRepository().updateUserProfile(updatedProfile) { [weak self] result in
            DispatchQueue.main.async {
                switch result {
                case .success:
                    self?.navigationController?.popViewController(animated: true)
                case .failure(let error):
                    self?.showError("Failed to update profile: \(error.localizedDescription)")
                }
            }
        }
    }
}

// MARK: - UIImagePickerControllerDelegate
extension EditProfileViewController: UIImagePickerControllerDelegate, UINavigationControllerDelegate {
    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
        if let editedImage = info[.editedImage] as? UIImage {
            avatarImageView.image = editedImage
            uploadNewAvatar(editedImage)
        }
        picker.dismiss(animated: true)
    }
    
    private func uploadNewAvatar(_ image: UIImage) {
        guard let imageData = image.jpegData(compressionQuality: 0.8) else { return }
        
        AmityFileRepository().uploadImage(imageData) { [weak self] result in
            switch result {
            case .success(let fileInfo):
                self?.updateUserAvatar(fileInfo.fileId)
            case .failure(let error):
                DispatchQueue.main.async {
                    self?.showError("Failed to upload avatar: \(error.localizedDescription)")
                }
            }
        }
    }
}
```

```kotlin Android
class EditProfileActivity : AppCompatActivity() {
    private lateinit var binding: ActivityEditProfileBinding
    private lateinit var userRepository: AmityUserRepository
    private var currentUser: AmityUser? = null
    private var selectedImageUri: Uri? = null
    
    private val imagePickerLauncher = registerForActivityResult(
        ActivityResultContracts.GetContent()
    ) { uri ->
        uri?.let { handleImageSelected(it) }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityEditProfileBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        userRepository = AmityUserRepository()
        
        setupUI()
        loadCurrentUser()
    }
    
    private fun setupUI() {
        setSupportActionBar(binding.toolbar)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        supportActionBar?.title = "Edit Profile"
        
        binding.changeAvatarButton.setOnClickListener {
            imagePickerLauncher.launch("image/*")
        }
        
        binding.saveButton.setOnClickListener {
            saveProfile()
        }
        
        binding.cancelButton.setOnClickListener {
            finish()
        }
        
        // Setup bio character counter
        binding.bioEditText.addTextChangedListener(object : TextWatcher {
            override fun afterTextChanged(s: Editable?) {
                val count = s?.length ?: 0
                binding.bioCharacterCount.text = "$count/150"
                binding.bioCharacterCount.setTextColor(
                    if (count > 150) Color.RED else Color.GRAY
                )
            }
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}
        })
    }
    
    private fun loadCurrentUser() {
        userRepository.getCurrentUser()
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                { user ->
                    currentUser = user
                    populateFields(user)
                },
                { error ->
                    showError("Failed to load user data: ${error.message}")
                }
            )
    }
    
    private fun populateFields(user: AmityUser) {
        binding.apply {
            // Load avatar
            Glide.with(this@EditProfileActivity)
                .load(user.avatar?.fileUrl)
                .placeholder(R.drawable.default_avatar)
                .circleCrop()
                .into(avatarImageView)
            
            displayNameEditText.setText(user.displayName)
            bioEditText.setText(user.description)
            privateAccountSwitch.isChecked = user.isPrivate
            
            // Update character count
            val bioLength = user.description?.length ?: 0
            bioCharacterCount.text = "$bioLength/150"
        }
    }
    
    private fun handleImageSelected(uri: Uri) {
        selectedImageUri = uri
        
        // Display selected image
        Glide.with(this)
            .load(uri)
            .circleCrop()
            .into(binding.avatarImageView)
    }
    
    private fun saveProfile() {
        val displayName = binding.displayNameEditText.text.toString().trim()
        val bio = binding.bioEditText.text.toString().trim()
        val isPrivate = binding.privateAccountSwitch.isChecked
        
        // Validate inputs
        if (displayName.isEmpty()) {
            binding.displayNameEditText.error = "Display name is required"
            return
        }
        
        if (bio.length > 150) {
            binding.bioEditText.error = "Bio must be 150 characters or less"
            return
        }
        
        binding.saveButton.isEnabled = false
        binding.progressBar.visibility = View.VISIBLE
        
        // Upload new avatar if selected
        if (selectedImageUri != null) {
            uploadAvatarAndSaveProfile(displayName, bio, isPrivate)
        } else {
            updateProfile(displayName, bio, isPrivate, null)
        }
    }
    
    private fun uploadAvatarAndSaveProfile(displayName: String, bio: String, isPrivate: Boolean) {
        val imageFile = createImageFile(selectedImageUri!!)
        
        AmityFileRepository().uploadImage(imageFile)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                { fileInfo ->
                    updateProfile(displayName, bio, isPrivate, fileInfo.fileId)
                },
                { error ->
                    binding.saveButton.isEnabled = true
                    binding.progressBar.visibility = View.GONE
                    showError("Failed to upload avatar: ${error.message}")
                }
            )
    }
    
    private fun updateProfile(displayName: String, bio: String, isPrivate: Boolean, avatarFileId: String?) {
        val updateRequest = AmityUserUpdateRequest.Builder()
            .displayName(displayName)
            .description(bio)
            .isPrivate(isPrivate)
            .apply { avatarFileId?.let { avatarId(it) } }
            .build()
        
        userRepository.updateUserProfile(updateRequest)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                {
                    showToast("Profile updated successfully")
                    setResult(RESULT_OK)
                    finish()
                },
                { error ->
                    binding.saveButton.isEnabled = true
                    binding.progressBar.visibility = View.GONE
                    showError("Failed to update profile: ${error.message}")
                }
            )
    }
}
```

```javascript Web
function EditProfile({ user, onSave, onCancel }) {
  const [formData, setFormData] = useState({
    displayName: user.displayName || '',
    bio: user.bio || '',
    isPrivate: user.isPrivate || false,
    avatar: null
  });
  const [avatarPreview, setAvatarPreview] = useState(user.avatar);
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState({});

  const handleInputChange = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    
    // Clear error when user starts typing
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: null }));
    }
  };

  const handleAvatarChange = (event) => {
    const file = event.target.files[0];
    if (file) {
      if (file.size > 5 * 1024 * 1024) { // 5MB limit
        setErrors(prev => ({ ...prev, avatar: 'Avatar image must be less than 5MB' }));
        return;
      }
      
      setFormData(prev => ({ ...prev, avatar: file }));
      setAvatarPreview(URL.createObjectURL(file));
      setErrors(prev => ({ ...prev, avatar: null }));
    }
  };

  const validateForm = () => {
    const newErrors = {};
    
    if (!formData.displayName.trim()) {
      newErrors.displayName = 'Display name is required';
    } else if (formData.displayName.length > 50) {
      newErrors.displayName = 'Display name must be 50 characters or less';
    }
    
    if (formData.bio.length > 150) {
      newErrors.bio = 'Bio must be 150 characters or less';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (event) => {
    event.preventDefault();
    
    if (!validateForm()) return;
    
    setLoading(true);
    
    try {
      let avatarUrl = user.avatar;
      
      // Upload new avatar if selected
      if (formData.avatar) {
        const formDataForUpload = new FormData();
        formDataForUpload.append('image', formData.avatar);
        
        const uploadResponse = await fetch('/api/upload/avatar', {
          method: 'POST',
          body: formDataForUpload
        });
        
        if (!uploadResponse.ok) {
          throw new Error('Failed to upload avatar');
        }
        
        const uploadResult = await uploadResponse.json();
        avatarUrl = uploadResult.url;
      }
      
      // Update user profile
      const updatedUser = await updateUserProfile({
        displayName: formData.displayName.trim(),
        bio: formData.bio.trim(),
        isPrivate: formData.isPrivate,
        avatar: avatarUrl
      });
      
      onSave(updatedUser);
    } catch (error) {
      console.error('Failed to update profile:', error);
      setErrors({ submit: error.message || 'Failed to update profile' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="edit-profile-modal">
      <div className="modal-content">
        <div className="modal-header">
          <h2>Edit Profile</h2>
          <button className="close-button" onClick={onCancel}>Ã—</button>
        </div>
        
        <form onSubmit={handleSubmit} className="edit-profile-form">
          {/* Avatar Section */}
          <div className="avatar-section">
            <div className="avatar-preview">
              <img 
                src={avatarPreview} 
                alt="Profile avatar" 
                className="avatar-image"
              />
              <button
                type="button"
                className="change-avatar-button"
                onClick={() => document.getElementById('avatar-input').click()}
              >
                Change Photo
              </button>
            </div>
            
            <input
              id="avatar-input"
              type="file"
              accept="image/*"
              onChange={handleAvatarChange}
              style={{ display: 'none' }}
            />
            
            {errors.avatar && (
              <span className="error-message">{errors.avatar}</span>
            )}
          </div>

          {/* Display Name */}
          <div className="form-group">
            <label htmlFor="displayName">Display Name *</label>
            <input
              id="displayName"
              type="text"
              value={formData.displayName}
              onChange={(e) => handleInputChange('displayName', e.target.value)}
              maxLength={50}
              className={errors.displayName ? 'error' : ''}
            />
            {errors.displayName && (
              <span className="error-message">{errors.displayName}</span>
            )}
            <span className="character-count">
              {formData.displayName.length}/50
            </span>
          </div>

          {/* Bio */}
          <div className="form-group">
            <label htmlFor="bio">Bio</label>
            <textarea
              id="bio"
              value={formData.bio}
              onChange={(e) => handleInputChange('bio', e.target.value)}
              maxLength={150}
              rows={3}
              placeholder="Tell people about yourself..."
              className={errors.bio ? 'error' : ''}
            />
            {errors.bio && (
              <span className="error-message">{errors.bio}</span>
            )}
            <span className="character-count">
              {formData.bio.length}/150
            </span>
          </div>

          {/* Privacy Setting */}
          <div className="form-group">
            <label className="toggle-setting">
              <div className="setting-info">
                <strong>Private Account</strong>
                <p>Only approved followers can see your posts</p>
              </div>
              <input
                type="checkbox"
                checked={formData.isPrivate}
                onChange={(e) => handleInputChange('isPrivate', e.target.checked)}
              />
            </label>
          </div>

          {/* Error Message */}
          {errors.submit && (
            <div className="error-message submit-error">
              {errors.submit}
            </div>
          )}

          {/* Action Buttons */}
          <div className="form-actions">
            <button
              type="button"
              onClick={onCancel}
              disabled={loading}
              className="cancel-button"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={loading}
              className="save-button"
            >
              {loading ? 'Saving...' : 'Save Changes'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
```
</CodeGroup>

## Follow System

### Followers/Following Lists

Display and manage user relationships.

<CodeGroup>
```swift iOS
class FollowListViewController: UIViewController {
    enum ListType {
        case followers
        case following
    }
    
    private let userId: String
    private let listType: ListType
    private var users: [AmityUser] = []
    private let tableView = UITableView()
    private let searchController = UISearchController()
    
    init(userId: String, listType: ListType) {
        self.userId = userId
        self.listType = listType
        super.init(nibName: nil, bundle: nil)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        loadUsers()
    }
    
    private func setupUI() {
        title = listType == .followers ? "Followers" : "Following"
        
        // Setup search
        searchController.searchResultsUpdater = self
        searchController.obscuresBackgroundDuringPresentation = false
        searchController.searchBar.placeholder = "Search users"
        navigationItem.searchController = searchController
        
        // Setup table view
        tableView.delegate = self
        tableView.dataSource = self
        tableView.register(UserTableViewCell.self, forCellReuseIdentifier: "UserCell")
        
        view.addSubview(tableView)
        tableView.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            tableView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            tableView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            tableView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            tableView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])
    }
    
    private func loadUsers() {
        let userRepository = AmityUserRepository()
        
        let loadMethod = listType == .followers 
            ? userRepository.getFollowers 
            : userRepository.getFollowing
        
        loadMethod(userId) { [weak self] result in
            DispatchQueue.main.async {
                switch result {
                case .success(let userList):
                    self?.users = userList
                    self?.tableView.reloadData()
                case .failure(let error):
                    self?.showError("Failed to load users: \(error.localizedDescription)")
                }
            }
        }
    }
}

// MARK: - TableView DataSource & Delegate
extension FollowListViewController: UITableViewDataSource, UITableViewDelegate {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return users.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "UserCell", for: indexPath) as! UserTableViewCell
        let user = users[indexPath.row]
        
        cell.configure(
            avatar: user.avatar?.fileUrl,
            displayName: user.displayName ?? "Unknown User",
            username: user.userId,
            followStatus: user.followStatus,
            onFollowTapped: { [weak self] in
                self?.toggleFollow(for: user, at: indexPath)
            }
        )
        
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
        let user = users[indexPath.row]
        
        let userProfileViewController = UserProfileViewController(userId: user.userId)
        navigationController?.pushViewController(userProfileViewController, animated: true)
    }
    
    private func toggleFollow(for user: AmityUser, at indexPath: IndexPath) {
        let userRepository = AmityUserRepository()
        
        switch user.followStatus {
        case .following:
            userRepository.unfollowUser(user.userId) { [weak self] result in
                self?.handleFollowResult(result, for: user, at: indexPath)
            }
        case .none:
            userRepository.followUser(user.userId) { [weak self] result in
                self?.handleFollowResult(result, for: user, at: indexPath)
            }
        case .pending:
            userRepository.cancelFollowRequest(user.userId) { [weak self] result in
                self?.handleFollowResult(result, for: user, at: indexPath)
            }
        }
    }
}
```

```javascript Web
function FollowList({ userId, type, onUserClick }) {
  const [users, setUsers] = useState([]);
  const [filteredUsers, setFilteredUsers] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadUsers();
  }, [userId, type]);

  useEffect(() => {
    filterUsers();
  }, [users, searchQuery]);

  const loadUsers = async () => {
    try {
      const userList = type === 'followers' 
        ? await getFollowers(userId)
        : await getFollowing(userId);
      setUsers(userList);
    } catch (error) {
      console.error(`Failed to load ${type}:`, error);
    } finally {
      setLoading(false);
    }
  };

  const filterUsers = () => {
    if (!searchQuery) {
      setFilteredUsers(users);
    } else {
      setFilteredUsers(
        users.filter(user =>
          user.displayName.toLowerCase().includes(searchQuery.toLowerCase()) ||
          user.username.toLowerCase().includes(searchQuery.toLowerCase())
        )
      );
    }
  };

  const handleFollowToggle = async (targetUserId, currentStatus) => {
    try {
      let newStatus;
      switch (currentStatus) {
        case 'following':
          await unfollowUser(targetUserId);
          newStatus = 'none';
          break;
        case 'none':
          await followUser(targetUserId);
          newStatus = 'following'; // or 'pending' for private accounts
          break;
        case 'pending':
          await cancelFollowRequest(targetUserId);
          newStatus = 'none';
          break;
      }

      // Update local state
      setUsers(prev => prev.map(user => 
        user.id === targetUserId 
          ? { ...user, followStatus: newStatus }
          : user
      ));
    } catch (error) {
      console.error('Failed to toggle follow:', error);
    }
  };

  if (loading) return <FollowListSkeleton />;

  return (
    <div className="follow-list">
      <div className="follow-list-header">
        <h2>{type === 'followers' ? 'Followers' : 'Following'} ({users.length})</h2>
        
        <div className="search-box">
          <input
            type="text"
            placeholder="Search users..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
          />
        </div>
      </div>

      <div className="users-list">
        {filteredUsers.length === 0 ? (
          <div className="empty-state">
            <p>{searchQuery ? 'No users found' : `No ${type} yet`}</p>
          </div>
        ) : (
          filteredUsers.map(user => (
            <UserListItem
              key={user.id}
              user={user}
              onUserClick={onUserClick}
              onFollowToggle={handleFollowToggle}
            />
          ))
        )}
      </div>
    </div>
  );
}

function UserListItem({ user, onUserClick, onFollowToggle }) {
  const [followLoading, setFollowLoading] = useState(false);
  const currentUserId = getCurrentUserId();

  const handleFollowClick = async () => {
    setFollowLoading(true);
    try {
      await onFollowToggle(user.id, user.followStatus);
    } finally {
      setFollowLoading(false);
    }
  };

  return (
    <div className="user-list-item">
      <div className="user-info" onClick={() => onUserClick(user.id)}>
        <Avatar src={user.avatar} size="medium" />
        <div className="user-details">
          <h4>{user.displayName}</h4>
          <p>@{user.username}</p>
          {user.bio && <p className="user-bio">{user.bio}</p>}
        </div>
      </div>

      {user.id !== currentUserId && (
        <FollowButton
          user={user}
          loading={followLoading}
          onToggle={handleFollowClick}
        />
      )}
    </div>
  );
}
```
</CodeGroup>

### Blocked Users Management

Manage blocked users and unblocking functionality.

<CodeGroup>
```swift iOS
class BlockedUsersViewController: UIViewController {
    private var blockedUsers: [AmityUser] = []
    private let tableView = UITableView()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        loadBlockedUsers()
    }
    
    private func setupUI() {
        title = "Blocked Users"
        
        tableView.delegate = self
        tableView.dataSource = self
        tableView.register(BlockedUserTableViewCell.self, forCellReuseIdentifier: "BlockedUserCell")
        
        view.addSubview(tableView)
        tableView.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            tableView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            tableView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            tableView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            tableView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])
    }
    
    private func loadBlockedUsers() {
        AmityUserRepository().getBlockedUsers { [weak self] result in
            DispatchQueue.main.async {
                switch result {
                case .success(let users):
                    self?.blockedUsers = users
                    self?.tableView.reloadData()
                    self?.updateEmptyState()
                case .failure(let error):
                    self?.showError("Failed to load blocked users: \(error.localizedDescription)")
                }
            }
        }
    }
    
    private func updateEmptyState() {
        if blockedUsers.isEmpty {
            let emptyLabel = UILabel()
            emptyLabel.text = "No blocked users"
            emptyLabel.textAlignment = .center
            emptyLabel.textColor = .systemGray
            tableView.backgroundView = emptyLabel
        } else {
            tableView.backgroundView = nil
        }
    }
    
    private func unblockUser(at indexPath: IndexPath) {
        let user = blockedUsers[indexPath.row]
        
        let alert = UIAlertController(
            title: "Unblock User",
            message: "Are you sure you want to unblock \(user.displayName ?? user.userId)?",
            preferredStyle: .alert
        )
        
        alert.addAction(UIAlertAction(title: "Cancel", style: .cancel))
        alert.addAction(UIAlertAction(title: "Unblock", style: .default) { [weak self] _ in
            self?.performUnblock(user: user, at: indexPath)
        })
        
        present(alert, animated: true)
    }
    
    private func performUnblock(user: AmityUser, at indexPath: IndexPath) {
        AmityUserRepository().unblockUser(user.userId) { [weak self] result in
            DispatchQueue.main.async {
                switch result {
                case .success:
                    self?.blockedUsers.remove(at: indexPath.row)
                    self?.tableView.deleteRows(at: [indexPath], with: .fade)
                    self?.updateEmptyState()
                    self?.showSuccess("User unblocked successfully")
                case .failure(let error):
                    self?.showError("Failed to unblock user: \(error.localizedDescription)")
                }
            }
        }
    }
}

// MARK: - TableView DataSource & Delegate
extension BlockedUsersViewController: UITableViewDataSource, UITableViewDelegate {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return blockedUsers.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "BlockedUserCell", for: indexPath) as! BlockedUserTableViewCell
        let user = blockedUsers[indexPath.row]
        
        cell.configure(
            avatar: user.avatar?.fileUrl,
            displayName: user.displayName ?? "Unknown User",
            username: user.userId,
            onUnblockTapped: { [weak self] in
                self?.unblockUser(at: indexPath)
            }
        )
        
        return cell
    }
}
```

```javascript Web
function BlockedUsers() {
  const [blockedUsers, setBlockedUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadBlockedUsers();
  }, []);

  const loadBlockedUsers = async () => {
    try {
      const users = await getBlockedUsers();
      setBlockedUsers(users);
    } catch (error) {
      console.error('Failed to load blocked users:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleUnblock = async (userId, displayName) => {
    if (!confirm(`Are you sure you want to unblock ${displayName}?`)) {
      return;
    }

    try {
      await unblockUser(userId);
      setBlockedUsers(prev => prev.filter(user => user.id !== userId));
      showToast(`${displayName} has been unblocked`);
    } catch (error) {
      console.error('Failed to unblock user:', error);
      showToast('Failed to unblock user', 'error');
    }
  };

  if (loading) return <div>Loading blocked users...</div>;

  return (
    <div className="blocked-users">
      <div className="blocked-users-header">
        <h2>Blocked Users</h2>
        <p>Users you've blocked won't be able to interact with you</p>
      </div>

      {blockedUsers.length === 0 ? (
        <div className="empty-state">
          <p>No blocked users</p>
        </div>
      ) : (
        <div className="blocked-users-list">
          {blockedUsers.map(user => (
            <div key={user.id} className="blocked-user-item">
              <div className="user-info">
                <Avatar src={user.avatar} size="medium" />
                <div className="user-details">
                  <h4>{user.displayName}</h4>
                  <p>@{user.username}</p>
                </div>
              </div>
              
              <button
                className="unblock-button"
                onClick={() => handleUnblock(user.id, user.displayName)}
              >
                Unblock
              </button>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```
</CodeGroup>

## Platform Support

| Feature | iOS | Android | Web | Flutter | React Native |
|---------|-----|---------|-----|---------|--------------|
| User Profiles | âœ… | âœ… | âœ… | âœ… | - |
| Edit Profile | âœ… | âœ… | âœ… | âœ… | - |
| Follow/Unfollow | âœ… | âœ… | âœ… | âœ… | - |
| Followers List | âœ… | âœ… | âœ… | âœ… | - |
| Following List | âœ… | âœ… | âœ… | âœ… | - |
| Follow Requests | âœ… | âœ… | âœ… | âœ… | - |
| Block/Unblock | âœ… | âœ… | âœ… | âœ… | - |
| Private Accounts | âœ… | âœ… | âœ… | âœ… | - |
| User Search | âœ… | âœ… | âœ… | âœ… | - |

## Best Practices

<Warning>
  Implement proper privacy controls and respect user preferences for private accounts and blocking functionality.
</Warning>

### Privacy & Security

- **Private Accounts**: Respect privacy settings and require approval for follow requests
- **Blocking**: Ensure blocked users cannot interact or see protected content
- **Data Protection**: Handle user data according to privacy regulations
- **Profile Validation**: Validate and sanitize user input to prevent abuse

### User Experience

- **Profile Completion**: Guide users to complete their profiles
- **Search & Discovery**: Make it easy to find and connect with other users
- **Relationship Management**: Provide clear controls for managing social connections
- **Notification Settings**: Allow users to control follow and interaction notifications

### Performance

- **Image Optimization**: Compress and optimize profile images
- **Caching**: Cache frequently accessed user data
- **Pagination**: Load user lists in manageable chunks
- **Lazy Loading**: Load profile images as needed

## Troubleshooting

### Common Issues

<Accordion title="Profile images not loading">
  Check image URL validity, network connectivity, and image format support. Ensure proper fallback images are displayed.
</Accordion>

<Accordion title="Follow requests not working">
  Verify user permissions, check if the target user exists, and ensure proper authentication is in place.
</Accordion>

<Accordion title="Blocked users still visible">
  Check if blocking is properly implemented across all components and that cached data is cleared appropriately.
</Accordion>

<Accordion title="Private account content visible">
  Ensure proper permission checks are in place and that content is filtered based on follow relationships.
</Accordion>

## Related Documentation

<CardGroup cols={2}>
  <Card title="Posts" href="/uikit/components/social/posts">
    Learn about user-specific posting features
  </Card>
  <Card title="Feeds" href="/uikit/components/social/feeds">
    Understand user feeds and content display
  </Card>
  <Card title="Communities" href="/uikit/components/social/communities">
    Explore community membership features
  </Card>
  <Card title="Moderation" href="/uikit/components/social/moderation">
    User reporting and safety features
  </Card>
</CardGroup>
