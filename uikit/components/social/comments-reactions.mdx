---
title: "Comments & Reactions"
description: "Engagement features including threaded comments, emoji reactions, and real-time interactions"
---

# Comments & Reactions

Social+ UIKit provides comprehensive engagement features that enable users to interact with content through comments and reactions. These components support threaded conversations, emoji reactions, and real-time updates for dynamic user engagement.

## Overview

Comments and reactions are essential for building engaging social experiences. They allow users to express opinions, start conversations, and show appreciation for content in various ways.

<img src="/images/uikit/comments-reactions-overview.png" alt="Comments and Reactions Overview" />

## Comments System

### Basic Comments

Enable users to comment on posts with text and media.

<CodeGroup>
```swift iOS
import AmitySocialCloudUIKit

// Display comments for a post
let commentsViewController = AmityCommentsViewController(postId: "post123")
commentsViewController.configure(
    enableReplies: true,
    enableReactions: true,
    enableMentions: true,
    sortOrder: .newest
)

navigationController?.pushViewController(commentsViewController, animated: true)

// Customize comment display
commentsViewController.commentDisplayOptions = AmityCommentDisplayOptions(
    showTimestamp: true,
    showUserAvatar: true,
    enableLinkPreview: true,
    maxNestingLevel: 3
)
```

```kotlin Android
import com.amity.socialcloud.uikit.social.comments.CommentsFragment

// Create comments fragment
val commentsFragment = CommentsFragment.Builder("post123")
    .enableReplies(true)
    .enableReactions(true)
    .enableMentions(true)
    .sortOrder(AmityCommentSortOrder.NEWEST)
    .build()

// Configure comment options
commentsFragment.setCommentDisplayOptions(
    AmityCommentDisplayOptions.Builder()
        .showTimestamp(true)
        .showUserAvatar(true)
        .enableLinkPreview(true)
        .maxNestingLevel(3)
        .build()
)

supportFragmentManager.beginTransaction()
    .replace(R.id.container, commentsFragment)
    .commit()
```

```javascript Web
import { AmityComments } from '@amityco/ui-kit';

function PostComments({ postId }) {
  const [comments, setComments] = useState([]);
  const [newComment, setNewComment] = useState('');

  const handleCommentSubmit = async (commentText) => {
    try {
      const comment = await createComment(postId, commentText);
      setComments(prev => [comment, ...prev]);
      setNewComment('');
    } catch (error) {
      console.error('Failed to create comment:', error);
    }
  };

  return (
    <div className="post-comments">
      <AmityComments
        postId={postId}
        enableReplies={true}
        enableReactions={true}
        enableMentions={true}
        sortOrder="newest"
        onCommentCreate={handleCommentSubmit}
        displayOptions={{
          showTimestamp: true,
          showUserAvatar: true,
          enableLinkPreview: true,
          maxNestingLevel: 3
        }}
      />
    </div>
  );
}
```

```dart Flutter
import 'package:amity_uikit_beta_service/amity_uikit_beta_service.dart';

class CommentsPage extends StatelessWidget {
  final String postId;

  const CommentsPage({Key? key, required this.postId}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Comments')),
      body: AmityComments(
        postId: postId,
        enableReplies: true,
        enableReactions: true,
        enableMentions: true,
        sortOrder: AmityCommentSortOrder.newest,
        displayOptions: AmityCommentDisplayOptions(
          showTimestamp: true,
          showUserAvatar: true,
          enableLinkPreview: true,
          maxNestingLevel: 3,
        ),
        onCommentCreated: (comment) {
          // Handle comment creation
        },
      ),
    );
  }
}
```
</CodeGroup>

### Threaded Comments

Support nested replies and threaded conversations.

<CodeGroup>
```swift iOS
// Configure threaded comments
class ThreadedCommentsViewController: AmityCommentsViewController {
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Enable threaded replies
        enableThreadedReplies(true)
        setMaxNestingLevel(3)
        
        // Customize thread display
        threadDisplayOptions = AmityThreadDisplayOptions(
            showThreadLines: true,
            indentReplies: true,
            collapseThreshold: 5,
            showReplyCount: true
        )
    }
    
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = super.tableView(tableView, cellForRowAt: indexPath)
        
        if let commentCell = cell as? AmityCommentTableViewCell {
            let comment = comments[indexPath.row]
            
            // Apply thread-specific styling
            commentCell.setThreadLevel(comment.threadLevel)
            commentCell.showThreadIndicator(comment.hasReplies)
            
            // Handle thread expansion
            commentCell.onThreadToggle = { [weak self] in
                self?.toggleThreadExpansion(for: comment)
            }
        }
        
        return cell
    }
}
```

```kotlin Android
class ThreadedCommentsAdapter : RecyclerView.Adapter<CommentViewHolder>() {
    
    override fun onBindViewHolder(holder: CommentViewHolder, position: Int) {
        val comment = comments[position]
        
        holder.bind(comment)
        
        // Apply thread indentation
        val indentation = comment.threadLevel * 24.dpToPx()
        holder.itemView.setPadding(indentation, 0, 0, 0)
        
        // Show thread indicator
        holder.threadIndicator.visibility = if (comment.hasReplies) View.VISIBLE else View.GONE
        
        // Handle thread expansion
        holder.expandButton.setOnClickListener {
            toggleThreadExpansion(comment)
        }
        
        // Show reply button
        holder.replyButton.setOnClickListener {
            showReplyComposer(comment)
        }
    }
    
    private fun toggleThreadExpansion(comment: AmityComment) {
        if (comment.isExpanded) {
            collapseThread(comment)
        } else {
            expandThread(comment)
        }
        notifyDataSetChanged()
    }
}
```

```javascript Web
function ThreadedComment({ comment, level = 0, onReply, onToggleThread }) {
  const [isExpanded, setIsExpanded] = useState(comment.isExpanded);
  const [showReplyForm, setShowReplyForm] = useState(false);

  const handleToggleThread = () => {
    setIsExpanded(!isExpanded);
    onToggleThread(comment.id, !isExpanded);
  };

  const handleReply = (replyText) => {
    onReply(comment.id, replyText);
    setShowReplyForm(false);
  };

  return (
    <div className={`threaded-comment level-${level}`}>
      <div className="comment-content">
        <div className="comment-header">
          <Avatar src={comment.user.avatar} size="small" />
          <span className="user-name">{comment.user.displayName}</span>
          <span className="timestamp">{formatDate(comment.createdAt)}</span>
        </div>
        
        <div className="comment-text">
          <MentionText text={comment.text} mentions={comment.mentions} />
        </div>
        
        <div className="comment-actions">
          <ReactionButton comment={comment} />
          <button onClick={() => setShowReplyForm(true)}>Reply</button>
          
          {comment.replies && comment.replies.length > 0 && (
            <button onClick={handleToggleThread}>
              {isExpanded ? 'Hide' : 'Show'} {comment.replies.length} replies
            </button>
          )}
        </div>
      </div>
      
      {showReplyForm && (
        <CommentComposer
          placeholder={`Reply to ${comment.user.displayName}`}
          onSubmit={handleReply}
          onCancel={() => setShowReplyForm(false)}
        />
      )}
      
      {isExpanded && comment.replies && (
        <div className="comment-replies">
          {comment.replies.map(reply => (
            <ThreadedComment
              key={reply.id}
              comment={reply}
              level={level + 1}
              onReply={onReply}
              onToggleThread={onToggleThread}
            />
          ))}
        </div>
      )}
    </div>
  );
}
```

```dart Flutter
class ThreadedCommentWidget extends StatefulWidget {
  final AmityComment comment;
  final int level;
  final Function(String, String) onReply;
  final Function(String, bool) onToggleThread;

  const ThreadedCommentWidget({
    Key? key,
    required this.comment,
    this.level = 0,
    required this.onReply,
    required this.onToggleThread,
  }) : super(key: key);

  @override
  _ThreadedCommentWidgetState createState() => _ThreadedCommentWidgetState();
}

class _ThreadedCommentWidgetState extends State<ThreadedCommentWidget> {
  bool isExpanded = false;
  bool showReplyForm = false;

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: EdgeInsets.only(left: widget.level * 24.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Comment content
          CommentContent(
            comment: widget.comment,
            onReply: () => setState(() => showReplyForm = true),
            onToggleThread: () {
              setState(() => isExpanded = !isExpanded);
              widget.onToggleThread(widget.comment.id, isExpanded);
            },
          ),
          
          // Reply form
          if (showReplyForm)
            CommentComposer(
              placeholder: 'Reply to ${widget.comment.user.displayName}',
              onSubmit: (text) {
                widget.onReply(widget.comment.id, text);
                setState(() => showReplyForm = false);
              },
              onCancel: () => setState(() => showReplyForm = false),
            ),
          
          // Nested replies
          if (isExpanded && widget.comment.replies.isNotEmpty)
            Column(
              children: widget.comment.replies.map((reply) =>
                ThreadedCommentWidget(
                  comment: reply,
                  level: widget.level + 1,
                  onReply: widget.onReply,
                  onToggleThread: widget.onToggleThread,
                )
              ).toList(),
            ),
        ],
      ),
    );
  }
}
```
</CodeGroup>

### Comment Composer

Provide a rich comment creation interface.

<CodeGroup>
```swift iOS
// Custom comment composer with enhanced features
class EnhancedCommentComposer: UIView {
    private let textView = UITextView()
    private let mentionButton = UIButton()
    private let emojiButton = UIButton()
    private let submitButton = UIButton()
    private let attachmentButton = UIButton()
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupUI()
    }
    
    private func setupUI() {
        // Configure text view
        textView.delegate = self
        textView.isScrollEnabled = false
        textView.font = UIFont.systemFont(ofSize: 16)
        textView.placeholder = "Write a comment..."
        
        // Configure buttons
        mentionButton.setTitle("@", for: .normal)
        mentionButton.addTarget(self, action: #selector(mentionTapped), for: .touchUpInside)
        
        emojiButton.setTitle("😊", for: .normal)
        emojiButton.addTarget(self, action: #selector(emojiTapped), for: .touchUpInside)
        
        submitButton.setTitle("Post", for: .normal)
        submitButton.addTarget(self, action: #selector(submitTapped), for: .touchUpInside)
        
        attachmentButton.setTitle("📎", for: .normal)
        attachmentButton.addTarget(self, action: #selector(attachmentTapped), for: .touchUpInside)
        
        // Layout constraints
        setupConstraints()
    }
    
    @objc private func mentionTapped() {
        // Show mention picker
        let mentionPicker = MentionPickerViewController()
        mentionPicker.onUserSelected = { [weak self] user in
            self?.insertMention(user)
        }
        present(mentionPicker, animated: true)
    }
    
    @objc private func emojiTapped() {
        // Show emoji picker
        textView.becomeFirstResponder()
        textView.inputView = EmojiKeyboard()
        textView.reloadInputViews()
    }
    
    @objc private func submitTapped() {
        guard !textView.text.isEmpty else { return }
        
        // Submit comment
        onCommentSubmit?(textView.text)
        textView.text = ""
        updateSubmitButtonState()
    }
    
    var onCommentSubmit: ((String) -> Void)?
}
```

```kotlin Android
class EnhancedCommentComposer @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : LinearLayout(context, attrs, defStyleAttr) {

    private val editText: EditText
    private val mentionButton: ImageButton
    private val emojiButton: ImageButton
    private val attachmentButton: ImageButton
    private val submitButton: Button

    var onCommentSubmit: ((String) -> Unit)? = null
    var onMentionTapped: (() -> Unit)? = null
    var onAttachmentTapped: (() -> Unit)? = null

    init {
        inflate(context, R.layout.enhanced_comment_composer, this)
        
        editText = findViewById(R.id.comment_edit_text)
        mentionButton = findViewById(R.id.mention_button)
        emojiButton = findViewById(R.id.emoji_button)
        attachmentButton = findViewById(R.id.attachment_button)
        submitButton = findViewById(R.id.submit_button)
        
        setupListeners()
    }

    private fun setupListeners() {
        editText.addTextChangedListener(object : TextWatcher {
            override fun afterTextChanged(s: Editable?) {
                updateSubmitButtonState()
                detectMentions(s.toString())
            }
            
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}
        })

        mentionButton.setOnClickListener {
            onMentionTapped?.invoke()
        }

        emojiButton.setOnClickListener {
            showEmojiKeyboard()
        }

        attachmentButton.setOnClickListener {
            onAttachmentTapped?.invoke()
        }

        submitButton.setOnClickListener {
            val text = editText.text.toString().trim()
            if (text.isNotEmpty()) {
                onCommentSubmit?.invoke(text)
                editText.text.clear()
            }
        }
    }

    private fun updateSubmitButtonState() {
        submitButton.isEnabled = editText.text.toString().trim().isNotEmpty()
    }

    private fun detectMentions(text: String) {
        // Detect @mentions and show suggestions
        val mentionPattern = "@(\\w*)$".toRegex()
        val match = mentionPattern.find(text)
        if (match != null) {
            showMentionSuggestions(match.groupValues[1])
        }
    }
}
```

```javascript Web
function EnhancedCommentComposer({ 
  onSubmit, 
  placeholder = "Write a comment...", 
  enableMentions = true,
  enableAttachments = false 
}) {
  const [text, setText] = useState('');
  const [mentions, setMentions] = useState([]);
  const [showMentionSuggestions, setShowMentionSuggestions] = useState(false);
  const [mentionQuery, setMentionQuery] = useState('');
  const textAreaRef = useRef(null);

  const handleTextChange = (value) => {
    setText(value);
    
    if (enableMentions) {
      // Detect mention trigger
      const mentionMatch = value.match(/@(\w*)$/);
      if (mentionMatch) {
        setMentionQuery(mentionMatch[1]);
        setShowMentionSuggestions(true);
      } else {
        setShowMentionSuggestions(false);
      }
    }
  };

  const handleSubmit = () => {
    if (text.trim()) {
      onSubmit(text.trim(), mentions);
      setText('');
      setMentions([]);
    }
  };

  const insertMention = (user) => {
    const newText = text.replace(/@\w*$/, `@${user.displayName} `);
    const newMention = {
      userId: user.id,
      displayName: user.displayName,
      startIndex: newText.lastIndexOf(`@${user.displayName}`),
      length: user.displayName.length + 1
    };
    
    setText(newText);
    setMentions([...mentions, newMention]);
    setShowMentionSuggestions(false);
    textAreaRef.current?.focus();
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit();
    }
  };

  return (
    <div className="enhanced-comment-composer">
      <div className="composer-input">
        <textarea
          ref={textAreaRef}
          value={text}
          onChange={(e) => handleTextChange(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          rows={1}
          style={{ resize: 'none' }}
        />
        
        <div className="composer-actions">
          {enableMentions && (
            <button
              type="button"
              className="mention-button"
              onClick={() => setShowMentionSuggestions(true)}
            >
              @
            </button>
          )}
          
          <button
            type="button"
            className="emoji-button"
            onClick={() => {/* Show emoji picker */}}
          >
            😊
          </button>
          
          {enableAttachments && (
            <button
              type="button"
              className="attachment-button"
              onClick={() => {/* Show attachment picker */}}
            >
              📎
            </button>
          )}
          
          <button
            type="button"
            className="submit-button"
            onClick={handleSubmit}
            disabled={!text.trim()}
          >
            Post
          </button>
        </div>
      </div>
      
      {showMentionSuggestions && (
        <MentionSuggestions
          query={mentionQuery}
          onSelect={insertMention}
          onClose={() => setShowMentionSuggestions(false)}
        />
      )}
    </div>
  );
}
```
</CodeGroup>

## Reactions System

### Emoji Reactions

Enable users to react to posts and comments with emojis.

<CodeGroup>
```swift iOS
// Configure reaction system
class ReactionManager {
    static let shared = ReactionManager()
    
    let defaultReactions = ["👍", "👎", "❤️", "😂", "😢", "😮"]
    
    func showReactionPicker(for post: AmityPost, from view: UIView) {
        let reactionPicker = ReactionPickerViewController()
        reactionPicker.reactions = defaultReactions
        reactionPicker.currentUserReactions = getCurrentUserReactions(for: post)
        
        reactionPicker.onReactionSelected = { [weak self] reaction in
            self?.toggleReaction(reaction, for: post)
        }
        
        // Present as popover on iPad, modal on iPhone
        if UIDevice.current.userInterfaceIdiom == .pad {
            reactionPicker.modalPresentationStyle = .popover
            reactionPicker.popoverPresentationController?.sourceView = view
        }
        
        present(reactionPicker, animated: true)
    }
    
    func toggleReaction(_ reaction: String, for post: AmityPost) {
        let reactionRepository = AmityReactionRepository()
        
        if hasUserReacted(reaction, to: post) {
            // Remove reaction
            reactionRepository.removeReaction(reaction, from: post.id) { result in
                DispatchQueue.main.async {
                    self.handleReactionResult(result, for: post)
                }
            }
        } else {
            // Add reaction
            reactionRepository.addReaction(reaction, to: post.id) { result in
                DispatchQueue.main.async {
                    self.handleReactionResult(result, for: post)
                }
            }
        }
    }
}
```

```kotlin Android
class ReactionManager {
    companion object {
        val DEFAULT_REACTIONS = listOf("👍", "👎", "❤️", "😂", "😢", "😮")
    }
    
    fun showReactionPicker(
        context: Context,
        post: AmityPost,
        anchorView: View,
        onReactionSelected: (String) -> Unit
    ) {
        val reactionPicker = ReactionPickerBottomSheet()
        reactionPicker.reactions = DEFAULT_REACTIONS
        reactionPicker.currentUserReactions = getCurrentUserReactions(post)
        reactionPicker.onReactionSelected = onReactionSelected
        
        if (context is FragmentActivity) {
            reactionPicker.show(context.supportFragmentManager, "ReactionPicker")
        }
    }
    
    fun toggleReaction(reaction: String, post: AmityPost) {
        val reactionRepository = AmityReactionRepository()
        
        if (hasUserReacted(reaction, post)) {
            reactionRepository.removeReaction(reaction, post.id)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                    { handleReactionResult(it, post) },
                    { handleReactionError(it) }
                )
        } else {
            reactionRepository.addReaction(reaction, post.id)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                    { handleReactionResult(it, post) },
                    { handleReactionError(it) }
                )
        }
    }
    
    private fun getCurrentUserReactions(post: AmityPost): List<String> {
        return post.myReactions?.map { it.reactionName } ?: emptyList()
    }
}
```

```javascript Web
function ReactionSystem({ post, onReactionChange }) {
  const [reactions, setReactions] = useState(post.reactions || {});
  const [userReactions, setUserReactions] = useState(post.myReactions || []);
  const [showPicker, setShowPicker] = useState(false);

  const defaultReactions = ['👍', '👎', '❤️', '😂', '😢', '😮'];

  const toggleReaction = async (reactionType) => {
    const hasReacted = userReactions.includes(reactionType);
    
    try {
      if (hasReacted) {
        await removeReaction(post.id, reactionType);
        setUserReactions(prev => prev.filter(r => r !== reactionType));
        setReactions(prev => ({
          ...prev,
          [reactionType]: Math.max(0, (prev[reactionType] || 0) - 1)
        }));
      } else {
        await addReaction(post.id, reactionType);
        setUserReactions(prev => [...prev, reactionType]);
        setReactions(prev => ({
          ...prev,
          [reactionType]: (prev[reactionType] || 0) + 1
        }));
      }
      
      onReactionChange?.(reactions);
    } catch (error) {
      console.error('Failed to toggle reaction:', error);
    }
  };

  const handleQuickReaction = (reactionType) => {
    toggleReaction(reactionType);
  };

  return (
    <div className="reaction-system">
      {/* Quick reactions */}
      <div className="quick-reactions">
        {defaultReactions.slice(0, 3).map(reaction => (
          <button
            key={reaction}
            className={`quick-reaction ${userReactions.includes(reaction) ? 'active' : ''}`}
            onClick={() => handleQuickReaction(reaction)}
          >
            {reaction} {reactions[reaction] || 0}
          </button>
        ))}
        
        <button
          className="more-reactions"
          onClick={() => setShowPicker(true)}
        >
          + Add Reaction
        </button>
      </div>

      {/* Reaction summary */}
      <div className="reaction-summary">
        {Object.entries(reactions)
          .filter(([_, count]) => count > 0)
          .map(([reaction, count]) => (
            <span key={reaction} className="reaction-count">
              {reaction} {count}
            </span>
          ))
        }
      </div>

      {/* Reaction picker modal */}
      {showPicker && (
        <ReactionPicker
          reactions={defaultReactions}
          userReactions={userReactions}
          onReactionSelect={toggleReaction}
          onClose={() => setShowPicker(false)}
        />
      )}
    </div>
  );
}

function ReactionPicker({ reactions, userReactions, onReactionSelect, onClose }) {
  return (
    <div className="reaction-picker-overlay" onClick={onClose}>
      <div className="reaction-picker" onClick={e => e.stopPropagation()}>
        <h3>Choose a reaction</h3>
        <div className="reaction-grid">
          {reactions.map(reaction => (
            <button
              key={reaction}
              className={`reaction-option ${userReactions.includes(reaction) ? 'selected' : ''}`}
              onClick={() => {
                onReactionSelect(reaction);
                onClose();
              }}
            >
              {reaction}
            </button>
          ))}
        </div>
      </div>
    </div>
  );
}
```

```dart Flutter
class ReactionSystem extends StatefulWidget {
  final AmityPost post;
  final Function(Map<String, int>) onReactionChange;

  const ReactionSystem({
    Key? key,
    required this.post,
    required this.onReactionChange,
  }) : super(key: key);

  @override
  _ReactionSystemState createState() => _ReactionSystemState();
}

class _ReactionSystemState extends State<ReactionSystem> {
  static const List<String> defaultReactions = ['👍', '👎', '❤️', '😂', '😢', '😮'];
  
  Map<String, int> reactions = {};
  List<String> userReactions = [];

  @override
  void initState() {
    super.initState();
    reactions = Map.from(widget.post.reactions ?? {});
    userReactions = List.from(widget.post.myReactions ?? []);
  }

  Future<void> toggleReaction(String reactionType) async {
    final hasReacted = userReactions.contains(reactionType);
    
    try {
      if (hasReacted) {
        await AmityReactionRepository.removeReaction(widget.post.id, reactionType);
        setState(() {
          userReactions.remove(reactionType);
          reactions[reactionType] = math.max(0, (reactions[reactionType] ?? 0) - 1);
        });
      } else {
        await AmityReactionRepository.addReaction(widget.post.id, reactionType);
        setState(() {
          userReactions.add(reactionType);
          reactions[reactionType] = (reactions[reactionType] ?? 0) + 1;
        });
      }
      
      widget.onReactionChange(reactions);
    } catch (error) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to toggle reaction: $error')),
      );
    }
  }

  void showReactionPicker() {
    showModalBottomSheet(
      context: context,
      builder: (context) => ReactionPicker(
        reactions: defaultReactions,
        userReactions: userReactions,
        onReactionSelect: (reaction) {
          toggleReaction(reaction);
          Navigator.pop(context);
        },
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Quick reactions
        Row(
          children: [
            ...defaultReactions.take(3).map((reaction) => 
              GestureDetector(
                onTap: () => toggleReaction(reaction),
                child: Container(
                  padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: userReactions.contains(reaction) 
                        ? Colors.blue.withOpacity(0.2)
                        : Colors.transparent,
                    borderRadius: BorderRadius.circular(16),
                    border: Border.all(
                      color: userReactions.contains(reaction) 
                          ? Colors.blue 
                          : Colors.grey,
                    ),
                  ),
                  child: Text('$reaction ${reactions[reaction] ?? 0}'),
                ),
              ),
            ),
            GestureDetector(
              onTap: showReactionPicker,
              child: Container(
                padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(16),
                  border: Border.all(color: Colors.grey),
                ),
                child: Text('+ Add Reaction'),
              ),
            ),
          ],
        ),
        
        // Reaction summary
        if (reactions.values.any((count) => count > 0))
          Padding(
            padding: EdgeInsets.only(top: 8),
            child: Wrap(
              spacing: 8,
              children: reactions.entries
                  .where((entry) => entry.value > 0)
                  .map((entry) => Text('${entry.key} ${entry.value}'))
                  .toList(),
            ),
          ),
      ],
    );
  }
}
```
</CodeGroup>

### Reaction Analytics

Track and display reaction analytics for insights.

<Tabs>
  <Tab title="Reaction Insights">
    ```javascript
    function ReactionInsights({ post, reactions }) {
      const [insights, setInsights] = useState(null);
      const [loading, setLoading] = useState(true);

      useEffect(() => {
        fetchReactionInsights();
      }, [post.id]);

      const fetchReactionInsights = async () => {
        try {
          const data = await getReactionInsights(post.id);
          setInsights(data);
        } catch (error) {
          console.error('Failed to fetch reaction insights:', error);
        } finally {
          setLoading(false);
        }
      };

      if (loading) return <div>Loading insights...</div>;
      if (!insights) return null;

      return (
        <div className="reaction-insights">
          <h4>Reaction Insights</h4>
          
          <div className="insights-summary">
            <div className="total-reactions">
              <strong>{insights.totalReactions}</strong> total reactions
            </div>
            <div className="unique-users">
              <strong>{insights.uniqueUsers}</strong> users reacted
            </div>
          </div>

          <div className="reaction-breakdown">
            {insights.reactionBreakdown.map(({ reaction, count, percentage }) => (
              <div key={reaction} className="reaction-stat">
                <span className="reaction-emoji">{reaction}</span>
                <div className="reaction-bar">
                  <div 
                    className="reaction-fill" 
                    style={{ width: `${percentage}%` }}
                  />
                </div>
                <span className="reaction-count">{count}</span>
              </div>
            ))}
          </div>

          <div className="reaction-timeline">
            <h5>Reaction Timeline</h5>
            <ReactionChart data={insights.timeline} />
          </div>
        </div>
      );
    }
    ```
  </Tab>
  
  <Tab title="Top Reactors">
    ```javascript
    function TopReactors({ postId, limit = 5 }) {
      const [topReactors, setTopReactors] = useState([]);

      useEffect(() => {
        fetchTopReactors();
      }, [postId]);

      const fetchTopReactors = async () => {
        try {
          const reactors = await getTopReactors(postId, limit);
          setTopReactors(reactors);
        } catch (error) {
          console.error('Failed to fetch top reactors:', error);
        }
      };

      return (
        <div className="top-reactors">
          <h5>Top Reactors</h5>
          <div className="reactor-list">
            {topReactors.map((reactor, index) => (
              <div key={reactor.userId} className="reactor-item">
                <div className="reactor-rank">#{index + 1}</div>
                <Avatar src={reactor.avatar} size="small" />
                <div className="reactor-info">
                  <div className="reactor-name">{reactor.displayName}</div>
                  <div className="reactor-stats">
                    {reactor.reactionCount} reactions
                  </div>
                </div>
                <div className="reactor-reactions">
                  {reactor.favoriteReactions.map(reaction => (
                    <span key={reaction} className="reaction-badge">
                      {reaction}
                    </span>
                  ))}
                </div>
              </div>
            ))}
          </div>
        </div>
      );
    }
    ```
  </Tab>
</Tabs>

## Real-time Updates

Enable live updates for comments and reactions.

<CodeGroup>
```swift iOS
// Real-time comment updates
class RealTimeCommentManager {
    private var commentObserver: AmityNotificationToken?
    private let postId: String
    
    init(postId: String) {
        self.postId = postId
        setupRealTimeUpdates()
    }
    
    private func setupRealTimeUpdates() {
        let commentRepository = AmityCommentRepository()
        
        commentObserver = commentRepository.getComments(
            postId: postId,
            sortBy: .createdAt,
            orderBy: .descending
        ).observe { [weak self] result in
            switch result {
            case .success(let comments):
                self?.handleCommentsUpdate(comments)
            case .failure(let error):
                self?.handleError(error)
            }
        }
    }
    
    private func handleCommentsUpdate(_ comments: [AmityComment]) {
        DispatchQueue.main.async {
            // Update UI with new comments
            self.delegate?.commentsDidUpdate(comments)
            
            // Show notification for new comments
            self.showNewCommentNotification(comments)
        }
    }
    
    deinit {
        commentObserver?.invalidate()
    }
}
```

```kotlin Android
class RealTimeCommentManager(private val postId: String) {
    private val commentRepository = AmityCommentRepository()
    private var commentDisposable: Disposable? = null
    
    fun startRealTimeUpdates() {
        commentDisposable = commentRepository.getComments(postId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                { comments -> handleCommentsUpdate(comments) },
                { error -> handleError(error) }
            )
    }
    
    private fun handleCommentsUpdate(comments: List<AmityComment>) {
        // Update UI with new comments
        commentUpdateListener?.onCommentsUpdated(comments)
        
        // Show notification for new comments
        showNewCommentNotification(comments)
    }
    
    fun stopRealTimeUpdates() {
        commentDisposable?.dispose()
    }
    
    var commentUpdateListener: CommentUpdateListener? = null
    
    interface CommentUpdateListener {
        fun onCommentsUpdated(comments: List<AmityComment>)
        fun onError(error: Throwable)
    }
}
```

```javascript Web
function useRealTimeComments(postId) {
  const [comments, setComments] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const subscription = subscribeToComments(postId, {
      onCommentsUpdate: (newComments) => {
        setComments(newComments);
        setLoading(false);
        
        // Show notification for new comments
        showNewCommentNotification(newComments);
      },
      onCommentAdded: (comment) => {
        setComments(prev => [comment, ...prev]);
        showCommentAddedNotification(comment);
      },
      onCommentUpdated: (comment) => {
        setComments(prev => 
          prev.map(c => c.id === comment.id ? comment : c)
        );
      },
      onCommentDeleted: (commentId) => {
        setComments(prev => prev.filter(c => c.id !== commentId));
      },
      onError: (error) => {
        console.error('Real-time comments error:', error);
        setLoading(false);
      }
    });

    return () => subscription.unsubscribe();
  }, [postId]);

  return { comments, loading };
}

function subscribeToComments(postId, callbacks) {
  const socket = io('/comments');
  
  socket.emit('join', { postId });
  
  socket.on('comments:update', callbacks.onCommentsUpdate);
  socket.on('comment:added', callbacks.onCommentAdded);
  socket.on('comment:updated', callbacks.onCommentUpdated);
  socket.on('comment:deleted', callbacks.onCommentDeleted);
  socket.on('error', callbacks.onError);
  
  return {
    unsubscribe: () => {
      socket.emit('leave', { postId });
      socket.off('comments:update');
      socket.off('comment:added');
      socket.off('comment:updated');
      socket.off('comment:deleted');
      socket.off('error');
      socket.close();
    }
  };
}
```

```dart Flutter
class RealTimeCommentManager {
  final String postId;
  StreamSubscription? _commentSubscription;
  final StreamController<List<AmityComment>> _commentsController = StreamController();
  
  RealTimeCommentManager(this.postId);
  
  Stream<List<AmityComment>> get commentsStream => _commentsController.stream;
  
  void startRealTimeUpdates() {
    _commentSubscription = AmityCommentRepository.getComments(postId)
        .listen(
          (comments) {
            _commentsController.add(comments);
            _showNewCommentNotification(comments);
          },
          onError: (error) {
            _commentsController.addError(error);
          },
        );
  }
  
  void stopRealTimeUpdates() {
    _commentSubscription?.cancel();
  }
  
  void _showNewCommentNotification(List<AmityComment> comments) {
    // Show notification for new comments
    if (comments.isNotEmpty) {
      final latestComment = comments.first;
      if (_isNewComment(latestComment)) {
        _showNotification('New comment from ${latestComment.user.displayName}');
      }
    }
  }
  
  bool _isNewComment(AmityComment comment) {
    final now = DateTime.now();
    final commentTime = comment.createdAt;
    return now.difference(commentTime).inSeconds < 10;
  }
  
  void dispose() {
    stopRealTimeUpdates();
    _commentsController.close();
  }
}
```
</CodeGroup>

## Platform Support

| Feature | iOS | Android | Web | Flutter | React Native |
|---------|-----|---------|-----|---------|--------------|
| Basic Comments | ✅ | ✅ | ✅ | ✅ | ✅ |
| Threaded Comments | ✅ | ✅ | ✅ | ✅ | ✅ |
| Comment Editing | ✅ | ✅ | ✅ | ✅ | ✅ |
| Comment Deletion | ✅ | ✅ | ✅ | ✅ | ✅ |
| Emoji Reactions | ✅ | ✅ | ✅ | ✅ | ✅ |
| Custom Reactions | ✅ | ✅ | ✅ | ✅ | - |
| Mentions in Comments | ✅ | ✅ | ✅ | ✅ | ✅ |
| Real-time Updates | ✅ | ✅ | ✅ | ✅ | ✅ |
| Reaction Analytics | ✅ | ✅ | ✅ | - | - |

## Best Practices

<Warning>
  Implement proper moderation and spam prevention measures for comments to maintain community quality and safety.
</Warning>

### Performance Optimization

- **Pagination**: Load comments in batches (20-50 per page)
- **Virtual Scrolling**: Use for long comment threads
- **Lazy Loading**: Load nested replies on demand
- **Debouncing**: Debounce real-time updates to prevent excessive API calls

### User Experience

- **Loading States**: Show skeleton screens while loading comments
- **Optimistic Updates**: Update UI immediately, sync with server
- **Error Handling**: Provide retry options for failed operations
- **Accessibility**: Ensure screen reader compatibility

### Content Quality

- **Spam Prevention**: Implement rate limiting and content filtering
- **Moderation Tools**: Provide easy reporting and moderation options
- **Character Limits**: Set reasonable limits for comment length
- **Rich Text**: Support basic formatting while preventing abuse

## Troubleshooting

### Common Issues

<Accordion title="Comments not loading">
  Check network connectivity, API authentication, and user permissions for the post.
</Accordion>

<Accordion title="Real-time updates not working">
  Verify WebSocket connection and ensure proper event listeners are configured.
</Accordion>

<Accordion title="Reactions not updating">
  Check if the user has proper permissions and that the reaction repository is properly initialized.
</Accordion>

<Accordion title="Threaded comments not displaying">
  Verify that the comment nesting level is within the configured maximum depth.
</Accordion>

## Related Documentation

<CardGroup cols={2}>
  <Card title="Posts" href="/uikit/components/social/posts">
    Learn about post creation and management
  </Card>
  <Card title="Feeds" href="/uikit/components/social/feeds">
    Understand how comments appear in feeds
  </Card>
  <Card title="Moderation" href="/uikit/components/social/moderation">
    Content moderation and safety features
  </Card>
  <Card title="Users" href="/uikit/components/social/users">
    User profiles and social interactions
  </Card>
</CardGroup>
