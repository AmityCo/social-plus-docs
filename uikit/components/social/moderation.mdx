---
title: "Content Moderation"
description: "Comprehensive content moderation tools for community safety and content oversight"
---

# Content Moderation

Social+ UIKit provides comprehensive content moderation tools that enable communities to maintain safe and healthy environments. These components include reporting systems, automated filtering, and administrative oversight features.

## Overview

Content moderation is essential for maintaining community standards and user safety. The moderation system supports both user-driven reporting and administrative tools for content oversight and management.

<img src="/images/uikit/moderation-overview.png" alt="Content Moderation Overview" />

## Reporting System

### Content Reporting

Enable users to report inappropriate content with structured reporting reasons.

<CodeGroup>
```swift iOS
import AmitySocialCloudUIKit

// Report post functionality
class ReportManager {
    enum ReportReason: String, CaseIterable {
        case spam = "spam"
        case harassment = "harassment"
        case selfHarm = "self_harm"
        case violence = "violence"
        case restrictedItems = "restricted_items"
        case sexualContent = "sexual_content"
        case misinformation = "misinformation"
        case communityGuidelines = "community_guidelines"
        case other = "other"
        
        var displayName: String {
            switch self {
            case .spam: return "Spam or scams"
            case .harassment: return "Harassment or bullying"
            case .selfHarm: return "Self-harm or suicide"
            case .violence: return "Violence or threatening content"
            case .restrictedItems: return "Selling/restricted items"
            case .sexualContent: return "Sexual content or nudity"
            case .misinformation: return "False information/misinformation"
            case .communityGuidelines: return "Against community guidelines"
            case .other: return "Others"
            }
        }
    }
    
    static func showReportOptions(for post: AmityPost, from viewController: UIViewController) {
        let alertController = UIAlertController(
            title: "Report Post",
            message: "Why are you reporting this post?",
            preferredStyle: .actionSheet
        )
        
        // Add report reason options
        for reason in ReportReason.allCases {
            let action = UIAlertAction(title: reason.displayName, style: .default) { _ in
                if reason == .other {
                    showCustomReasonInput(for: post, from: viewController)
                } else {
                    submitReport(for: post, reason: reason.rawValue, customReason: nil, from: viewController)
                }
            }
            alertController.addAction(action)
        }
        
        alertController.addAction(UIAlertAction(title: "Cancel", style: .cancel))
        
        // Present as popover on iPad
        if let popover = alertController.popoverPresentationController {
            popover.sourceView = viewController.view
            popover.sourceRect = CGRect(x: viewController.view.bounds.midX, y: viewController.view.bounds.midY, width: 0, height: 0)
            popover.permittedArrowDirections = []
        }
        
        viewController.present(alertController, animated: true)
    }
    
    private static func showCustomReasonInput(for post: AmityPost, from viewController: UIViewController) {
        let alertController = UIAlertController(
            title: "Other Reason",
            message: "Please describe the issue (max 300 characters)",
            preferredStyle: .alert
        )
        
        alertController.addTextField { textField in
            textField.placeholder = "Describe the issue..."
            textField.autocapitalizationType = .sentences
        }
        
        let submitAction = UIAlertAction(title: "Submit", style: .default) { _ in
            let customReason = alertController.textFields?.first?.text ?? ""
            submitReport(for: post, reason: ReportReason.other.rawValue, customReason: customReason, from: viewController)
        }
        
        alertController.addAction(submitAction)
        alertController.addAction(UIAlertAction(title: "Cancel", style: .cancel))
        
        viewController.present(alertController, animated: true)
    }
    
    private static func submitReport(for post: AmityPost, reason: String, customReason: String?, from viewController: UIViewController) {
        let reportRepository = AmityReportRepository()
        
        reportRepository.reportPost(
            postId: post.id,
            reason: reason,
            customReason: customReason
        ) { result in
            DispatchQueue.main.async {
                switch result {
                case .success:
                    viewController.showSuccess("Thank you for your report. We'll review it soon.")
                case .failure(let error):
                    viewController.showError("Failed to submit report: \(error.localizedDescription)")
                }
            }
        }
    }
}

// Report comment functionality
extension ReportManager {
    static func showReportOptions(for comment: AmityComment, from viewController: UIViewController) {
        let alertController = UIAlertController(
            title: "Report Comment",
            message: "Why are you reporting this comment?",
            preferredStyle: .actionSheet
        )
        
        for reason in ReportReason.allCases {
            let action = UIAlertAction(title: reason.displayName, style: .default) { _ in
                if reason == .other {
                    showCustomReasonInput(for: comment, from: viewController)
                } else {
                    submitReport(for: comment, reason: reason.rawValue, customReason: nil, from: viewController)
                }
            }
            alertController.addAction(action)
        }
        
        alertController.addAction(UIAlertAction(title: "Cancel", style: .cancel))
        
        if let popover = alertController.popoverPresentationController {
            popover.sourceView = viewController.view
            popover.sourceRect = CGRect(x: viewController.view.bounds.midX, y: viewController.view.bounds.midY, width: 0, height: 0)
            popover.permittedArrowDirections = []
        }
        
        viewController.present(alertController, animated: true)
    }
    
    private static func submitReport(for comment: AmityComment, reason: String, customReason: String?, from viewController: UIViewController) {
        let reportRepository = AmityReportRepository()
        
        reportRepository.reportComment(
            commentId: comment.id,
            reason: reason,
            customReason: customReason
        ) { result in
            DispatchQueue.main.async {
                switch result {
                case .success:
                    viewController.showSuccess("Thank you for your report. We'll review it soon.")
                case .failure(let error):
                    viewController.showError("Failed to submit report: \(error.localizedDescription)")
                }
            }
        }
    }
}
```

```kotlin Android
import com.amity.socialcloud.uikit.social.moderation.ReportBottomSheetDialog

class ReportManager {
    companion object {
        enum class ReportReason(val value: String, val displayName: String) {
            SPAM("spam", "Spam or scams"),
            HARASSMENT("harassment", "Harassment or bullying"),
            SELF_HARM("self_harm", "Self-harm or suicide"),
            VIOLENCE("violence", "Violence or threatening content"),
            RESTRICTED_ITEMS("restricted_items", "Selling/restricted items"),
            SEXUAL_CONTENT("sexual_content", "Sexual content or nudity"),
            MISINFORMATION("misinformation", "False information/misinformation"),
            COMMUNITY_GUIDELINES("community_guidelines", "Against community guidelines"),
            OTHER("other", "Others")
        }
        
        fun showReportOptions(context: Context, post: AmityPost) {
            val reportDialog = ReportBottomSheetDialog.Builder()
                .setTitle("Report Post")
                .setMessage("Why are you reporting this post?")
                .setReportReasons(ReportReason.values().map { it.displayName })
                .setOnReasonSelected { position, customReason ->
                    val reason = ReportReason.values()[position]
                    submitPostReport(post.id, reason.value, customReason)
                }
                .build()
            
            if (context is FragmentActivity) {
                reportDialog.show(context.supportFragmentManager, "ReportDialog")
            }
        }
        
        fun showReportOptions(context: Context, comment: AmityComment) {
            val reportDialog = ReportBottomSheetDialog.Builder()
                .setTitle("Report Comment")
                .setMessage("Why are you reporting this comment?")
                .setReportReasons(ReportReason.values().map { it.displayName })
                .setOnReasonSelected { position, customReason ->
                    val reason = ReportReason.values()[position]
                    submitCommentReport(comment.id, reason.value, customReason)
                }
                .build()
            
            if (context is FragmentActivity) {
                reportDialog.show(context.supportFragmentManager, "ReportDialog")
            }
        }
        
        private fun submitPostReport(postId: String, reason: String, customReason: String?) {
            AmityReportRepository().reportPost(postId, reason, customReason)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                    { 
                        showToast("Thank you for your report. We'll review it soon.")
                    },
                    { error -> 
                        showToast("Failed to submit report: ${error.message}")
                    }
                )
        }
        
        private fun submitCommentReport(commentId: String, reason: String, customReason: String?) {
            AmityReportRepository().reportComment(commentId, reason, customReason)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                    { 
                        showToast("Thank you for your report. We'll review it soon.")
                    },
                    { error -> 
                        showToast("Failed to submit report: ${error.message}")
                    }
                )
        }
    }
}

// Custom report dialog
class ReportBottomSheetDialog : BottomSheetDialogFragment() {
    private lateinit var binding: DialogReportBinding
    private var reportReasons: List<String> = emptyList()
    private var onReasonSelected: ((Int, String?) -> Unit)? = null
    
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        binding = DialogReportBinding.inflate(inflater, container, false)
        return binding.root
    }
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupReasonsList()
    }
    
    private fun setupReasonsList() {
        val adapter = ReportReasonsAdapter(reportReasons) { position ->
            if (reportReasons[position] == "Others") {
                showCustomReasonInput(position)
            } else {
                onReasonSelected?.invoke(position, null)
                dismiss()
            }
        }
        
        binding.recyclerViewReasons.adapter = adapter
        binding.recyclerViewReasons.layoutManager = LinearLayoutManager(requireContext())
    }
    
    private fun showCustomReasonInput(position: Int) {
        binding.layoutCustomReason.visibility = View.VISIBLE
        binding.buttonSubmitCustom.setOnClickListener {
            val customReason = binding.editTextCustomReason.text.toString().trim()
            if (customReason.isNotEmpty()) {
                onReasonSelected?.invoke(position, customReason)
                dismiss()
            } else {
                binding.editTextCustomReason.error = "Please provide a reason"
            }
        }
    }
    
    class Builder {
        private val dialog = ReportBottomSheetDialog()
        
        fun setTitle(title: String): Builder {
            // Set title in arguments
            return this
        }
        
        fun setMessage(message: String): Builder {
            // Set message in arguments
            return this
        }
        
        fun setReportReasons(reasons: List<String>): Builder {
            dialog.reportReasons = reasons
            return this
        }
        
        fun setOnReasonSelected(callback: (Int, String?) -> Unit): Builder {
            dialog.onReasonSelected = callback
            return this
        }
        
        fun build(): ReportBottomSheetDialog = dialog
    }
}
```

```javascript Web
import React, { useState } from 'react';

const REPORT_REASONS = [
  { value: 'community_guidelines', label: 'Against community guidelines' },
  { value: 'harassment', label: 'Harassment or bullying' },
  { value: 'self_harm', label: 'Self-harm or suicide' },
  { value: 'violence', label: 'Violence or threatening content' },
  { value: 'restricted_items', label: 'Selling/restricted items' },
  { value: 'sexual_content', label: 'Sexual content or nudity' },
  { value: 'spam', label: 'Spam or scams' },
  { value: 'misinformation', label: 'False information/misinformation' },
  { value: 'other', label: 'Others' }
];

function ReportModal({ isOpen, onClose, contentType, contentId, onReportSubmitted }) {
  const [selectedReason, setSelectedReason] = useState('');
  const [customReason, setCustomReason] = useState('');
  const [submitting, setSubmitting] = useState(false);

  const handleSubmit = async (event) => {
    event.preventDefault();
    
    if (!selectedReason) {
      alert('Please select a reason for reporting');
      return;
    }
    
    if (selectedReason === 'other' && !customReason.trim()) {
      alert('Please provide a custom reason');
      return;
    }
    
    setSubmitting(true);
    
    try {
      await submitReport({
        contentType,
        contentId,
        reason: selectedReason,
        customReason: selectedReason === 'other' ? customReason.trim() : null
      });
      
      onReportSubmitted();
      showToast('Thank you for your report. We\'ll review it soon.');
      onClose();
    } catch (error) {
      console.error('Failed to submit report:', error);
      alert('Failed to submit report. Please try again.');
    } finally {
      setSubmitting(false);
    }
  };

  const resetForm = () => {
    setSelectedReason('');
    setCustomReason('');
  };

  if (!isOpen) return null;

  return (
    <div className="report-modal-overlay" onClick={onClose}>
      <div className="report-modal" onClick={e => e.stopPropagation()}>
        <div className="modal-header">
          <h3>Report {contentType}</h3>
          <button className="close-button" onClick={onClose}>×</button>
        </div>
        
        <div className="modal-content">
          <p>Why are you reporting this {contentType}?</p>
          
          <form onSubmit={handleSubmit}>
            <div className="report-reasons">
              {REPORT_REASONS.map((reason) => (
                <label key={reason.value} className="reason-option">
                  <input
                    type="radio"
                    name="reportReason"
                    value={reason.value}
                    checked={selectedReason === reason.value}
                    onChange={(e) => setSelectedReason(e.target.value)}
                  />
                  <span className="reason-label">{reason.label}</span>
                </label>
              ))}
            </div>
            
            {selectedReason === 'other' && (
              <div className="custom-reason-section">
                <label htmlFor="customReason">Please describe the issue:</label>
                <textarea
                  id="customReason"
                  value={customReason}
                  onChange={(e) => setCustomReason(e.target.value)}
                  placeholder="Describe the issue..."
                  maxLength={300}
                  rows={3}
                />
                <div className="character-count">
                  {customReason.length}/300
                </div>
              </div>
            )}
            
            <div className="modal-actions">
              <button
                type="button"
                onClick={() => {
                  resetForm();
                  onClose();
                }}
                disabled={submitting}
                className="cancel-button"
              >
                Cancel
              </button>
              <button
                type="submit"
                disabled={submitting || !selectedReason}
                className="submit-button"
              >
                {submitting ? 'Submitting...' : 'Submit Report'}
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
}

// Usage component for adding report functionality to posts/comments
function ReportButton({ contentType, contentId, className = '' }) {
  const [showReportModal, setShowReportModal] = useState(false);

  const handleReportSubmitted = () => {
    // Optionally update UI to show that content has been reported
    console.log(`${contentType} ${contentId} has been reported`);
  };

  return (
    <>
      <button
        className={`report-button ${className}`}
        onClick={() => setShowReportModal(true)}
        title={`Report ${contentType}`}
      >
        <ReportIcon size="small" />
        Report
      </button>
      
      <ReportModal
        isOpen={showReportModal}
        onClose={() => setShowReportModal(false)}
        contentType={contentType}
        contentId={contentId}
        onReportSubmitted={handleReportSubmitted}
      />
    </>
  );
}

// API function to submit reports
async function submitReport({ contentType, contentId, reason, customReason }) {
  const endpoint = contentType === 'post' ? '/api/reports/posts' : '/api/reports/comments';
  
  const response = await fetch(endpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${getAuthToken()}`
    },
    body: JSON.stringify({
      contentId,
      reason,
      customReason
    })
  });
  
  if (!response.ok) {
    throw new Error('Failed to submit report');
  }
  
  return response.json();
}

export { ReportModal, ReportButton, REPORT_REASONS };
```

```dart Flutter
import 'package:flutter/material.dart';
import 'package:amity_uikit_beta_service/amity_uikit_beta_service.dart';

enum ReportReason {
  communityGuidelines('community_guidelines', 'Against community guidelines'),
  harassment('harassment', 'Harassment or bullying'),
  selfHarm('self_harm', 'Self-harm or suicide'),
  violence('violence', 'Violence or threatening content'),
  restrictedItems('restricted_items', 'Selling/restricted items'),
  sexualContent('sexual_content', 'Sexual content or nudity'),
  spam('spam', 'Spam or scams'),
  misinformation('misinformation', 'False information/misinformation'),
  other('other', 'Others');

  const ReportReason(this.value, this.displayName);

  final String value;
  final String displayName;
}

class ReportManager {
  static void showReportOptions({
    required BuildContext context,
    required String contentType,
    required String contentId,
    VoidCallback? onReported,
  }) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) => ReportBottomSheet(
        contentType: contentType,
        contentId: contentId,
        onReported: onReported,
      ),
    );
  }
}

class ReportBottomSheet extends StatefulWidget {
  final String contentType;
  final String contentId;
  final VoidCallback? onReported;

  const ReportBottomSheet({
    Key? key,
    required this.contentType,
    required this.contentId,
    this.onReported,
  }) : super(key: key);

  @override
  _ReportBottomSheetState createState() => _ReportBottomSheetState();
}

class _ReportBottomSheetState extends State<ReportBottomSheet> {
  ReportReason? selectedReason;
  final TextEditingController customReasonController = TextEditingController();
  bool isSubmitting = false;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.only(
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      child: Container(
        padding: EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Report ${widget.contentType}',
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                IconButton(
                  onPressed: () => Navigator.pop(context),
                  icon: Icon(Icons.close),
                ),
              ],
            ),
            
            SizedBox(height: 8),
            
            Text(
              'Why are you reporting this ${widget.contentType}?',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            
            SizedBox(height: 16),
            
            // Report reasons
            ...ReportReason.values.map((reason) => 
              RadioListTile<ReportReason>(
                title: Text(reason.displayName),
                value: reason,
                groupValue: selectedReason,
                onChanged: (value) {
                  setState(() {
                    selectedReason = value;
                  });
                },
              ),
            ),
            
            // Custom reason input for "Others"
            if (selectedReason == ReportReason.other) ...[
              SizedBox(height: 16),
              TextField(
                controller: customReasonController,
                decoration: InputDecoration(
                  labelText: 'Please describe the issue',
                  hintText: 'Describe the issue...',
                  border: OutlineInputBorder(),
                  counterText: '${customReasonController.text.length}/300',
                ),
                maxLength: 300,
                maxLines: 3,
                onChanged: (value) => setState(() {}),
              ),
            ],
            
            SizedBox(height: 24),
            
            // Action buttons
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: isSubmitting ? null : () => Navigator.pop(context),
                  child: Text('Cancel'),
                ),
                
                SizedBox(width: 12),
                
                ElevatedButton(
                  onPressed: isSubmitting || selectedReason == null ? null : _submitReport,
                  child: isSubmitting 
                      ? SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : Text('Submit Report'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _submitReport() async {
    if (selectedReason == null) return;
    
    if (selectedReason == ReportReason.other && customReasonController.text.trim().isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Please provide a custom reason')),
      );
      return;
    }

    setState(() => isSubmitting = true);

    try {
      if (widget.contentType == 'post') {
        await AmityReportRepository.reportPost(
          widget.contentId,
          selectedReason!.value,
          selectedReason == ReportReason.other ? customReasonController.text.trim() : null,
        );
      } else {
        await AmityReportRepository.reportComment(
          widget.contentId,
          selectedReason!.value,
          selectedReason == ReportReason.other ? customReasonController.text.trim() : null,
        );
      }

      widget.onReported?.call();
      Navigator.pop(context);
      
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Thank you for your report. We\'ll review it soon.')),
      );
    } catch (error) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to submit report: $error')),
      );
    } finally {
      setState(() => isSubmitting = false);
    }
  }

  @override
  void dispose() {
    customReasonController.dispose();
    super.dispose();
  }
}

// Widget for adding report functionality to posts/comments
class ReportButton extends StatelessWidget {
  final String contentType;
  final String contentId;
  final VoidCallback? onReported;

  const ReportButton({
    Key? key,
    required this.contentType,
    required this.contentId,
    this.onReported,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return IconButton(
      onPressed: () {
        ReportManager.showReportOptions(
          context: context,
          contentType: contentType,
          contentId: contentId,
          onReported: onReported,
        );
      },
      icon: Icon(Icons.flag_outlined),
      tooltip: 'Report $contentType',
    );
  }
}
```
</CodeGroup>

### Report Management Dashboard

Administrative interface for reviewing and managing reports.

<CodeGroup>
```swift iOS
class ReportManagementViewController: UIViewController {
    private var reports: [AmityReport] = []
    private let tableView = UITableView()
    private let segmentedControl = UISegmentedControl(items: ["Pending", "Reviewed", "All"])
    private var currentFilter: ReportStatus = .pending
    
    enum ReportStatus {
        case pending
        case reviewed
        case all
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        loadReports()
    }
    
    private func setupUI() {
        title = "Content Reports"
        
        // Filter control
        segmentedControl.selectedSegmentIndex = 0
        segmentedControl.addTarget(self, action: #selector(filterChanged), for: .valueChanged)
        
        // Table view
        tableView.delegate = self
        tableView.dataSource = self
        tableView.register(ReportTableViewCell.self, forCellReuseIdentifier: "ReportCell")
        
        // Layout
        let stackView = UIStackView(arrangedSubviews: [segmentedControl, tableView])
        stackView.axis = .vertical
        stackView.spacing = 16
        
        view.addSubview(stackView)
        stackView.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            stackView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 16),
            stackView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            stackView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            stackView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])
    }
    
    @objc private func filterChanged() {
        switch segmentedControl.selectedSegmentIndex {
        case 0: currentFilter = .pending
        case 1: currentFilter = .reviewed
        default: currentFilter = .all
        }
        loadReports()
    }
    
    private func loadReports() {
        AmityReportRepository().getReports(status: currentFilter) { [weak self] result in
            DispatchQueue.main.async {
                switch result {
                case .success(let reportList):
                    self?.reports = reportList
                    self?.tableView.reloadData()
                case .failure(let error):
                    self?.showError("Failed to load reports: \(error.localizedDescription)")
                }
            }
        }
    }
    
    private func handleReport(_ report: AmityReport, action: ReportAction) {
        let alertController = UIAlertController(
            title: "Confirm Action",
            message: "Are you sure you want to \(action.rawValue) this report?",
            preferredStyle: .alert
        )
        
        alertController.addAction(UIAlertAction(title: "Cancel", style: .cancel))
        alertController.addAction(UIAlertAction(title: action.rawValue.capitalized, style: .default) { [weak self] _ in
            self?.performReportAction(report, action: action)
        })
        
        present(alertController, animated: true)
    }
    
    private func performReportAction(_ report: AmityReport, action: ReportAction) {
        AmityReportRepository().updateReportStatus(
            reportId: report.id,
            action: action
        ) { [weak self] result in
            DispatchQueue.main.async {
                switch result {
                case .success:
                    self?.loadReports() // Refresh list
                    self?.showSuccess("Report \(action.rawValue)d successfully")
                case .failure(let error):
                    self?.showError("Failed to \(action.rawValue) report: \(error.localizedDescription)")
                }
            }
        }
    }
}

enum ReportAction: String {
    case approve = "approve"
    case reject = "reject"
    case remove = "remove"
}

// MARK: - TableView DataSource & Delegate
extension ReportManagementViewController: UITableViewDataSource, UITableViewDelegate {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return reports.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "ReportCell", for: indexPath) as! ReportTableViewCell
        let report = reports[indexPath.row]
        
        cell.configure(
            report: report,
            onActionTapped: { [weak self] action in
                self?.handleReport(report, action: action)
            }
        )
        
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
        let report = reports[indexPath.row]
        
        // Show detailed report view
        let detailViewController = ReportDetailViewController(report: report)
        navigationController?.pushViewController(detailViewController, animated: true)
    }
}
```

```javascript Web
function ReportManagementDashboard() {
  const [reports, setReports] = useState([]);
  const [filteredReports, setFilteredReports] = useState([]);
  const [filter, setFilter] = useState('pending');
  const [loading, setLoading] = useState(true);
  const [selectedReports, setSelectedReports] = useState([]);

  useEffect(() => {
    loadReports();
  }, []);

  useEffect(() => {
    filterReports();
  }, [reports, filter]);

  const loadReports = async () => {
    try {
      const reportsData = await getReports();
      setReports(reportsData);
    } catch (error) {
      console.error('Failed to load reports:', error);
    } finally {
      setLoading(false);
    }
  };

  const filterReports = () => {
    let filtered = reports;
    
    switch (filter) {
      case 'pending':
        filtered = reports.filter(report => report.status === 'pending');
        break;
      case 'reviewed':
        filtered = reports.filter(report => report.status === 'reviewed');
        break;
      case 'approved':
        filtered = reports.filter(report => report.action === 'approved');
        break;
      case 'removed':
        filtered = reports.filter(report => report.action === 'removed');
        break;
      default:
        filtered = reports;
    }
    
    setFilteredReports(filtered);
  };

  const handleReportAction = async (reportId, action) => {
    try {
      await updateReportStatus(reportId, action);
      await loadReports(); // Refresh data
      showToast(`Report ${action} successfully`);
    } catch (error) {
      console.error(`Failed to ${action} report:`, error);
      showToast(`Failed to ${action} report`, 'error');
    }
  };

  const handleBulkAction = async (action) => {
    if (selectedReports.length === 0) return;
    
    if (!confirm(`Are you sure you want to ${action} ${selectedReports.length} reports?`)) {
      return;
    }

    try {
      await Promise.all(selectedReports.map(reportId => 
        updateReportStatus(reportId, action)
      ));
      
      setSelectedReports([]);
      await loadReports();
      showToast(`${selectedReports.length} reports ${action}d successfully`);
    } catch (error) {
      console.error(`Bulk ${action} failed:`, error);
      showToast(`Failed to ${action} reports`, 'error');
    }
  };

  if (loading) return <div>Loading reports...</div>;

  return (
    <div className="report-management-dashboard">
      <div className="dashboard-header">
        <h1>Content Reports</h1>
        
        <div className="filter-controls">
          <select value={filter} onChange={(e) => setFilter(e.target.value)}>
            <option value="all">All Reports</option>
            <option value="pending">Pending Review</option>
            <option value="reviewed">Reviewed</option>
            <option value="approved">Approved</option>
            <option value="removed">Content Removed</option>
          </select>
        </div>
      </div>

      <div className="reports-stats">
        <div className="stat">
          <strong>{reports.filter(r => r.status === 'pending').length}</strong>
          <span>Pending</span>
        </div>
        <div className="stat">
          <strong>{reports.filter(r => r.status === 'reviewed').length}</strong>
          <span>Reviewed</span>
        </div>
        <div className="stat">
          <strong>{reports.filter(r => r.action === 'removed').length}</strong>
          <span>Removed</span>
        </div>
      </div>

      {selectedReports.length > 0 && (
        <div className="bulk-actions">
          <span>{selectedReports.length} selected</span>
          <div className="action-buttons">
            <button onClick={() => handleBulkAction('approve')}>
              Approve Selected
            </button>
            <button onClick={() => handleBulkAction('remove')} className="danger">
              Remove Selected
            </button>
          </div>
        </div>
      )}

      <div className="reports-table">
        <table>
          <thead>
            <tr>
              <th>
                <input
                  type="checkbox"
                  onChange={(e) => {
                    if (e.target.checked) {
                      setSelectedReports(filteredReports.map(r => r.id));
                    } else {
                      setSelectedReports([]);
                    }
                  }}
                />
              </th>
              <th>Content</th>
              <th>Reason</th>
              <th>Reporter</th>
              <th>Date</th>
              <th>Status</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {filteredReports.map(report => (
              <ReportTableRow
                key={report.id}
                report={report}
                isSelected={selectedReports.includes(report.id)}
                onSelect={(isSelected) => {
                  if (isSelected) {
                    setSelectedReports(prev => [...prev, report.id]);
                  } else {
                    setSelectedReports(prev => prev.filter(id => id !== report.id));
                  }
                }}
                onAction={handleReportAction}
              />
            ))}
          </tbody>
        </table>
      </div>

      {filteredReports.length === 0 && (
        <div className="empty-state">
          <p>No reports found for the selected filter</p>
        </div>
      )}
    </div>
  );
}

function ReportTableRow({ report, isSelected, onSelect, onAction }) {
  const [showDetails, setShowDetails] = useState(false);

  return (
    <>
      <tr className={`report-row ${report.status}`}>
        <td>
          <input
            type="checkbox"
            checked={isSelected}
            onChange={(e) => onSelect(e.target.checked)}
          />
        </td>
        <td>
          <div className="content-preview">
            <span className="content-type">{report.contentType}</span>
            <p className="content-text">
              {report.content.substring(0, 100)}
              {report.content.length > 100 && '...'}
            </p>
          </div>
        </td>
        <td>
          <div className="report-reason">
            <span className="reason-category">{report.reason}</span>
            {report.customReason && (
              <p className="custom-reason">{report.customReason}</p>
            )}
          </div>
        </td>
        <td>
          <div className="reporter-info">
            <span className="reporter-name">{report.reporter.displayName}</span>
            <span className="reporter-id">@{report.reporter.username}</span>
          </div>
        </td>
        <td>{formatDate(report.createdAt)}</td>
        <td>
          <span className={`status-badge ${report.status}`}>
            {report.status}
          </span>
        </td>
        <td>
          <div className="action-buttons">
            <button onClick={() => setShowDetails(true)}>
              View
            </button>
            
            {report.status === 'pending' && (
              <>
                <button
                  onClick={() => onAction(report.id, 'approve')}
                  className="approve"
                >
                  Approve
                </button>
                <button
                  onClick={() => onAction(report.id, 'remove')}
                  className="remove"
                >
                  Remove
                </button>
              </>
            )}
          </div>
        </td>
      </tr>
      
      {showDetails && (
        <ReportDetailModal
          report={report}
          onClose={() => setShowDetails(false)}
          onAction={onAction}
        />
      )}
    </>
  );
}
```
</CodeGroup>

## Automated Moderation

### Content Filtering

Implement automated content filtering and moderation rules.

<Tabs>
  <Tab title="Word Filter">
    ```javascript
    class ContentModerationService {
      constructor() {
        this.bannedWords = new Set([
          // Profanity, hate speech, etc.
          'spam', 'scam', 'hate', 'violence'
        ]);
        
        this.suspiciousPatterns = [
          /\b(?:buy|sell|discount|offer|deal)\s+(?:now|today|cheap)\b/gi,
          /\b(?:click|visit|goto)\s+(?:link|url|website)\b/gi,
          /\b(?:free|win|winner|prize|lottery)\b/gi
        ];
      }

      moderateContent(text) {
        const result = {
          isApproved: true,
          violations: [],
          suggestedAction: 'approve',
          confidence: 0
        };

        // Check for banned words
        const words = text.toLowerCase().split(/\s+/);
        const foundBannedWords = words.filter(word => this.bannedWords.has(word));
        
        if (foundBannedWords.length > 0) {
          result.violations.push({
            type: 'banned_words',
            words: foundBannedWords,
            severity: 'high'
          });
          result.isApproved = false;
          result.suggestedAction = 'remove';
          result.confidence = 0.9;
        }

        // Check suspicious patterns
        for (const pattern of this.suspiciousPatterns) {
          const matches = text.match(pattern);
          if (matches) {
            result.violations.push({
              type: 'suspicious_pattern',
              matches: matches,
              severity: 'medium'
            });
            result.confidence = Math.max(result.confidence, 0.6);
            
            if (!result.isApproved) {
              result.suggestedAction = 'review';
            }
          }
        }

        // Check for excessive caps
        const capsRatio = (text.match(/[A-Z]/g) || []).length / text.length;
        if (capsRatio > 0.7 && text.length > 20) {
          result.violations.push({
            type: 'excessive_caps',
            ratio: capsRatio,
            severity: 'low'
          });
          result.confidence = Math.max(result.confidence, 0.3);
        }

        return result;
      }

      async moderateImage(imageData) {
        try {
          // Use ML service for image moderation
          const response = await fetch('/api/moderation/image', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ image: imageData })
          });
          
          const result = await response.json();
          return {
            isApproved: result.safe,
            violations: result.violations || [],
            suggestedAction: result.safe ? 'approve' : 'review',
            confidence: result.confidence
          };
        } catch (error) {
          console.error('Image moderation failed:', error);
          return {
            isApproved: false,
            violations: [{ type: 'moderation_error' }],
            suggestedAction: 'review',
            confidence: 0
          };
        }
      }
    }
    ```
  </Tab>
  
  <Tab title="Spam Detection">
    ```javascript
    class SpamDetectionService {
      constructor() {
        this.userActivityCache = new Map();
        this.spamThresholds = {
          postsPerMinute: 5,
          commentsPerMinute: 10,
          duplicateContentThreshold: 0.8,
          linkRatio: 0.3
        };
      }

      detectSpam(content, userId) {
        const spamScore = this.calculateSpamScore(content, userId);
        const isSpam = spamScore > 0.7;
        
        return {
          isSpam,
          spamScore,
          reasons: this.getSpamReasons(content, userId),
          suggestedAction: this.getSuggestedAction(spamScore)
        };
      }

      calculateSpamScore(content, userId) {
        let score = 0;
        
        // Check posting frequency
        const userActivity = this.getUserActivity(userId);
        if (userActivity.postsInLastMinute > this.spamThresholds.postsPerMinute) {
          score += 0.4;
        }
        
        // Check for duplicate content
        const duplicateScore = this.checkDuplicateContent(content, userId);
        score += duplicateScore * 0.3;
        
        // Check link ratio
        const linkRatio = this.calculateLinkRatio(content);
        if (linkRatio > this.spamThresholds.linkRatio) {
          score += 0.3;
        }
        
        // Check for repetitive patterns
        const repetitiveScore = this.checkRepetitivePatterns(content);
        score += repetitiveScore * 0.2;
        
        return Math.min(score, 1);
      }

      checkDuplicateContent(content, userId) {
        const userActivity = this.getUserActivity(userId);
        const recentContent = userActivity.recentContent || [];
        
        let maxSimilarity = 0;
        for (const previous of recentContent) {
          const similarity = this.calculateSimilarity(content, previous);
          maxSimilarity = Math.max(maxSimilarity, similarity);
        }
        
        return maxSimilarity;
      }

      calculateLinkRatio(content) {
        const words = content.split(/\s+/);
        const links = content.match(/https?:\/\/[^\s]+/g) || [];
        return words.length > 0 ? links.length / words.length : 0;
      }

      checkRepetitivePatterns(content) {
        // Check for repeated characters
        const repeatedChars = content.match(/(.)\1{3,}/g) || [];
        
        // Check for repeated words
        const words = content.toLowerCase().split(/\s+/);
        const wordCounts = {};
        words.forEach(word => {
          wordCounts[word] = (wordCounts[word] || 0) + 1;
        });
        
        const maxWordCount = Math.max(...Object.values(wordCounts));
        const repetitiveWords = maxWordCount > words.length * 0.3;
        
        return (repeatedChars.length > 0 || repetitiveWords) ? 1 : 0;
      }

      getSuggestedAction(spamScore) {
        if (spamScore > 0.8) return 'remove';
        if (spamScore > 0.5) return 'review';
        return 'approve';
      }
    }
    ```
  </Tab>
</Tabs>

## Platform Support

| Feature | iOS | Android | Web | Flutter | React Native |
|---------|-----|---------|-----|---------|--------------|
| Content Reporting | ✅ | ✅ | ✅ | ✅ | ✅ |
| Report Management | ✅ | ✅ | ✅ | - | - |
| Advanced Reporting | ✅ | ✅ | ✅ | - | - |
| Automated Filtering | ✅ | ✅ | ✅ | - | - |
| Spam Detection | ✅ | ✅ | ✅ | - | - |
| Image Moderation | ✅ | ✅ | ✅ | - | - |
| Bulk Actions | ✅ | ✅ | ✅ | - | - |
| Moderation Analytics | ✅ | ✅ | ✅ | - | - |

## Best Practices

<Warning>
  Always maintain transparency with users about content moderation policies and provide clear appeal processes for moderation decisions.
</Warning>

### Moderation Strategy

- **Clear Guidelines**: Establish and communicate community standards
- **Graduated Responses**: Use escalating moderation actions (warning → temporary restriction → permanent ban)
- **Human Oversight**: Combine automated filtering with human review
- **Appeal Process**: Provide mechanisms for users to appeal moderation decisions

### Technical Implementation

- **Performance**: Implement efficient filtering algorithms to avoid impacting user experience
- **Accuracy**: Balance false positives and false negatives in automated moderation
- **Scalability**: Design moderation systems to handle growing content volumes
- **Privacy**: Ensure moderation processes respect user privacy and data protection

### Community Management

- **Proactive Moderation**: Address potential issues before they escalate
- **Consistent Enforcement**: Apply rules fairly and consistently across all users
- **Community Involvement**: Allow community members to participate in moderation through reporting
- **Regular Updates**: Keep moderation policies current with evolving community needs

## Troubleshooting

### Common Issues

<Accordion title="Reports not being submitted">
  Check API connectivity, user authentication, and ensure all required fields are provided in the report request.
</Accordion>

<Accordion title="Automated moderation too strict/lenient">
  Adjust filtering thresholds based on community feedback and false positive/negative rates.
</Accordion>

<Accordion title="Moderation queue overloaded">
  Implement priority systems, improve automated filtering accuracy, and consider adding more moderators.
</Accordion>

<Accordion title="Users circumventing filters">
  Regularly update filter rules, implement pattern detection, and use machine learning for adaptive filtering.
</Accordion>

## Related Documentation

<CardGroup cols={2}>
  <Card title="Posts" href="/uikit/components/social/posts">
    Learn about post-level moderation features
  </Card>
  <Card title="Comments & Reactions" href="/uikit/components/social/comments-reactions">
    Understand comment moderation and reporting
  </Card>
  <Card title="Communities" href="/uikit/components/social/communities">
    Community-specific moderation tools
  </Card>
  <Card title="Users" href="/uikit/components/social/users">
    User management and blocking features
  </Card>
</CardGroup>
